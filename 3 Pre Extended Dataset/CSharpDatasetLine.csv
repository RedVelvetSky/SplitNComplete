prefix,middle,suffix,filename
"using System;
using Microsoft.ML;
using Microsoft.ML.Data;
using Spectre.Console;
namespace TinyIDS.Services
{
    internal class ModelInferenceService
    {
        private readonly string _modelPath;
        private readonly MLContext _mlContext;
        private ITransformer _loadedModel;
        private PredictionEngine<PacketData, Prediction> _predictionEngine;
        public ModelInferenceService(ITransformer trainedModel)
        {
            _mlContext = new MLContext();
            _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(trainedModel);
            AnsiConsole.MarkupLine();
        }
        private void LoadModel()
        {
            if (!System.IO.File.Exists(_modelPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            try
            {
                DataViewSchema modelSchema;
                _loadedModel = _mlContext.Model.Load(_modelPath, out modelSchema);
                _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(_loadedModel);
                AnsiConsole.MarkupLine();
            }
            catch (Exception ex)
            {
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
                if (ex.InnerException != null)
                {
                    AnsiConsole.MarkupLine($);","}
            }
        }","public void Predict(PacketData packetData)
        {
            try
            {
                var prediction = _predictionEngine.Predict(packetData);
                string result = prediction.PredictedLabel ?  : ;
                string color = prediction.PredictedLabel ?  : ; 
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
            }
            catch (Exception ex)
            {
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
            }
        }
    }
    public class Prediction
    {
        [ColumnName()]
        public bool PredictedLabel { get; set; }
        public float Score { get; set; }
    }
}",ClassificationModelInferenceService.cs
"using System;
using Microsoft.ML;
using Microsoft.ML.Data;
using Spectre.Console;
namespace TinyIDS.Services
{
    internal class ModelInferenceService
    {
        private readonly string _modelPath;
        private readonly MLContext _mlContext;
        private ITransformer _loadedModel;
        private PredictionEngine<PacketData, Prediction> _predictionEngine;
        public ModelInferenceService(ITransformer trainedModel)
        {
            _mlContext = new MLContext();
            _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(trainedModel);
            AnsiConsole.MarkupLine();
        }
        private void LoadModel()
        {
            if (!System.IO.File.Exists(_modelPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            try
            {
                DataViewSchema modelSchema;
                _loadedModel = _mlContext.Model.Load(_modelPath, out modelSchema);
                _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(_loadedModel);
                AnsiConsole.MarkupLine();
            }
            catch (Exception ex)
            {
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
                if (ex.InnerException != null)
                {
                    AnsiConsole.MarkupLine($);
                }
            }
        }
        public void Predict(PacketData packetData)
        {
            try
            {
                var prediction = _predictionEngine.Predict(packetData);
                string result = prediction.PredictedLabel ?  : ;
                string color = prediction.PredictedLabel ?  : ; 
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
            }
            catch (Exception ex)
            {
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
            }","}
    }
    public class Prediction","{
        [ColumnName()]
        public bool PredictedLabel { get; set; }
        public float Score { get; set; }
    }
}",ClassificationModelInferenceService.cs
"using System;
using Microsoft.ML;
using Microsoft.ML.Data;
using Spectre.Console;
namespace TinyIDS.Services
{
    internal class ModelInferenceService
    {","private readonly string _modelPath;
        private readonly MLContext _mlContext;
        private ITransformer _loadedModel;","private PredictionEngine<PacketData, Prediction> _predictionEngine;
        public ModelInferenceService(ITransformer trainedModel)
        {
            _mlContext = new MLContext();
            _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(trainedModel);
            AnsiConsole.MarkupLine();
        }
        private void LoadModel()
        {
            if (!System.IO.File.Exists(_modelPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            try
            {
                DataViewSchema modelSchema;
                _loadedModel = _mlContext.Model.Load(_modelPath, out modelSchema);
                _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(_loadedModel);
                AnsiConsole.MarkupLine();
            }
            catch (Exception ex)
            {
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
                if (ex.InnerException != null)
                {
                    AnsiConsole.MarkupLine($);
                }
            }
        }
        public void Predict(PacketData packetData)
        {
            try
            {
                var prediction = _predictionEngine.Predict(packetData);
                string result = prediction.PredictedLabel ?  : ;
                string color = prediction.PredictedLabel ?  : ; 
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
            }
            catch (Exception ex)
            {
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
            }
        }
    }
    public class Prediction
    {
        [ColumnName()]
        public bool PredictedLabel { get; set; }
        public float Score { get; set; }
    }
}",ClassificationModelInferenceService.cs
"using System;
using Microsoft.ML;
using Microsoft.ML.Data;
using Spectre.Console;
namespace TinyIDS.Services
{
    internal class ModelInferenceService
    {
        private readonly string _modelPath;
        private readonly MLContext _mlContext;
        private ITransformer _loadedModel;
        private PredictionEngine<PacketData, Prediction> _predictionEngine;
        public ModelInferenceService(ITransformer trainedModel)
        {
            _mlContext = new MLContext();
            _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(trainedModel);
            AnsiConsole.MarkupLine();
        }
        private void LoadModel()
        {
            if (!System.IO.File.Exists(_modelPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            try
            {
                DataViewSchema modelSchema;
                _loadedModel = _mlContext.Model.Load(_modelPath, out modelSchema);
                _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(_loadedModel);
                AnsiConsole.MarkupLine();
            }
            catch (Exception ex)
            {
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
                if (ex.InnerException != null)
                {
                    AnsiConsole.MarkupLine($);
                }
            }
        }
        public void Predict(PacketData packetData)
        {
            try
            {","var prediction = _predictionEngine.Predict(packetData);
                string result = prediction.PredictedLabel ?  : ;
                string color = prediction.PredictedLabel ?  : ;","Console.WriteLine();
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
            }
            catch (Exception ex)
            {
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
            }
        }
    }
    public class Prediction
    {
        [ColumnName()]
        public bool PredictedLabel { get; set; }
        public float Score { get; set; }
    }
}",ClassificationModelInferenceService.cs
"using System;
using Microsoft.ML;
using Microsoft.ML.Data;
using Spectre.Console;
namespace TinyIDS.Services
{
    internal class ModelInferenceService
    {
        private readonly string _modelPath;
        private readonly MLContext _mlContext;
        private ITransformer _loadedModel;
        private PredictionEngine<PacketData, Prediction> _predictionEngine;
        public ModelInferenceService(ITransformer trainedModel)
        {
            _mlContext = new MLContext();
            _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(trainedModel);
            AnsiConsole.MarkupLine();
        }
        private void LoadModel()
        {
            if (!System.IO.File.Exists(_modelPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            try","{
                DataViewSchema modelSchema;
                _loadedModel = _mlContext.Model.Load(_modelPath, out modelSchema);","_predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(_loadedModel);
                AnsiConsole.MarkupLine();
            }
            catch (Exception ex)
            {
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
                if (ex.InnerException != null)
                {
                    AnsiConsole.MarkupLine($);
                }
            }
        }
        public void Predict(PacketData packetData)
        {
            try
            {
                var prediction = _predictionEngine.Predict(packetData);
                string result = prediction.PredictedLabel ?  : ;
                string color = prediction.PredictedLabel ?  : ; 
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
            }
            catch (Exception ex)
            {
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
            }
        }
    }
    public class Prediction
    {
        [ColumnName()]
        public bool PredictedLabel { get; set; }
        public float Score { get; set; }
    }
}",ClassificationModelInferenceService.cs
"using System;
using Microsoft.ML;
using Microsoft.ML.Data;
using Spectre.Console;
namespace TinyIDS.Services
{
    internal class ModelInferenceService
    {
        private readonly string _modelPath;
        private readonly MLContext _mlContext;
        private ITransformer _loadedModel;
        private PredictionEngine<PacketData, Prediction> _predictionEngine;","public ModelInferenceService(ITransformer trainedModel)
        {
            _mlContext = new MLContext();","_predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(trainedModel);
            AnsiConsole.MarkupLine();
        }
        private void LoadModel()
        {
            if (!System.IO.File.Exists(_modelPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            try
            {
                DataViewSchema modelSchema;
                _loadedModel = _mlContext.Model.Load(_modelPath, out modelSchema);
                _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(_loadedModel);
                AnsiConsole.MarkupLine();
            }
            catch (Exception ex)
            {
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
                if (ex.InnerException != null)
                {
                    AnsiConsole.MarkupLine($);
                }
            }
        }
        public void Predict(PacketData packetData)
        {
            try
            {
                var prediction = _predictionEngine.Predict(packetData);
                string result = prediction.PredictedLabel ?  : ;
                string color = prediction.PredictedLabel ?  : ; 
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
            }
            catch (Exception ex)
            {
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
            }
        }
    }
    public class Prediction
    {
        [ColumnName()]
        public bool PredictedLabel { get; set; }
        public float Score { get; set; }
    }
}",ClassificationModelInferenceService.cs
"using System;
using Microsoft.ML;
using Microsoft.ML.Data;
using Spectre.Console;
namespace TinyIDS.Services
{
    internal class ModelInferenceService
    {
        private readonly string _modelPath;
        private readonly MLContext _mlContext;
        private ITransformer _loadedModel;
        private PredictionEngine<PacketData, Prediction> _predictionEngine;
        public ModelInferenceService(ITransformer trainedModel)
        {
            _mlContext = new MLContext();
            _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(trainedModel);
            AnsiConsole.MarkupLine();
        }
        private void LoadModel()
        {
            if (!System.IO.File.Exists(_modelPath))
            {
                AnsiConsole.MarkupLine($);","return;
            }
            try","{
                DataViewSchema modelSchema;
                _loadedModel = _mlContext.Model.Load(_modelPath, out modelSchema);
                _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(_loadedModel);
                AnsiConsole.MarkupLine();
            }
            catch (Exception ex)
            {
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
                if (ex.InnerException != null)
                {
                    AnsiConsole.MarkupLine($);
                }
            }
        }
        public void Predict(PacketData packetData)
        {
            try
            {
                var prediction = _predictionEngine.Predict(packetData);
                string result = prediction.PredictedLabel ?  : ;
                string color = prediction.PredictedLabel ?  : ; 
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
            }
            catch (Exception ex)
            {
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
            }
        }
    }
    public class Prediction
    {
        [ColumnName()]
        public bool PredictedLabel { get; set; }
        public float Score { get; set; }
    }
}",ClassificationModelInferenceService.cs
"using System;
using Microsoft.ML;
using Microsoft.ML.Data;
using Spectre.Console;
namespace TinyIDS.Services
{
    internal class ModelInferenceService
    {
        private readonly string _modelPath;
        private readonly MLContext _mlContext;
        private ITransformer _loadedModel;
        private PredictionEngine<PacketData, Prediction> _predictionEngine;
        public ModelInferenceService(ITransformer trainedModel)
        {
            _mlContext = new MLContext();
            _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(trainedModel);
            AnsiConsole.MarkupLine();
        }
        private void LoadModel()
        {
            if (!System.IO.File.Exists(_modelPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            try
            {
                DataViewSchema modelSchema;
                _loadedModel = _mlContext.Model.Load(_modelPath, out modelSchema);
                _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(_loadedModel);
                AnsiConsole.MarkupLine();
            }","catch (Exception ex)
            {
                AnsiConsole.MarkupLine($);","AnsiConsole.MarkupLine($);
                if (ex.InnerException != null)
                {
                    AnsiConsole.MarkupLine($);
                }
            }
        }
        public void Predict(PacketData packetData)
        {
            try
            {
                var prediction = _predictionEngine.Predict(packetData);
                string result = prediction.PredictedLabel ?  : ;
                string color = prediction.PredictedLabel ?  : ; 
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
            }
            catch (Exception ex)
            {
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
            }
        }
    }
    public class Prediction
    {
        [ColumnName()]
        public bool PredictedLabel { get; set; }
        public float Score { get; set; }
    }
}",ClassificationModelInferenceService.cs
"using System;
using Microsoft.ML;
using Microsoft.ML.Data;
using Spectre.Console;
namespace TinyIDS.Services
{
    internal class ModelInferenceService","{
        private readonly string _modelPath;
        private readonly MLContext _mlContext;","private ITransformer _loadedModel;
        private PredictionEngine<PacketData, Prediction> _predictionEngine;
        public ModelInferenceService(ITransformer trainedModel)
        {
            _mlContext = new MLContext();
            _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(trainedModel);
            AnsiConsole.MarkupLine();
        }
        private void LoadModel()
        {
            if (!System.IO.File.Exists(_modelPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            try
            {
                DataViewSchema modelSchema;
                _loadedModel = _mlContext.Model.Load(_modelPath, out modelSchema);
                _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(_loadedModel);
                AnsiConsole.MarkupLine();
            }
            catch (Exception ex)
            {
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
                if (ex.InnerException != null)
                {
                    AnsiConsole.MarkupLine($);
                }
            }
        }
        public void Predict(PacketData packetData)
        {
            try
            {
                var prediction = _predictionEngine.Predict(packetData);
                string result = prediction.PredictedLabel ?  : ;
                string color = prediction.PredictedLabel ?  : ; 
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
            }
            catch (Exception ex)
            {
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
            }
        }
    }
    public class Prediction
    {
        [ColumnName()]
        public bool PredictedLabel { get; set; }
        public float Score { get; set; }
    }
}",ClassificationModelInferenceService.cs
"using System;
using Microsoft.ML;
using Microsoft.ML.Data;
using Spectre.Console;
namespace TinyIDS.Services
{
    internal class ModelInferenceService
    {
        private readonly string _modelPath;
        private readonly MLContext _mlContext;
        private ITransformer _loadedModel;
        private PredictionEngine<PacketData, Prediction> _predictionEngine;
        public ModelInferenceService(ITransformer trainedModel)
        {
            _mlContext = new MLContext();
            _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(trainedModel);
            AnsiConsole.MarkupLine();
        }
        private void LoadModel()
        {
            if (!System.IO.File.Exists(_modelPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            try
            {
                DataViewSchema modelSchema;","_loadedModel = _mlContext.Model.Load(_modelPath, out modelSchema);
                _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(_loadedModel);
                AnsiConsole.MarkupLine();","}
            catch (Exception ex)
            {
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
                if (ex.InnerException != null)
                {
                    AnsiConsole.MarkupLine($);
                }
            }
        }
        public void Predict(PacketData packetData)
        {
            try
            {
                var prediction = _predictionEngine.Predict(packetData);
                string result = prediction.PredictedLabel ?  : ;
                string color = prediction.PredictedLabel ?  : ; 
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
            }
            catch (Exception ex)
            {
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
            }
        }
    }
    public class Prediction
    {
        [ColumnName()]
        public bool PredictedLabel { get; set; }
        public float Score { get; set; }
    }
}",ClassificationModelInferenceService.cs
"using System;
using Microsoft.ML;
using Microsoft.ML.Data;
using Spectre.Console;
namespace TinyIDS.Services
{
    internal class ModelInferenceService
    {
        private readonly string _modelPath;
        private readonly MLContext _mlContext;
        private ITransformer _loadedModel;
        private PredictionEngine<PacketData, Prediction> _predictionEngine;
        public ModelInferenceService(ITransformer trainedModel)
        {
            _mlContext = new MLContext();
            _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(trainedModel);
            AnsiConsole.MarkupLine();
        }
        private void LoadModel()
        {
            if (!System.IO.File.Exists(_modelPath))
            {
                AnsiConsole.MarkupLine($);
                return;","}
            try
            {","DataViewSchema modelSchema;
                _loadedModel = _mlContext.Model.Load(_modelPath, out modelSchema);
                _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(_loadedModel);
                AnsiConsole.MarkupLine();
            }
            catch (Exception ex)
            {
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
                if (ex.InnerException != null)
                {
                    AnsiConsole.MarkupLine($);
                }
            }
        }
        public void Predict(PacketData packetData)
        {
            try
            {
                var prediction = _predictionEngine.Predict(packetData);
                string result = prediction.PredictedLabel ?  : ;
                string color = prediction.PredictedLabel ?  : ; 
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
            }
            catch (Exception ex)
            {
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
            }
        }
    }
    public class Prediction
    {
        [ColumnName()]
        public bool PredictedLabel { get; set; }
        public float Score { get; set; }
    }
}",ClassificationModelInferenceService.cs
"using System;
using Microsoft.ML;","using Microsoft.ML.Data;
using Spectre.Console;
namespace TinyIDS.Services","{
    internal class ModelInferenceService
    {
        private readonly string _modelPath;
        private readonly MLContext _mlContext;
        private ITransformer _loadedModel;
        private PredictionEngine<PacketData, Prediction> _predictionEngine;
        public ModelInferenceService(ITransformer trainedModel)
        {
            _mlContext = new MLContext();
            _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(trainedModel);
            AnsiConsole.MarkupLine();
        }
        private void LoadModel()
        {
            if (!System.IO.File.Exists(_modelPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            try
            {
                DataViewSchema modelSchema;
                _loadedModel = _mlContext.Model.Load(_modelPath, out modelSchema);
                _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(_loadedModel);
                AnsiConsole.MarkupLine();
            }
            catch (Exception ex)
            {
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
                if (ex.InnerException != null)
                {
                    AnsiConsole.MarkupLine($);
                }
            }
        }
        public void Predict(PacketData packetData)
        {
            try
            {
                var prediction = _predictionEngine.Predict(packetData);
                string result = prediction.PredictedLabel ?  : ;
                string color = prediction.PredictedLabel ?  : ; 
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
            }
            catch (Exception ex)
            {
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
            }
        }
    }
    public class Prediction
    {
        [ColumnName()]
        public bool PredictedLabel { get; set; }
        public float Score { get; set; }
    }
}",ClassificationModelInferenceService.cs
"using System;
using Microsoft.ML;
using Microsoft.ML.Data;
using Spectre.Console;
namespace TinyIDS.Services
{
    internal class ModelInferenceService
    {
        private readonly string _modelPath;
        private readonly MLContext _mlContext;
        private ITransformer _loadedModel;
        private PredictionEngine<PacketData, Prediction> _predictionEngine;
        public ModelInferenceService(ITransformer trainedModel)
        {
            _mlContext = new MLContext();
            _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(trainedModel);
            AnsiConsole.MarkupLine();
        }
        private void LoadModel()
        {
            if (!System.IO.File.Exists(_modelPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            try
            {
                DataViewSchema modelSchema;
                _loadedModel = _mlContext.Model.Load(_modelPath, out modelSchema);
                _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(_loadedModel);
                AnsiConsole.MarkupLine();
            }
            catch (Exception ex)
            {
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
                if (ex.InnerException != null)
                {
                    AnsiConsole.MarkupLine($);
                }
            }
        }
        public void Predict(PacketData packetData)
        {
            try
            {
                var prediction = _predictionEngine.Predict(packetData);
                string result = prediction.PredictedLabel ?  : ;
                string color = prediction.PredictedLabel ?  : ; 
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
            }
            catch (Exception ex)
            {
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
            }
        }
    }
    public class Prediction
    {","[ColumnName()]
        public bool PredictedLabel { get; set; }
        public float Score { get; set; }","}
}",ClassificationModelInferenceService.cs
"using System;
using Microsoft.ML;
using Microsoft.ML.Data;
using Spectre.Console;
namespace TinyIDS.Services
{
    internal class ModelInferenceService
    {
        private readonly string _modelPath;
        private readonly MLContext _mlContext;
        private ITransformer _loadedModel;
        private PredictionEngine<PacketData, Prediction> _predictionEngine;
        public ModelInferenceService(ITransformer trainedModel)
        {
            _mlContext = new MLContext();
            _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(trainedModel);
            AnsiConsole.MarkupLine();
        }
        private void LoadModel()
        {
            if (!System.IO.File.Exists(_modelPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }","try
            {
                DataViewSchema modelSchema;","_loadedModel = _mlContext.Model.Load(_modelPath, out modelSchema);
                _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(_loadedModel);
                AnsiConsole.MarkupLine();
            }
            catch (Exception ex)
            {
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
                if (ex.InnerException != null)
                {
                    AnsiConsole.MarkupLine($);
                }
            }
        }
        public void Predict(PacketData packetData)
        {
            try
            {
                var prediction = _predictionEngine.Predict(packetData);
                string result = prediction.PredictedLabel ?  : ;
                string color = prediction.PredictedLabel ?  : ; 
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
            }
            catch (Exception ex)
            {
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
            }
        }
    }
    public class Prediction
    {
        [ColumnName()]
        public bool PredictedLabel { get; set; }
        public float Score { get; set; }
    }
}",ClassificationModelInferenceService.cs
"using System;
using Microsoft.ML;
using Microsoft.ML.Data;
using Spectre.Console;
namespace TinyIDS.Services
{
    internal class ModelInferenceService
    {
        private readonly string _modelPath;
        private readonly MLContext _mlContext;
        private ITransformer _loadedModel;
        private PredictionEngine<PacketData, Prediction> _predictionEngine;
        public ModelInferenceService(ITransformer trainedModel)
        {
            _mlContext = new MLContext();
            _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(trainedModel);
            AnsiConsole.MarkupLine();
        }
        private void LoadModel()
        {
            if (!System.IO.File.Exists(_modelPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            try
            {
                DataViewSchema modelSchema;
                _loadedModel = _mlContext.Model.Load(_modelPath, out modelSchema);
                _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(_loadedModel);
                AnsiConsole.MarkupLine();
            }
            catch (Exception ex)
            {
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
                if (ex.InnerException != null)
                {
                    AnsiConsole.MarkupLine($);
                }","}
        }
        public void Predict(PacketData packetData)","{
            try
            {
                var prediction = _predictionEngine.Predict(packetData);
                string result = prediction.PredictedLabel ?  : ;
                string color = prediction.PredictedLabel ?  : ; 
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
            }
            catch (Exception ex)
            {
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
            }
        }
    }
    public class Prediction
    {
        [ColumnName()]
        public bool PredictedLabel { get; set; }
        public float Score { get; set; }
    }
}",ClassificationModelInferenceService.cs
"using System;
using Microsoft.ML;
using Microsoft.ML.Data;
using Spectre.Console;
namespace TinyIDS.Services
{
    internal class ModelInferenceService
    {
        private readonly string _modelPath;
        private readonly MLContext _mlContext;
        private ITransformer _loadedModel;
        private PredictionEngine<PacketData, Prediction> _predictionEngine;
        public ModelInferenceService(ITransformer trainedModel)
        {
            _mlContext = new MLContext();
            _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(trainedModel);
            AnsiConsole.MarkupLine();
        }
        private void LoadModel()
        {
            if (!System.IO.File.Exists(_modelPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            try
            {
                DataViewSchema modelSchema;
                _loadedModel = _mlContext.Model.Load(_modelPath, out modelSchema);
                _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(_loadedModel);
                AnsiConsole.MarkupLine();
            }
            catch (Exception ex)
            {
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
                if (ex.InnerException != null)
                {
                    AnsiConsole.MarkupLine($);
                }
            }
        }
        public void Predict(PacketData packetData)
        {
            try","{
                var prediction = _predictionEngine.Predict(packetData);
                string result = prediction.PredictedLabel ?  : ;","string color = prediction.PredictedLabel ?  : ; 
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
            }
            catch (Exception ex)
            {
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
            }
        }
    }
    public class Prediction
    {
        [ColumnName()]
        public bool PredictedLabel { get; set; }
        public float Score { get; set; }
    }
}",ClassificationModelInferenceService.cs
"using System;
using Microsoft.ML;
using Microsoft.ML.Data;
using Spectre.Console;
namespace TinyIDS.Services
{
    internal class ModelInferenceService
    {
        private readonly string _modelPath;
        private readonly MLContext _mlContext;
        private ITransformer _loadedModel;
        private PredictionEngine<PacketData, Prediction> _predictionEngine;
        public ModelInferenceService(ITransformer trainedModel)
        {
            _mlContext = new MLContext();
            _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(trainedModel);
            AnsiConsole.MarkupLine();
        }
        private void LoadModel()
        {
            if (!System.IO.File.Exists(_modelPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            try
            {
                DataViewSchema modelSchema;
                _loadedModel = _mlContext.Model.Load(_modelPath, out modelSchema);
                _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(_loadedModel);
                AnsiConsole.MarkupLine();
            }
            catch (Exception ex)
            {
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
                if (ex.InnerException != null)
                {
                    AnsiConsole.MarkupLine($);
                }
            }
        }
        public void Predict(PacketData packetData)
        {
            try
            {
                var prediction = _predictionEngine.Predict(packetData);
                string result = prediction.PredictedLabel ?  : ;
                string color = prediction.PredictedLabel ?  : ; 
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
            }
            catch (Exception ex)","{
                Console.WriteLine();
                AnsiConsole.MarkupLine($);","}
        }
    }
    public class Prediction
    {
        [ColumnName()]
        public bool PredictedLabel { get; set; }
        public float Score { get; set; }
    }
}",ClassificationModelInferenceService.cs
"using System;
using Microsoft.ML;
using Microsoft.ML.Data;
using Spectre.Console;
namespace TinyIDS.Services
{
    internal class ModelInferenceService
    {
        private readonly string _modelPath;
        private readonly MLContext _mlContext;
        private ITransformer _loadedModel;
        private PredictionEngine<PacketData, Prediction> _predictionEngine;
        public ModelInferenceService(ITransformer trainedModel)
        {
            _mlContext = new MLContext();
            _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(trainedModel);","AnsiConsole.MarkupLine();
        }
        private void LoadModel()","{
            if (!System.IO.File.Exists(_modelPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            try
            {
                DataViewSchema modelSchema;
                _loadedModel = _mlContext.Model.Load(_modelPath, out modelSchema);
                _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(_loadedModel);
                AnsiConsole.MarkupLine();
            }
            catch (Exception ex)
            {
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
                if (ex.InnerException != null)
                {
                    AnsiConsole.MarkupLine($);
                }
            }
        }
        public void Predict(PacketData packetData)
        {
            try
            {
                var prediction = _predictionEngine.Predict(packetData);
                string result = prediction.PredictedLabel ?  : ;
                string color = prediction.PredictedLabel ?  : ; 
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
            }
            catch (Exception ex)
            {
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
            }
        }
    }
    public class Prediction
    {
        [ColumnName()]
        public bool PredictedLabel { get; set; }
        public float Score { get; set; }
    }
}",ClassificationModelInferenceService.cs
"using System;
using Microsoft.ML;
using Microsoft.ML.Data;
using Spectre.Console;
namespace TinyIDS.Services
{
    internal class ModelInferenceService
    {
        private readonly string _modelPath;
        private readonly MLContext _mlContext;
        private ITransformer _loadedModel;
        private PredictionEngine<PacketData, Prediction> _predictionEngine;
        public ModelInferenceService(ITransformer trainedModel)
        {
            _mlContext = new MLContext();
            _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(trainedModel);
            AnsiConsole.MarkupLine();
        }
        private void LoadModel()
        {
            if (!System.IO.File.Exists(_modelPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            try
            {
                DataViewSchema modelSchema;
                _loadedModel = _mlContext.Model.Load(_modelPath, out modelSchema);
                _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(_loadedModel);
                AnsiConsole.MarkupLine();
            }
            catch (Exception ex)","{
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);","if (ex.InnerException != null)
                {
                    AnsiConsole.MarkupLine($);
                }
            }
        }
        public void Predict(PacketData packetData)
        {
            try
            {
                var prediction = _predictionEngine.Predict(packetData);
                string result = prediction.PredictedLabel ?  : ;
                string color = prediction.PredictedLabel ?  : ; 
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
            }
            catch (Exception ex)
            {
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
            }
        }
    }
    public class Prediction
    {
        [ColumnName()]
        public bool PredictedLabel { get; set; }
        public float Score { get; set; }
    }
}",ClassificationModelInferenceService.cs
"using System;
using Microsoft.ML;
using Microsoft.ML.Data;
using Spectre.Console;
namespace TinyIDS.Services
{
    internal class ModelInferenceService
    {
        private readonly string _modelPath;
        private readonly MLContext _mlContext;
        private ITransformer _loadedModel;
        private PredictionEngine<PacketData, Prediction> _predictionEngine;
        public ModelInferenceService(ITransformer trainedModel)
        {
            _mlContext = new MLContext();
            _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(trainedModel);
            AnsiConsole.MarkupLine();
        }
        private void LoadModel()
        {
            if (!System.IO.File.Exists(_modelPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            try
            {
                DataViewSchema modelSchema;
                _loadedModel = _mlContext.Model.Load(_modelPath, out modelSchema);
                _predictionEngine = _mlContext.Model.CreatePredictionEngine<PacketData, Prediction>(_loadedModel);
                AnsiConsole.MarkupLine();","}
            catch (Exception ex)
            {","AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
                if (ex.InnerException != null)
                {
                    AnsiConsole.MarkupLine($);
                }
            }
        }
        public void Predict(PacketData packetData)
        {
            try
            {
                var prediction = _predictionEngine.Predict(packetData);
                string result = prediction.PredictedLabel ?  : ;
                string color = prediction.PredictedLabel ?  : ; 
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
                AnsiConsole.MarkupLine($);
            }
            catch (Exception ex)
            {
                Console.WriteLine();
                AnsiConsole.MarkupLine($);
            }
        }
    }
    public class Prediction
    {
        [ColumnName()]
        public bool PredictedLabel { get; set; }
        public float Score { get; set; }
    }
}",ClassificationModelInferenceService.cs
"using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using CsvHelper;
using PacketDotNet;
using PcapDotNet.Packets;
using SharpPcap;
using SharpPcap.LibPcap;
using Spectre.Console;
using TinyIDS.Models;
using TinyIDS.Utils;
namespace TinyIDS.Services
{
    public enum CaptureMode
    {
        Csv,
        Cap,
        Flow
    }
    public class PacketCaptureService
    {
        private ICaptureDevice _device;
        private static CaptureFileWriterDevice captureFileWriter;
        private static StreamWriter csvWriter;
        private static CsvWriter csv;
        private static Verbosity _verbosity;
        private CaptureMode _captureMode;
        private static PacketProcessor _packetProcessor;
        private static Logger _logger;
        public PacketCaptureService(Verbosity verbosity)
        {
            _logger = new Logger(verbosity);
            _packetProcessor = new PacketProcessor(_logger, );
        }
        public void ListDevices()
        {
            var devices = CaptureDeviceList.Instance;
            if (devices.Count == 0)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            var table = new Table();
            table.AddColumn();
            table.AddColumn();
            foreach (var device in devices)
            {
                table.AddRow(device.Name, device.Description);
            }
            AnsiConsole.Write(table);
        }
        public void PrintSharpPcapVersion()
        {
            var ver = Pcap.SharpPcapVersion;
            Log($, Verbosity.Basic);
        }
        private LibPcapLiveDeviceList GetDevices()
        {
            return LibPcapLiveDeviceList.Instance;
        }
        private void DisplayAvailableDevices(LibPcapLiveDeviceList devices)
        {
            var table = new Table();
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            for (int i = 0; i < devices.Count; i++)
            {
                var dev = devices[i];
                table.AddRow(i.ToString(), dev.Name, dev.Description);
            }
            AnsiConsole.Write(table);
        }
        private int GetDeviceIndexFromUser()
        {
            return AnsiConsole.Prompt(
                new TextPrompt<int>()
                    .PromptStyle()
                    .Validate(index =>
                        index >= 0 ? ValidationResult.Success() : ValidationResult.Error()));
        }
        private string GetOutputFileNameFromUser(string fileType)
        {
            return AnsiConsole.Ask<string>($);
        }
        public void StartCapture(CaptureMode captureMode)
        {
            _captureMode = captureMode;
            Log(, Verbosity.Basic);
            PrintSharpPcapVersion();
            var devices = GetDevices();
            if (devices.Count < 1)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            DisplayAvailableDevices(devices);
            int deviceIndex = GetDeviceIndexFromUser();
            string capFile = null;
            string csvFile = null;
            if (_captureMode == CaptureMode.Cap)
            {
                capFile = GetOutputFileNameFromUser();
            }
            if (_captureMode == CaptureMode.Csv)
            {
                csvFile = GetOutputFileNameFromUser();
            }
            CapturePackets(devices[deviceIndex], capFile, csvFile);
        }
        private void CapturePackets(ICaptureDevice device, string capFile, string csvFile)
        {
            device.OnPacketArrival += new PacketArrivalEventHandler(device_OnPacketArrivalCapture);
            device.Open(DeviceModes.Promiscuous | DeviceModes.DataTransferUdp | DeviceModes.NoCaptureLocal, read_timeout: 1000);
            Log($, Verbosity.Basic);
            if (_captureMode == CaptureMode.Cap && capFile != null)
            {
                captureFileWriter = new CaptureFileWriterDevice(capFile);
                captureFileWriter.Open(device);
            }
            if (_captureMode == CaptureMode.Csv && csvFile != null)
            {
                csvWriter = new StreamWriter(csvFile);
                csv = new CsvWriter(csvWriter, CultureInfo.InvariantCulture);
                csv.WriteHeader<PacketRecord>();
                csv.NextRecord();
            }
            device.StartCapture();
            if (_verbosity >= Verbosity.Detailed)
            {
                Console.WriteLine();
                AnsiConsole.Write(
                 new Rule()
                     .RuleStyle()
                     .Centered());
                Console.WriteLine();
            }
            Console.ReadLine();
            device.StopCapture();
            if (_captureMode == CaptureMode.Cap && captureFileWriter != null)
            {
                captureFileWriter.Close();
            }
            if (_captureMode == CaptureMode.Csv && csvWriter != null)
            {
                csvWriter.Close();
            }
            Log(, Verbosity.Basic);
            LogDeviceStatistics(device.Statistics.ToString());
        }
        private static void device_OnPacketArrivalCapture(object sender, PacketCapture e)
        {
            var rawPacket = e.GetPacket();
            _packetProcessor.ProcessPacket(rawPacket);
            if (captureFileWriter != null)
            {
                captureFileWriter.Write(rawPacket);
            }
            if (rawPacket.LinkLayerType == PacketDotNet.LinkLayers.Ethernet)
            {
                var packet = PacketDotNet.Packet.ParsePacket(rawPacket.LinkLayerType, rawPacket.Data);
                var ethernetPacket = packet.Extract<EthernetPacket>();
                if (ethernetPacket != null)
                {
                    var ipPacket = ethernetPacket.Extract<IPPacket>();
                    var tcpPacket = ipPacket?.Extract<TcpPacket>();
                    var udpPacket = ipPacket?.Extract<UdpPacket>();
                    LogPacketInfo(packet, Verbosity.Detailed);","var record = FeatureExtractor.ExtractFeatures(rawPacket);
                    if (csv != null)
                    {","csv.WriteRecord(record);
                        csv.NextRecord();
                        csv.Flush();
                    }
                }
            }
        }
        private void Log(string message, Verbosity requiredVerbosity)
        {
            _logger.Log(message, requiredVerbosity);
        }
        private void LogDeviceStatistics(string statistics)
        {
            _logger.LogDeviceStatistics(statistics);
        }
        public static void LogPacketInfo(PacketDotNet.Packet packet, Verbosity requiredVerbosity)
        {
            _logger.LogPacketInfo(packet, requiredVerbosity);
        }
    }
}",ClassificationPacketCaptureService.cs
"using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using CsvHelper;
using PacketDotNet;
using PcapDotNet.Packets;
using SharpPcap;
using SharpPcap.LibPcap;
using Spectre.Console;
using TinyIDS.Models;
using TinyIDS.Utils;
namespace TinyIDS.Services
{
    public enum CaptureMode
    {
        Csv,
        Cap,
        Flow
    }
    public class PacketCaptureService
    {
        private ICaptureDevice _device;
        private static CaptureFileWriterDevice captureFileWriter;
        private static StreamWriter csvWriter;
        private static CsvWriter csv;
        private static Verbosity _verbosity;
        private CaptureMode _captureMode;
        private static PacketProcessor _packetProcessor;
        private static Logger _logger;
        public PacketCaptureService(Verbosity verbosity)
        {
            _logger = new Logger(verbosity);
            _packetProcessor = new PacketProcessor(_logger, );
        }
        public void ListDevices()
        {
            var devices = CaptureDeviceList.Instance;
            if (devices.Count == 0)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            var table = new Table();
            table.AddColumn();
            table.AddColumn();
            foreach (var device in devices)
            {
                table.AddRow(device.Name, device.Description);
            }
            AnsiConsole.Write(table);
        }
        public void PrintSharpPcapVersion()
        {
            var ver = Pcap.SharpPcapVersion;
            Log($, Verbosity.Basic);
        }
        private LibPcapLiveDeviceList GetDevices()
        {
            return LibPcapLiveDeviceList.Instance;
        }
        private void DisplayAvailableDevices(LibPcapLiveDeviceList devices)
        {
            var table = new Table();
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            for (int i = 0; i < devices.Count; i++)
            {
                var dev = devices[i];
                table.AddRow(i.ToString(), dev.Name, dev.Description);
            }
            AnsiConsole.Write(table);
        }
        private int GetDeviceIndexFromUser()
        {
            return AnsiConsole.Prompt(
                new TextPrompt<int>()
                    .PromptStyle()
                    .Validate(index =>
                        index >= 0 ? ValidationResult.Success() : ValidationResult.Error()));
        }
        private string GetOutputFileNameFromUser(string fileType)
        {
            return AnsiConsole.Ask<string>($);
        }
        public void StartCapture(CaptureMode captureMode)
        {
            _captureMode = captureMode;
            Log(, Verbosity.Basic);
            PrintSharpPcapVersion();
            var devices = GetDevices();
            if (devices.Count < 1)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            DisplayAvailableDevices(devices);
            int deviceIndex = GetDeviceIndexFromUser();","string capFile = null;
            string csvFile = null;
            if (_captureMode == CaptureMode.Cap)","{
                capFile = GetOutputFileNameFromUser();
            }
            if (_captureMode == CaptureMode.Csv)
            {
                csvFile = GetOutputFileNameFromUser();
            }
            CapturePackets(devices[deviceIndex], capFile, csvFile);
        }
        private void CapturePackets(ICaptureDevice device, string capFile, string csvFile)
        {
            device.OnPacketArrival += new PacketArrivalEventHandler(device_OnPacketArrivalCapture);
            device.Open(DeviceModes.Promiscuous | DeviceModes.DataTransferUdp | DeviceModes.NoCaptureLocal, read_timeout: 1000);
            Log($, Verbosity.Basic);
            if (_captureMode == CaptureMode.Cap && capFile != null)
            {
                captureFileWriter = new CaptureFileWriterDevice(capFile);
                captureFileWriter.Open(device);
            }
            if (_captureMode == CaptureMode.Csv && csvFile != null)
            {
                csvWriter = new StreamWriter(csvFile);
                csv = new CsvWriter(csvWriter, CultureInfo.InvariantCulture);
                csv.WriteHeader<PacketRecord>();
                csv.NextRecord();
            }
            device.StartCapture();
            if (_verbosity >= Verbosity.Detailed)
            {
                Console.WriteLine();
                AnsiConsole.Write(
                 new Rule()
                     .RuleStyle()
                     .Centered());
                Console.WriteLine();
            }
            Console.ReadLine();
            device.StopCapture();
            if (_captureMode == CaptureMode.Cap && captureFileWriter != null)
            {
                captureFileWriter.Close();
            }
            if (_captureMode == CaptureMode.Csv && csvWriter != null)
            {
                csvWriter.Close();
            }
            Log(, Verbosity.Basic);
            LogDeviceStatistics(device.Statistics.ToString());
        }
        private static void device_OnPacketArrivalCapture(object sender, PacketCapture e)
        {
            var rawPacket = e.GetPacket();
            _packetProcessor.ProcessPacket(rawPacket);
            if (captureFileWriter != null)
            {
                captureFileWriter.Write(rawPacket);
            }
            if (rawPacket.LinkLayerType == PacketDotNet.LinkLayers.Ethernet)
            {
                var packet = PacketDotNet.Packet.ParsePacket(rawPacket.LinkLayerType, rawPacket.Data);
                var ethernetPacket = packet.Extract<EthernetPacket>();
                if (ethernetPacket != null)
                {
                    var ipPacket = ethernetPacket.Extract<IPPacket>();
                    var tcpPacket = ipPacket?.Extract<TcpPacket>();
                    var udpPacket = ipPacket?.Extract<UdpPacket>();
                    LogPacketInfo(packet, Verbosity.Detailed);
                    var record = FeatureExtractor.ExtractFeatures(rawPacket);
                    if (csv != null)
                    {
                        csv.WriteRecord(record);
                        csv.NextRecord();
                        csv.Flush();
                    }
                }
            }
        }
        private void Log(string message, Verbosity requiredVerbosity)
        {
            _logger.Log(message, requiredVerbosity);
        }
        private void LogDeviceStatistics(string statistics)
        {
            _logger.LogDeviceStatistics(statistics);
        }
        public static void LogPacketInfo(PacketDotNet.Packet packet, Verbosity requiredVerbosity)
        {
            _logger.LogPacketInfo(packet, requiredVerbosity);
        }
    }
}",ClassificationPacketCaptureService.cs
"using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using CsvHelper;
using PacketDotNet;
using PcapDotNet.Packets;
using SharpPcap;
using SharpPcap.LibPcap;
using Spectre.Console;
using TinyIDS.Models;
using TinyIDS.Utils;
namespace TinyIDS.Services
{
    public enum CaptureMode
    {
        Csv,
        Cap,
        Flow
    }
    public class PacketCaptureService
    {
        private ICaptureDevice _device;
        private static CaptureFileWriterDevice captureFileWriter;
        private static StreamWriter csvWriter;
        private static CsvWriter csv;
        private static Verbosity _verbosity;
        private CaptureMode _captureMode;
        private static PacketProcessor _packetProcessor;
        private static Logger _logger;
        public PacketCaptureService(Verbosity verbosity)
        {
            _logger = new Logger(verbosity);
            _packetProcessor = new PacketProcessor(_logger, );
        }
        public void ListDevices()
        {
            var devices = CaptureDeviceList.Instance;
            if (devices.Count == 0)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            var table = new Table();
            table.AddColumn();
            table.AddColumn();
            foreach (var device in devices)
            {
                table.AddRow(device.Name, device.Description);
            }
            AnsiConsole.Write(table);
        }
        public void PrintSharpPcapVersion()
        {
            var ver = Pcap.SharpPcapVersion;
            Log($, Verbosity.Basic);
        }
        private LibPcapLiveDeviceList GetDevices()
        {
            return LibPcapLiveDeviceList.Instance;
        }
        private void DisplayAvailableDevices(LibPcapLiveDeviceList devices)
        {
            var table = new Table();
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            for (int i = 0; i < devices.Count; i++)
            {
                var dev = devices[i];
                table.AddRow(i.ToString(), dev.Name, dev.Description);
            }
            AnsiConsole.Write(table);
        }
        private int GetDeviceIndexFromUser()
        {
            return AnsiConsole.Prompt(
                new TextPrompt<int>()
                    .PromptStyle()
                    .Validate(index =>
                        index >= 0 ? ValidationResult.Success() : ValidationResult.Error()));
        }
        private string GetOutputFileNameFromUser(string fileType)
        {
            return AnsiConsole.Ask<string>($);
        }
        public void StartCapture(CaptureMode captureMode)
        {
            _captureMode = captureMode;
            Log(, Verbosity.Basic);
            PrintSharpPcapVersion();
            var devices = GetDevices();
            if (devices.Count < 1)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            DisplayAvailableDevices(devices);
            int deviceIndex = GetDeviceIndexFromUser();
            string capFile = null;
            string csvFile = null;
            if (_captureMode == CaptureMode.Cap)
            {
                capFile = GetOutputFileNameFromUser();
            }
            if (_captureMode == CaptureMode.Csv)
            {
                csvFile = GetOutputFileNameFromUser();
            }
            CapturePackets(devices[deviceIndex], capFile, csvFile);
        }
        private void CapturePackets(ICaptureDevice device, string capFile, string csvFile)
        {
            device.OnPacketArrival += new PacketArrivalEventHandler(device_OnPacketArrivalCapture);
            device.Open(DeviceModes.Promiscuous | DeviceModes.DataTransferUdp | DeviceModes.NoCaptureLocal, read_timeout: 1000);
            Log($, Verbosity.Basic);
            if (_captureMode == CaptureMode.Cap && capFile != null)
            {
                captureFileWriter = new CaptureFileWriterDevice(capFile);
                captureFileWriter.Open(device);
            }
            if (_captureMode == CaptureMode.Csv && csvFile != null)
            {
                csvWriter = new StreamWriter(csvFile);
                csv = new CsvWriter(csvWriter, CultureInfo.InvariantCulture);
                csv.WriteHeader<PacketRecord>();
                csv.NextRecord();
            }
            device.StartCapture();
            if (_verbosity >= Verbosity.Detailed)
            {
                Console.WriteLine();
                AnsiConsole.Write(
                 new Rule()
                     .RuleStyle()
                     .Centered());
                Console.WriteLine();","}
            Console.ReadLine();
            device.StopCapture();","if (_captureMode == CaptureMode.Cap && captureFileWriter != null)
            {
                captureFileWriter.Close();
            }
            if (_captureMode == CaptureMode.Csv && csvWriter != null)
            {
                csvWriter.Close();
            }
            Log(, Verbosity.Basic);
            LogDeviceStatistics(device.Statistics.ToString());
        }
        private static void device_OnPacketArrivalCapture(object sender, PacketCapture e)
        {
            var rawPacket = e.GetPacket();
            _packetProcessor.ProcessPacket(rawPacket);
            if (captureFileWriter != null)
            {
                captureFileWriter.Write(rawPacket);
            }
            if (rawPacket.LinkLayerType == PacketDotNet.LinkLayers.Ethernet)
            {
                var packet = PacketDotNet.Packet.ParsePacket(rawPacket.LinkLayerType, rawPacket.Data);
                var ethernetPacket = packet.Extract<EthernetPacket>();
                if (ethernetPacket != null)
                {
                    var ipPacket = ethernetPacket.Extract<IPPacket>();
                    var tcpPacket = ipPacket?.Extract<TcpPacket>();
                    var udpPacket = ipPacket?.Extract<UdpPacket>();
                    LogPacketInfo(packet, Verbosity.Detailed);
                    var record = FeatureExtractor.ExtractFeatures(rawPacket);
                    if (csv != null)
                    {
                        csv.WriteRecord(record);
                        csv.NextRecord();
                        csv.Flush();
                    }
                }
            }
        }
        private void Log(string message, Verbosity requiredVerbosity)
        {
            _logger.Log(message, requiredVerbosity);
        }
        private void LogDeviceStatistics(string statistics)
        {
            _logger.LogDeviceStatistics(statistics);
        }
        public static void LogPacketInfo(PacketDotNet.Packet packet, Verbosity requiredVerbosity)
        {
            _logger.LogPacketInfo(packet, requiredVerbosity);
        }
    }
}",ClassificationPacketCaptureService.cs
"using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using CsvHelper;
using PacketDotNet;
using PcapDotNet.Packets;
using SharpPcap;
using SharpPcap.LibPcap;
using Spectre.Console;
using TinyIDS.Models;
using TinyIDS.Utils;
namespace TinyIDS.Services
{
    public enum CaptureMode
    {
        Csv,
        Cap,
        Flow
    }
    public class PacketCaptureService
    {","private ICaptureDevice _device;
        private static CaptureFileWriterDevice captureFileWriter;
        private static StreamWriter csvWriter;","private static CsvWriter csv;
        private static Verbosity _verbosity;
        private CaptureMode _captureMode;
        private static PacketProcessor _packetProcessor;
        private static Logger _logger;
        public PacketCaptureService(Verbosity verbosity)
        {
            _logger = new Logger(verbosity);
            _packetProcessor = new PacketProcessor(_logger, );
        }
        public void ListDevices()
        {
            var devices = CaptureDeviceList.Instance;
            if (devices.Count == 0)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            var table = new Table();
            table.AddColumn();
            table.AddColumn();
            foreach (var device in devices)
            {
                table.AddRow(device.Name, device.Description);
            }
            AnsiConsole.Write(table);
        }
        public void PrintSharpPcapVersion()
        {
            var ver = Pcap.SharpPcapVersion;
            Log($, Verbosity.Basic);
        }
        private LibPcapLiveDeviceList GetDevices()
        {
            return LibPcapLiveDeviceList.Instance;
        }
        private void DisplayAvailableDevices(LibPcapLiveDeviceList devices)
        {
            var table = new Table();
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            for (int i = 0; i < devices.Count; i++)
            {
                var dev = devices[i];
                table.AddRow(i.ToString(), dev.Name, dev.Description);
            }
            AnsiConsole.Write(table);
        }
        private int GetDeviceIndexFromUser()
        {
            return AnsiConsole.Prompt(
                new TextPrompt<int>()
                    .PromptStyle()
                    .Validate(index =>
                        index >= 0 ? ValidationResult.Success() : ValidationResult.Error()));
        }
        private string GetOutputFileNameFromUser(string fileType)
        {
            return AnsiConsole.Ask<string>($);
        }
        public void StartCapture(CaptureMode captureMode)
        {
            _captureMode = captureMode;
            Log(, Verbosity.Basic);
            PrintSharpPcapVersion();
            var devices = GetDevices();
            if (devices.Count < 1)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            DisplayAvailableDevices(devices);
            int deviceIndex = GetDeviceIndexFromUser();
            string capFile = null;
            string csvFile = null;
            if (_captureMode == CaptureMode.Cap)
            {
                capFile = GetOutputFileNameFromUser();
            }
            if (_captureMode == CaptureMode.Csv)
            {
                csvFile = GetOutputFileNameFromUser();
            }
            CapturePackets(devices[deviceIndex], capFile, csvFile);
        }
        private void CapturePackets(ICaptureDevice device, string capFile, string csvFile)
        {
            device.OnPacketArrival += new PacketArrivalEventHandler(device_OnPacketArrivalCapture);
            device.Open(DeviceModes.Promiscuous | DeviceModes.DataTransferUdp | DeviceModes.NoCaptureLocal, read_timeout: 1000);
            Log($, Verbosity.Basic);
            if (_captureMode == CaptureMode.Cap && capFile != null)
            {
                captureFileWriter = new CaptureFileWriterDevice(capFile);
                captureFileWriter.Open(device);
            }
            if (_captureMode == CaptureMode.Csv && csvFile != null)
            {
                csvWriter = new StreamWriter(csvFile);
                csv = new CsvWriter(csvWriter, CultureInfo.InvariantCulture);
                csv.WriteHeader<PacketRecord>();
                csv.NextRecord();
            }
            device.StartCapture();
            if (_verbosity >= Verbosity.Detailed)
            {
                Console.WriteLine();
                AnsiConsole.Write(
                 new Rule()
                     .RuleStyle()
                     .Centered());
                Console.WriteLine();
            }
            Console.ReadLine();
            device.StopCapture();
            if (_captureMode == CaptureMode.Cap && captureFileWriter != null)
            {
                captureFileWriter.Close();
            }
            if (_captureMode == CaptureMode.Csv && csvWriter != null)
            {
                csvWriter.Close();
            }
            Log(, Verbosity.Basic);
            LogDeviceStatistics(device.Statistics.ToString());
        }
        private static void device_OnPacketArrivalCapture(object sender, PacketCapture e)
        {
            var rawPacket = e.GetPacket();
            _packetProcessor.ProcessPacket(rawPacket);
            if (captureFileWriter != null)
            {
                captureFileWriter.Write(rawPacket);
            }
            if (rawPacket.LinkLayerType == PacketDotNet.LinkLayers.Ethernet)
            {
                var packet = PacketDotNet.Packet.ParsePacket(rawPacket.LinkLayerType, rawPacket.Data);
                var ethernetPacket = packet.Extract<EthernetPacket>();
                if (ethernetPacket != null)
                {
                    var ipPacket = ethernetPacket.Extract<IPPacket>();
                    var tcpPacket = ipPacket?.Extract<TcpPacket>();
                    var udpPacket = ipPacket?.Extract<UdpPacket>();
                    LogPacketInfo(packet, Verbosity.Detailed);
                    var record = FeatureExtractor.ExtractFeatures(rawPacket);
                    if (csv != null)
                    {
                        csv.WriteRecord(record);
                        csv.NextRecord();
                        csv.Flush();
                    }
                }
            }
        }
        private void Log(string message, Verbosity requiredVerbosity)
        {
            _logger.Log(message, requiredVerbosity);
        }
        private void LogDeviceStatistics(string statistics)
        {
            _logger.LogDeviceStatistics(statistics);
        }
        public static void LogPacketInfo(PacketDotNet.Packet packet, Verbosity requiredVerbosity)
        {
            _logger.LogPacketInfo(packet, requiredVerbosity);
        }
    }
}",ClassificationPacketCaptureService.cs
"using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using CsvHelper;
using PacketDotNet;
using PcapDotNet.Packets;
using SharpPcap;
using SharpPcap.LibPcap;
using Spectre.Console;
using TinyIDS.Models;
using TinyIDS.Utils;
namespace TinyIDS.Services
{
    public enum CaptureMode
    {
        Csv,
        Cap,
        Flow
    }
    public class PacketCaptureService
    {
        private ICaptureDevice _device;
        private static CaptureFileWriterDevice captureFileWriter;
        private static StreamWriter csvWriter;
        private static CsvWriter csv;
        private static Verbosity _verbosity;
        private CaptureMode _captureMode;
        private static PacketProcessor _packetProcessor;
        private static Logger _logger;
        public PacketCaptureService(Verbosity verbosity)
        {
            _logger = new Logger(verbosity);
            _packetProcessor = new PacketProcessor(_logger, );
        }
        public void ListDevices()
        {
            var devices = CaptureDeviceList.Instance;
            if (devices.Count == 0)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            var table = new Table();
            table.AddColumn();
            table.AddColumn();
            foreach (var device in devices)
            {
                table.AddRow(device.Name, device.Description);
            }
            AnsiConsole.Write(table);
        }
        public void PrintSharpPcapVersion()
        {
            var ver = Pcap.SharpPcapVersion;
            Log($, Verbosity.Basic);
        }
        private LibPcapLiveDeviceList GetDevices()
        {
            return LibPcapLiveDeviceList.Instance;
        }
        private void DisplayAvailableDevices(LibPcapLiveDeviceList devices)
        {
            var table = new Table();
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            for (int i = 0; i < devices.Count; i++)
            {
                var dev = devices[i];
                table.AddRow(i.ToString(), dev.Name, dev.Description);
            }
            AnsiConsole.Write(table);
        }
        private int GetDeviceIndexFromUser()
        {
            return AnsiConsole.Prompt(
                new TextPrompt<int>()
                    .PromptStyle()
                    .Validate(index =>
                        index >= 0 ? ValidationResult.Success() : ValidationResult.Error()));
        }
        private string GetOutputFileNameFromUser(string fileType)
        {
            return AnsiConsole.Ask<string>($);
        }
        public void StartCapture(CaptureMode captureMode)
        {
            _captureMode = captureMode;
            Log(, Verbosity.Basic);
            PrintSharpPcapVersion();
            var devices = GetDevices();
            if (devices.Count < 1)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            DisplayAvailableDevices(devices);
            int deviceIndex = GetDeviceIndexFromUser();
            string capFile = null;
            string csvFile = null;
            if (_captureMode == CaptureMode.Cap)
            {
                capFile = GetOutputFileNameFromUser();
            }
            if (_captureMode == CaptureMode.Csv)
            {
                csvFile = GetOutputFileNameFromUser();
            }
            CapturePackets(devices[deviceIndex], capFile, csvFile);
        }
        private void CapturePackets(ICaptureDevice device, string capFile, string csvFile)
        {
            device.OnPacketArrival += new PacketArrivalEventHandler(device_OnPacketArrivalCapture);
            device.Open(DeviceModes.Promiscuous | DeviceModes.DataTransferUdp | DeviceModes.NoCaptureLocal, read_timeout: 1000);
            Log($, Verbosity.Basic);
            if (_captureMode == CaptureMode.Cap && capFile != null)
            {
                captureFileWriter = new CaptureFileWriterDevice(capFile);
                captureFileWriter.Open(device);","}
            if (_captureMode == CaptureMode.Csv && csvFile != null)
            {","csvWriter = new StreamWriter(csvFile);
                csv = new CsvWriter(csvWriter, CultureInfo.InvariantCulture);
                csv.WriteHeader<PacketRecord>();
                csv.NextRecord();
            }
            device.StartCapture();
            if (_verbosity >= Verbosity.Detailed)
            {
                Console.WriteLine();
                AnsiConsole.Write(
                 new Rule()
                     .RuleStyle()
                     .Centered());
                Console.WriteLine();
            }
            Console.ReadLine();
            device.StopCapture();
            if (_captureMode == CaptureMode.Cap && captureFileWriter != null)
            {
                captureFileWriter.Close();
            }
            if (_captureMode == CaptureMode.Csv && csvWriter != null)
            {
                csvWriter.Close();
            }
            Log(, Verbosity.Basic);
            LogDeviceStatistics(device.Statistics.ToString());
        }
        private static void device_OnPacketArrivalCapture(object sender, PacketCapture e)
        {
            var rawPacket = e.GetPacket();
            _packetProcessor.ProcessPacket(rawPacket);
            if (captureFileWriter != null)
            {
                captureFileWriter.Write(rawPacket);
            }
            if (rawPacket.LinkLayerType == PacketDotNet.LinkLayers.Ethernet)
            {
                var packet = PacketDotNet.Packet.ParsePacket(rawPacket.LinkLayerType, rawPacket.Data);
                var ethernetPacket = packet.Extract<EthernetPacket>();
                if (ethernetPacket != null)
                {
                    var ipPacket = ethernetPacket.Extract<IPPacket>();
                    var tcpPacket = ipPacket?.Extract<TcpPacket>();
                    var udpPacket = ipPacket?.Extract<UdpPacket>();
                    LogPacketInfo(packet, Verbosity.Detailed);
                    var record = FeatureExtractor.ExtractFeatures(rawPacket);
                    if (csv != null)
                    {
                        csv.WriteRecord(record);
                        csv.NextRecord();
                        csv.Flush();
                    }
                }
            }
        }
        private void Log(string message, Verbosity requiredVerbosity)
        {
            _logger.Log(message, requiredVerbosity);
        }
        private void LogDeviceStatistics(string statistics)
        {
            _logger.LogDeviceStatistics(statistics);
        }
        public static void LogPacketInfo(PacketDotNet.Packet packet, Verbosity requiredVerbosity)
        {
            _logger.LogPacketInfo(packet, requiredVerbosity);
        }
    }
}",ClassificationPacketCaptureService.cs
"using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using CsvHelper;
using PacketDotNet;
using PcapDotNet.Packets;
using SharpPcap;
using SharpPcap.LibPcap;
using Spectre.Console;
using TinyIDS.Models;
using TinyIDS.Utils;
namespace TinyIDS.Services
{
    public enum CaptureMode
    {
        Csv,
        Cap,
        Flow
    }
    public class PacketCaptureService
    {
        private ICaptureDevice _device;
        private static CaptureFileWriterDevice captureFileWriter;
        private static StreamWriter csvWriter;
        private static CsvWriter csv;
        private static Verbosity _verbosity;
        private CaptureMode _captureMode;
        private static PacketProcessor _packetProcessor;
        private static Logger _logger;
        public PacketCaptureService(Verbosity verbosity)
        {
            _logger = new Logger(verbosity);
            _packetProcessor = new PacketProcessor(_logger, );
        }
        public void ListDevices()
        {
            var devices = CaptureDeviceList.Instance;
            if (devices.Count == 0)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            var table = new Table();
            table.AddColumn();
            table.AddColumn();
            foreach (var device in devices)
            {
                table.AddRow(device.Name, device.Description);
            }
            AnsiConsole.Write(table);
        }
        public void PrintSharpPcapVersion()
        {
            var ver = Pcap.SharpPcapVersion;
            Log($, Verbosity.Basic);
        }
        private LibPcapLiveDeviceList GetDevices()
        {
            return LibPcapLiveDeviceList.Instance;
        }
        private void DisplayAvailableDevices(LibPcapLiveDeviceList devices)
        {
            var table = new Table();
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            for (int i = 0; i < devices.Count; i++)
            {
                var dev = devices[i];
                table.AddRow(i.ToString(), dev.Name, dev.Description);
            }
            AnsiConsole.Write(table);
        }
        private int GetDeviceIndexFromUser()
        {
            return AnsiConsole.Prompt(
                new TextPrompt<int>()
                    .PromptStyle()
                    .Validate(index =>
                        index >= 0 ? ValidationResult.Success() : ValidationResult.Error()));
        }
        private string GetOutputFileNameFromUser(string fileType)
        {
            return AnsiConsole.Ask<string>($);
        }
        public void StartCapture(CaptureMode captureMode)
        {
            _captureMode = captureMode;
            Log(, Verbosity.Basic);
            PrintSharpPcapVersion();
            var devices = GetDevices();
            if (devices.Count < 1)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            DisplayAvailableDevices(devices);
            int deviceIndex = GetDeviceIndexFromUser();
            string capFile = null;
            string csvFile = null;","if (_captureMode == CaptureMode.Cap)
            {
                capFile = GetOutputFileNameFromUser();","}
            if (_captureMode == CaptureMode.Csv)
            {
                csvFile = GetOutputFileNameFromUser();
            }
            CapturePackets(devices[deviceIndex], capFile, csvFile);
        }
        private void CapturePackets(ICaptureDevice device, string capFile, string csvFile)
        {
            device.OnPacketArrival += new PacketArrivalEventHandler(device_OnPacketArrivalCapture);
            device.Open(DeviceModes.Promiscuous | DeviceModes.DataTransferUdp | DeviceModes.NoCaptureLocal, read_timeout: 1000);
            Log($, Verbosity.Basic);
            if (_captureMode == CaptureMode.Cap && capFile != null)
            {
                captureFileWriter = new CaptureFileWriterDevice(capFile);
                captureFileWriter.Open(device);
            }
            if (_captureMode == CaptureMode.Csv && csvFile != null)
            {
                csvWriter = new StreamWriter(csvFile);
                csv = new CsvWriter(csvWriter, CultureInfo.InvariantCulture);
                csv.WriteHeader<PacketRecord>();
                csv.NextRecord();
            }
            device.StartCapture();
            if (_verbosity >= Verbosity.Detailed)
            {
                Console.WriteLine();
                AnsiConsole.Write(
                 new Rule()
                     .RuleStyle()
                     .Centered());
                Console.WriteLine();
            }
            Console.ReadLine();
            device.StopCapture();
            if (_captureMode == CaptureMode.Cap && captureFileWriter != null)
            {
                captureFileWriter.Close();
            }
            if (_captureMode == CaptureMode.Csv && csvWriter != null)
            {
                csvWriter.Close();
            }
            Log(, Verbosity.Basic);
            LogDeviceStatistics(device.Statistics.ToString());
        }
        private static void device_OnPacketArrivalCapture(object sender, PacketCapture e)
        {
            var rawPacket = e.GetPacket();
            _packetProcessor.ProcessPacket(rawPacket);
            if (captureFileWriter != null)
            {
                captureFileWriter.Write(rawPacket);
            }
            if (rawPacket.LinkLayerType == PacketDotNet.LinkLayers.Ethernet)
            {
                var packet = PacketDotNet.Packet.ParsePacket(rawPacket.LinkLayerType, rawPacket.Data);
                var ethernetPacket = packet.Extract<EthernetPacket>();
                if (ethernetPacket != null)
                {
                    var ipPacket = ethernetPacket.Extract<IPPacket>();
                    var tcpPacket = ipPacket?.Extract<TcpPacket>();
                    var udpPacket = ipPacket?.Extract<UdpPacket>();
                    LogPacketInfo(packet, Verbosity.Detailed);
                    var record = FeatureExtractor.ExtractFeatures(rawPacket);
                    if (csv != null)
                    {
                        csv.WriteRecord(record);
                        csv.NextRecord();
                        csv.Flush();
                    }
                }
            }
        }
        private void Log(string message, Verbosity requiredVerbosity)
        {
            _logger.Log(message, requiredVerbosity);
        }
        private void LogDeviceStatistics(string statistics)
        {
            _logger.LogDeviceStatistics(statistics);
        }
        public static void LogPacketInfo(PacketDotNet.Packet packet, Verbosity requiredVerbosity)
        {
            _logger.LogPacketInfo(packet, requiredVerbosity);
        }
    }
}",ClassificationPacketCaptureService.cs
"using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using CsvHelper;
using PacketDotNet;
using PcapDotNet.Packets;
using SharpPcap;
using SharpPcap.LibPcap;
using Spectre.Console;
using TinyIDS.Models;
using TinyIDS.Utils;
namespace TinyIDS.Services
{
    public enum CaptureMode
    {
        Csv,
        Cap,
        Flow
    }
    public class PacketCaptureService
    {
        private ICaptureDevice _device;
        private static CaptureFileWriterDevice captureFileWriter;
        private static StreamWriter csvWriter;
        private static CsvWriter csv;
        private static Verbosity _verbosity;
        private CaptureMode _captureMode;
        private static PacketProcessor _packetProcessor;
        private static Logger _logger;
        public PacketCaptureService(Verbosity verbosity)
        {
            _logger = new Logger(verbosity);
            _packetProcessor = new PacketProcessor(_logger, );
        }
        public void ListDevices()
        {
            var devices = CaptureDeviceList.Instance;
            if (devices.Count == 0)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            var table = new Table();
            table.AddColumn();
            table.AddColumn();
            foreach (var device in devices)
            {
                table.AddRow(device.Name, device.Description);
            }
            AnsiConsole.Write(table);
        }
        public void PrintSharpPcapVersion()
        {
            var ver = Pcap.SharpPcapVersion;
            Log($, Verbosity.Basic);
        }
        private LibPcapLiveDeviceList GetDevices()
        {
            return LibPcapLiveDeviceList.Instance;
        }
        private void DisplayAvailableDevices(LibPcapLiveDeviceList devices)
        {
            var table = new Table();
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            for (int i = 0; i < devices.Count; i++)
            {
                var dev = devices[i];
                table.AddRow(i.ToString(), dev.Name, dev.Description);
            }
            AnsiConsole.Write(table);
        }
        private int GetDeviceIndexFromUser()
        {
            return AnsiConsole.Prompt(
                new TextPrompt<int>()
                    .PromptStyle()
                    .Validate(index =>
                        index >= 0 ? ValidationResult.Success() : ValidationResult.Error()));
        }
        private string GetOutputFileNameFromUser(string fileType)
        {
            return AnsiConsole.Ask<string>($);
        }
        public void StartCapture(CaptureMode captureMode)
        {
            _captureMode = captureMode;
            Log(, Verbosity.Basic);
            PrintSharpPcapVersion();
            var devices = GetDevices();
            if (devices.Count < 1)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            DisplayAvailableDevices(devices);
            int deviceIndex = GetDeviceIndexFromUser();
            string capFile = null;
            string csvFile = null;
            if (_captureMode == CaptureMode.Cap)
            {
                capFile = GetOutputFileNameFromUser();
            }
            if (_captureMode == CaptureMode.Csv)
            {
                csvFile = GetOutputFileNameFromUser();
            }
            CapturePackets(devices[deviceIndex], capFile, csvFile);
        }
        private void CapturePackets(ICaptureDevice device, string capFile, string csvFile)
        {
            device.OnPacketArrival += new PacketArrivalEventHandler(device_OnPacketArrivalCapture);
            device.Open(DeviceModes.Promiscuous | DeviceModes.DataTransferUdp | DeviceModes.NoCaptureLocal, read_timeout: 1000);
            Log($, Verbosity.Basic);
            if (_captureMode == CaptureMode.Cap && capFile != null)
            {
                captureFileWriter = new CaptureFileWriterDevice(capFile);
                captureFileWriter.Open(device);
            }
            if (_captureMode == CaptureMode.Csv && csvFile != null)
            {
                csvWriter = new StreamWriter(csvFile);
                csv = new CsvWriter(csvWriter, CultureInfo.InvariantCulture);
                csv.WriteHeader<PacketRecord>();
                csv.NextRecord();
            }
            device.StartCapture();
            if (_verbosity >= Verbosity.Detailed)
            {
                Console.WriteLine();
                AnsiConsole.Write(
                 new Rule()
                     .RuleStyle()
                     .Centered());
                Console.WriteLine();
            }
            Console.ReadLine();
            device.StopCapture();
            if (_captureMode == CaptureMode.Cap && captureFileWriter != null)
            {
                captureFileWriter.Close();
            }
            if (_captureMode == CaptureMode.Csv && csvWriter != null)
            {
                csvWriter.Close();
            }
            Log(, Verbosity.Basic);
            LogDeviceStatistics(device.Statistics.ToString());
        }
        private static void device_OnPacketArrivalCapture(object sender, PacketCapture e)
        {
            var rawPacket = e.GetPacket();
            _packetProcessor.ProcessPacket(rawPacket);","if (captureFileWriter != null)
            {
                captureFileWriter.Write(rawPacket);","}
            if (rawPacket.LinkLayerType == PacketDotNet.LinkLayers.Ethernet)
            {
                var packet = PacketDotNet.Packet.ParsePacket(rawPacket.LinkLayerType, rawPacket.Data);
                var ethernetPacket = packet.Extract<EthernetPacket>();
                if (ethernetPacket != null)
                {
                    var ipPacket = ethernetPacket.Extract<IPPacket>();
                    var tcpPacket = ipPacket?.Extract<TcpPacket>();
                    var udpPacket = ipPacket?.Extract<UdpPacket>();
                    LogPacketInfo(packet, Verbosity.Detailed);
                    var record = FeatureExtractor.ExtractFeatures(rawPacket);
                    if (csv != null)
                    {
                        csv.WriteRecord(record);
                        csv.NextRecord();
                        csv.Flush();
                    }
                }
            }
        }
        private void Log(string message, Verbosity requiredVerbosity)
        {
            _logger.Log(message, requiredVerbosity);
        }
        private void LogDeviceStatistics(string statistics)
        {
            _logger.LogDeviceStatistics(statistics);
        }
        public static void LogPacketInfo(PacketDotNet.Packet packet, Verbosity requiredVerbosity)
        {
            _logger.LogPacketInfo(packet, requiredVerbosity);
        }
    }
}",ClassificationPacketCaptureService.cs
"using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using CsvHelper;
using PacketDotNet;
using PcapDotNet.Packets;
using SharpPcap;
using SharpPcap.LibPcap;
using Spectre.Console;
using TinyIDS.Models;
using TinyIDS.Utils;
namespace TinyIDS.Services
{
    public enum CaptureMode
    {
        Csv,
        Cap,
        Flow
    }
    public class PacketCaptureService
    {
        private ICaptureDevice _device;
        private static CaptureFileWriterDevice captureFileWriter;
        private static StreamWriter csvWriter;
        private static CsvWriter csv;
        private static Verbosity _verbosity;
        private CaptureMode _captureMode;","private static PacketProcessor _packetProcessor;
        private static Logger _logger;
        public PacketCaptureService(Verbosity verbosity)","{
            _logger = new Logger(verbosity);
            _packetProcessor = new PacketProcessor(_logger, );
        }
        public void ListDevices()
        {
            var devices = CaptureDeviceList.Instance;
            if (devices.Count == 0)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            var table = new Table();
            table.AddColumn();
            table.AddColumn();
            foreach (var device in devices)
            {
                table.AddRow(device.Name, device.Description);
            }
            AnsiConsole.Write(table);
        }
        public void PrintSharpPcapVersion()
        {
            var ver = Pcap.SharpPcapVersion;
            Log($, Verbosity.Basic);
        }
        private LibPcapLiveDeviceList GetDevices()
        {
            return LibPcapLiveDeviceList.Instance;
        }
        private void DisplayAvailableDevices(LibPcapLiveDeviceList devices)
        {
            var table = new Table();
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            for (int i = 0; i < devices.Count; i++)
            {
                var dev = devices[i];
                table.AddRow(i.ToString(), dev.Name, dev.Description);
            }
            AnsiConsole.Write(table);
        }
        private int GetDeviceIndexFromUser()
        {
            return AnsiConsole.Prompt(
                new TextPrompt<int>()
                    .PromptStyle()
                    .Validate(index =>
                        index >= 0 ? ValidationResult.Success() : ValidationResult.Error()));
        }
        private string GetOutputFileNameFromUser(string fileType)
        {
            return AnsiConsole.Ask<string>($);
        }
        public void StartCapture(CaptureMode captureMode)
        {
            _captureMode = captureMode;
            Log(, Verbosity.Basic);
            PrintSharpPcapVersion();
            var devices = GetDevices();
            if (devices.Count < 1)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            DisplayAvailableDevices(devices);
            int deviceIndex = GetDeviceIndexFromUser();
            string capFile = null;
            string csvFile = null;
            if (_captureMode == CaptureMode.Cap)
            {
                capFile = GetOutputFileNameFromUser();
            }
            if (_captureMode == CaptureMode.Csv)
            {
                csvFile = GetOutputFileNameFromUser();
            }
            CapturePackets(devices[deviceIndex], capFile, csvFile);
        }
        private void CapturePackets(ICaptureDevice device, string capFile, string csvFile)
        {
            device.OnPacketArrival += new PacketArrivalEventHandler(device_OnPacketArrivalCapture);
            device.Open(DeviceModes.Promiscuous | DeviceModes.DataTransferUdp | DeviceModes.NoCaptureLocal, read_timeout: 1000);
            Log($, Verbosity.Basic);
            if (_captureMode == CaptureMode.Cap && capFile != null)
            {
                captureFileWriter = new CaptureFileWriterDevice(capFile);
                captureFileWriter.Open(device);
            }
            if (_captureMode == CaptureMode.Csv && csvFile != null)
            {
                csvWriter = new StreamWriter(csvFile);
                csv = new CsvWriter(csvWriter, CultureInfo.InvariantCulture);
                csv.WriteHeader<PacketRecord>();
                csv.NextRecord();
            }
            device.StartCapture();
            if (_verbosity >= Verbosity.Detailed)
            {
                Console.WriteLine();
                AnsiConsole.Write(
                 new Rule()
                     .RuleStyle()
                     .Centered());
                Console.WriteLine();
            }
            Console.ReadLine();
            device.StopCapture();
            if (_captureMode == CaptureMode.Cap && captureFileWriter != null)
            {
                captureFileWriter.Close();
            }
            if (_captureMode == CaptureMode.Csv && csvWriter != null)
            {
                csvWriter.Close();
            }
            Log(, Verbosity.Basic);
            LogDeviceStatistics(device.Statistics.ToString());
        }
        private static void device_OnPacketArrivalCapture(object sender, PacketCapture e)
        {
            var rawPacket = e.GetPacket();
            _packetProcessor.ProcessPacket(rawPacket);
            if (captureFileWriter != null)
            {
                captureFileWriter.Write(rawPacket);
            }
            if (rawPacket.LinkLayerType == PacketDotNet.LinkLayers.Ethernet)
            {
                var packet = PacketDotNet.Packet.ParsePacket(rawPacket.LinkLayerType, rawPacket.Data);
                var ethernetPacket = packet.Extract<EthernetPacket>();
                if (ethernetPacket != null)
                {
                    var ipPacket = ethernetPacket.Extract<IPPacket>();
                    var tcpPacket = ipPacket?.Extract<TcpPacket>();
                    var udpPacket = ipPacket?.Extract<UdpPacket>();
                    LogPacketInfo(packet, Verbosity.Detailed);
                    var record = FeatureExtractor.ExtractFeatures(rawPacket);
                    if (csv != null)
                    {
                        csv.WriteRecord(record);
                        csv.NextRecord();
                        csv.Flush();
                    }
                }
            }
        }
        private void Log(string message, Verbosity requiredVerbosity)
        {
            _logger.Log(message, requiredVerbosity);
        }
        private void LogDeviceStatistics(string statistics)
        {
            _logger.LogDeviceStatistics(statistics);
        }
        public static void LogPacketInfo(PacketDotNet.Packet packet, Verbosity requiredVerbosity)
        {
            _logger.LogPacketInfo(packet, requiredVerbosity);
        }
    }
}",ClassificationPacketCaptureService.cs
"using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using CsvHelper;
using PacketDotNet;
using PcapDotNet.Packets;
using SharpPcap;
using SharpPcap.LibPcap;
using Spectre.Console;
using TinyIDS.Models;
using TinyIDS.Utils;
namespace TinyIDS.Services
{
    public enum CaptureMode
    {
        Csv,
        Cap,
        Flow
    }
    public class PacketCaptureService
    {
        private ICaptureDevice _device;
        private static CaptureFileWriterDevice captureFileWriter;
        private static StreamWriter csvWriter;
        private static CsvWriter csv;
        private static Verbosity _verbosity;
        private CaptureMode _captureMode;
        private static PacketProcessor _packetProcessor;
        private static Logger _logger;
        public PacketCaptureService(Verbosity verbosity)
        {
            _logger = new Logger(verbosity);
            _packetProcessor = new PacketProcessor(_logger, );
        }
        public void ListDevices()
        {
            var devices = CaptureDeviceList.Instance;
            if (devices.Count == 0)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            var table = new Table();
            table.AddColumn();
            table.AddColumn();
            foreach (var device in devices)
            {
                table.AddRow(device.Name, device.Description);
            }
            AnsiConsole.Write(table);
        }
        public void PrintSharpPcapVersion()
        {
            var ver = Pcap.SharpPcapVersion;
            Log($, Verbosity.Basic);
        }
        private LibPcapLiveDeviceList GetDevices()
        {
            return LibPcapLiveDeviceList.Instance;
        }
        private void DisplayAvailableDevices(LibPcapLiveDeviceList devices)
        {
            var table = new Table();
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            for (int i = 0; i < devices.Count; i++)
            {
                var dev = devices[i];
                table.AddRow(i.ToString(), dev.Name, dev.Description);
            }
            AnsiConsole.Write(table);
        }
        private int GetDeviceIndexFromUser()
        {
            return AnsiConsole.Prompt(
                new TextPrompt<int>()
                    .PromptStyle()
                    .Validate(index =>
                        index >= 0 ? ValidationResult.Success() : ValidationResult.Error()));
        }
        private string GetOutputFileNameFromUser(string fileType)
        {
            return AnsiConsole.Ask<string>($);
        }
        public void StartCapture(CaptureMode captureMode)
        {
            _captureMode = captureMode;
            Log(, Verbosity.Basic);
            PrintSharpPcapVersion();
            var devices = GetDevices();
            if (devices.Count < 1)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            DisplayAvailableDevices(devices);
            int deviceIndex = GetDeviceIndexFromUser();
            string capFile = null;
            string csvFile = null;
            if (_captureMode == CaptureMode.Cap)
            {
                capFile = GetOutputFileNameFromUser();
            }
            if (_captureMode == CaptureMode.Csv)
            {
                csvFile = GetOutputFileNameFromUser();
            }
            CapturePackets(devices[deviceIndex], capFile, csvFile);
        }
        private void CapturePackets(ICaptureDevice device, string capFile, string csvFile)
        {
            device.OnPacketArrival += new PacketArrivalEventHandler(device_OnPacketArrivalCapture);
            device.Open(DeviceModes.Promiscuous | DeviceModes.DataTransferUdp | DeviceModes.NoCaptureLocal, read_timeout: 1000);
            Log($, Verbosity.Basic);
            if (_captureMode == CaptureMode.Cap && capFile != null)
            {
                captureFileWriter = new CaptureFileWriterDevice(capFile);
                captureFileWriter.Open(device);
            }
            if (_captureMode == CaptureMode.Csv && csvFile != null)
            {
                csvWriter = new StreamWriter(csvFile);
                csv = new CsvWriter(csvWriter, CultureInfo.InvariantCulture);
                csv.WriteHeader<PacketRecord>();
                csv.NextRecord();
            }
            device.StartCapture();
            if (_verbosity >= Verbosity.Detailed)
            {
                Console.WriteLine();
                AnsiConsole.Write(
                 new Rule()
                     .RuleStyle()
                     .Centered());
                Console.WriteLine();
            }
            Console.ReadLine();
            device.StopCapture();
            if (_captureMode == CaptureMode.Cap && captureFileWriter != null)
            {
                captureFileWriter.Close();
            }
            if (_captureMode == CaptureMode.Csv && csvWriter != null)
            {","csvWriter.Close();
            }
            Log(, Verbosity.Basic);","LogDeviceStatistics(device.Statistics.ToString());
        }
        private static void device_OnPacketArrivalCapture(object sender, PacketCapture e)
        {
            var rawPacket = e.GetPacket();
            _packetProcessor.ProcessPacket(rawPacket);
            if (captureFileWriter != null)
            {
                captureFileWriter.Write(rawPacket);
            }
            if (rawPacket.LinkLayerType == PacketDotNet.LinkLayers.Ethernet)
            {
                var packet = PacketDotNet.Packet.ParsePacket(rawPacket.LinkLayerType, rawPacket.Data);
                var ethernetPacket = packet.Extract<EthernetPacket>();
                if (ethernetPacket != null)
                {
                    var ipPacket = ethernetPacket.Extract<IPPacket>();
                    var tcpPacket = ipPacket?.Extract<TcpPacket>();
                    var udpPacket = ipPacket?.Extract<UdpPacket>();
                    LogPacketInfo(packet, Verbosity.Detailed);
                    var record = FeatureExtractor.ExtractFeatures(rawPacket);
                    if (csv != null)
                    {
                        csv.WriteRecord(record);
                        csv.NextRecord();
                        csv.Flush();
                    }
                }
            }
        }
        private void Log(string message, Verbosity requiredVerbosity)
        {
            _logger.Log(message, requiredVerbosity);
        }
        private void LogDeviceStatistics(string statistics)
        {
            _logger.LogDeviceStatistics(statistics);
        }
        public static void LogPacketInfo(PacketDotNet.Packet packet, Verbosity requiredVerbosity)
        {
            _logger.LogPacketInfo(packet, requiredVerbosity);
        }
    }
}",ClassificationPacketCaptureService.cs
"using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using CsvHelper;
using PacketDotNet;
using PcapDotNet.Packets;
using SharpPcap;
using SharpPcap.LibPcap;
using Spectre.Console;
using TinyIDS.Models;
using TinyIDS.Utils;
namespace TinyIDS.Services
{
    public enum CaptureMode
    {
        Csv,
        Cap,
        Flow
    }
    public class PacketCaptureService
    {
        private ICaptureDevice _device;
        private static CaptureFileWriterDevice captureFileWriter;
        private static StreamWriter csvWriter;
        private static CsvWriter csv;
        private static Verbosity _verbosity;
        private CaptureMode _captureMode;
        private static PacketProcessor _packetProcessor;
        private static Logger _logger;
        public PacketCaptureService(Verbosity verbosity)
        {
            _logger = new Logger(verbosity);
            _packetProcessor = new PacketProcessor(_logger, );
        }
        public void ListDevices()
        {
            var devices = CaptureDeviceList.Instance;
            if (devices.Count == 0)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            var table = new Table();
            table.AddColumn();
            table.AddColumn();
            foreach (var device in devices)
            {
                table.AddRow(device.Name, device.Description);
            }
            AnsiConsole.Write(table);
        }
        public void PrintSharpPcapVersion()
        {
            var ver = Pcap.SharpPcapVersion;
            Log($, Verbosity.Basic);
        }
        private LibPcapLiveDeviceList GetDevices()
        {
            return LibPcapLiveDeviceList.Instance;
        }
        private void DisplayAvailableDevices(LibPcapLiveDeviceList devices)
        {
            var table = new Table();
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            for (int i = 0; i < devices.Count; i++)
            {
                var dev = devices[i];
                table.AddRow(i.ToString(), dev.Name, dev.Description);
            }
            AnsiConsole.Write(table);
        }
        private int GetDeviceIndexFromUser()
        {
            return AnsiConsole.Prompt(
                new TextPrompt<int>()
                    .PromptStyle()
                    .Validate(index =>
                        index >= 0 ? ValidationResult.Success() : ValidationResult.Error()));
        }
        private string GetOutputFileNameFromUser(string fileType)
        {
            return AnsiConsole.Ask<string>($);
        }
        public void StartCapture(CaptureMode captureMode)
        {
            _captureMode = captureMode;
            Log(, Verbosity.Basic);
            PrintSharpPcapVersion();
            var devices = GetDevices();
            if (devices.Count < 1)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            DisplayAvailableDevices(devices);
            int deviceIndex = GetDeviceIndexFromUser();
            string capFile = null;
            string csvFile = null;
            if (_captureMode == CaptureMode.Cap)
            {
                capFile = GetOutputFileNameFromUser();
            }
            if (_captureMode == CaptureMode.Csv)
            {
                csvFile = GetOutputFileNameFromUser();
            }
            CapturePackets(devices[deviceIndex], capFile, csvFile);
        }
        private void CapturePackets(ICaptureDevice device, string capFile, string csvFile)
        {
            device.OnPacketArrival += new PacketArrivalEventHandler(device_OnPacketArrivalCapture);
            device.Open(DeviceModes.Promiscuous | DeviceModes.DataTransferUdp | DeviceModes.NoCaptureLocal, read_timeout: 1000);
            Log($, Verbosity.Basic);
            if (_captureMode == CaptureMode.Cap && capFile != null)
            {
                captureFileWriter = new CaptureFileWriterDevice(capFile);
                captureFileWriter.Open(device);
            }
            if (_captureMode == CaptureMode.Csv && csvFile != null)
            {
                csvWriter = new StreamWriter(csvFile);
                csv = new CsvWriter(csvWriter, CultureInfo.InvariantCulture);
                csv.WriteHeader<PacketRecord>();
                csv.NextRecord();
            }
            device.StartCapture();
            if (_verbosity >= Verbosity.Detailed)
            {
                Console.WriteLine();
                AnsiConsole.Write(
                 new Rule()
                     .RuleStyle()
                     .Centered());
                Console.WriteLine();
            }
            Console.ReadLine();
            device.StopCapture();
            if (_captureMode == CaptureMode.Cap && captureFileWriter != null)
            {
                captureFileWriter.Close();
            }
            if (_captureMode == CaptureMode.Csv && csvWriter != null)","{
                csvWriter.Close();
            }","Log(, Verbosity.Basic);
            LogDeviceStatistics(device.Statistics.ToString());
        }
        private static void device_OnPacketArrivalCapture(object sender, PacketCapture e)
        {
            var rawPacket = e.GetPacket();
            _packetProcessor.ProcessPacket(rawPacket);
            if (captureFileWriter != null)
            {
                captureFileWriter.Write(rawPacket);
            }
            if (rawPacket.LinkLayerType == PacketDotNet.LinkLayers.Ethernet)
            {
                var packet = PacketDotNet.Packet.ParsePacket(rawPacket.LinkLayerType, rawPacket.Data);
                var ethernetPacket = packet.Extract<EthernetPacket>();
                if (ethernetPacket != null)
                {
                    var ipPacket = ethernetPacket.Extract<IPPacket>();
                    var tcpPacket = ipPacket?.Extract<TcpPacket>();
                    var udpPacket = ipPacket?.Extract<UdpPacket>();
                    LogPacketInfo(packet, Verbosity.Detailed);
                    var record = FeatureExtractor.ExtractFeatures(rawPacket);
                    if (csv != null)
                    {
                        csv.WriteRecord(record);
                        csv.NextRecord();
                        csv.Flush();
                    }
                }
            }
        }
        private void Log(string message, Verbosity requiredVerbosity)
        {
            _logger.Log(message, requiredVerbosity);
        }
        private void LogDeviceStatistics(string statistics)
        {
            _logger.LogDeviceStatistics(statistics);
        }
        public static void LogPacketInfo(PacketDotNet.Packet packet, Verbosity requiredVerbosity)
        {
            _logger.LogPacketInfo(packet, requiredVerbosity);
        }
    }
}",ClassificationPacketCaptureService.cs
"using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using CsvHelper;
using PacketDotNet;
using PcapDotNet.Packets;
using SharpPcap;
using SharpPcap.LibPcap;
using Spectre.Console;
using TinyIDS.Models;
using TinyIDS.Utils;
namespace TinyIDS.Services
{
    public enum CaptureMode
    {
        Csv,
        Cap,
        Flow
    }
    public class PacketCaptureService
    {
        private ICaptureDevice _device;
        private static CaptureFileWriterDevice captureFileWriter;
        private static StreamWriter csvWriter;
        private static CsvWriter csv;
        private static Verbosity _verbosity;
        private CaptureMode _captureMode;
        private static PacketProcessor _packetProcessor;
        private static Logger _logger;
        public PacketCaptureService(Verbosity verbosity)
        {
            _logger = new Logger(verbosity);
            _packetProcessor = new PacketProcessor(_logger, );
        }
        public void ListDevices()
        {
            var devices = CaptureDeviceList.Instance;
            if (devices.Count == 0)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            var table = new Table();
            table.AddColumn();
            table.AddColumn();
            foreach (var device in devices)
            {
                table.AddRow(device.Name, device.Description);
            }
            AnsiConsole.Write(table);
        }
        public void PrintSharpPcapVersion()
        {
            var ver = Pcap.SharpPcapVersion;
            Log($, Verbosity.Basic);
        }
        private LibPcapLiveDeviceList GetDevices()
        {
            return LibPcapLiveDeviceList.Instance;
        }
        private void DisplayAvailableDevices(LibPcapLiveDeviceList devices)
        {
            var table = new Table();
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            for (int i = 0; i < devices.Count; i++)
            {
                var dev = devices[i];
                table.AddRow(i.ToString(), dev.Name, dev.Description);
            }
            AnsiConsole.Write(table);
        }
        private int GetDeviceIndexFromUser()
        {
            return AnsiConsole.Prompt(
                new TextPrompt<int>()
                    .PromptStyle()
                    .Validate(index =>
                        index >= 0 ? ValidationResult.Success() : ValidationResult.Error()));
        }
        private string GetOutputFileNameFromUser(string fileType)
        {
            return AnsiConsole.Ask<string>($);
        }
        public void StartCapture(CaptureMode captureMode)
        {
            _captureMode = captureMode;
            Log(, Verbosity.Basic);
            PrintSharpPcapVersion();
            var devices = GetDevices();
            if (devices.Count < 1)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            DisplayAvailableDevices(devices);
            int deviceIndex = GetDeviceIndexFromUser();
            string capFile = null;
            string csvFile = null;
            if (_captureMode == CaptureMode.Cap)
            {
                capFile = GetOutputFileNameFromUser();","}
            if (_captureMode == CaptureMode.Csv)
            {","csvFile = GetOutputFileNameFromUser();
            }
            CapturePackets(devices[deviceIndex], capFile, csvFile);
        }
        private void CapturePackets(ICaptureDevice device, string capFile, string csvFile)
        {
            device.OnPacketArrival += new PacketArrivalEventHandler(device_OnPacketArrivalCapture);
            device.Open(DeviceModes.Promiscuous | DeviceModes.DataTransferUdp | DeviceModes.NoCaptureLocal, read_timeout: 1000);
            Log($, Verbosity.Basic);
            if (_captureMode == CaptureMode.Cap && capFile != null)
            {
                captureFileWriter = new CaptureFileWriterDevice(capFile);
                captureFileWriter.Open(device);
            }
            if (_captureMode == CaptureMode.Csv && csvFile != null)
            {
                csvWriter = new StreamWriter(csvFile);
                csv = new CsvWriter(csvWriter, CultureInfo.InvariantCulture);
                csv.WriteHeader<PacketRecord>();
                csv.NextRecord();
            }
            device.StartCapture();
            if (_verbosity >= Verbosity.Detailed)
            {
                Console.WriteLine();
                AnsiConsole.Write(
                 new Rule()
                     .RuleStyle()
                     .Centered());
                Console.WriteLine();
            }
            Console.ReadLine();
            device.StopCapture();
            if (_captureMode == CaptureMode.Cap && captureFileWriter != null)
            {
                captureFileWriter.Close();
            }
            if (_captureMode == CaptureMode.Csv && csvWriter != null)
            {
                csvWriter.Close();
            }
            Log(, Verbosity.Basic);
            LogDeviceStatistics(device.Statistics.ToString());
        }
        private static void device_OnPacketArrivalCapture(object sender, PacketCapture e)
        {
            var rawPacket = e.GetPacket();
            _packetProcessor.ProcessPacket(rawPacket);
            if (captureFileWriter != null)
            {
                captureFileWriter.Write(rawPacket);
            }
            if (rawPacket.LinkLayerType == PacketDotNet.LinkLayers.Ethernet)
            {
                var packet = PacketDotNet.Packet.ParsePacket(rawPacket.LinkLayerType, rawPacket.Data);
                var ethernetPacket = packet.Extract<EthernetPacket>();
                if (ethernetPacket != null)
                {
                    var ipPacket = ethernetPacket.Extract<IPPacket>();
                    var tcpPacket = ipPacket?.Extract<TcpPacket>();
                    var udpPacket = ipPacket?.Extract<UdpPacket>();
                    LogPacketInfo(packet, Verbosity.Detailed);
                    var record = FeatureExtractor.ExtractFeatures(rawPacket);
                    if (csv != null)
                    {
                        csv.WriteRecord(record);
                        csv.NextRecord();
                        csv.Flush();
                    }
                }
            }
        }
        private void Log(string message, Verbosity requiredVerbosity)
        {
            _logger.Log(message, requiredVerbosity);
        }
        private void LogDeviceStatistics(string statistics)
        {
            _logger.LogDeviceStatistics(statistics);
        }
        public static void LogPacketInfo(PacketDotNet.Packet packet, Verbosity requiredVerbosity)
        {
            _logger.LogPacketInfo(packet, requiredVerbosity);
        }
    }
}",ClassificationPacketCaptureService.cs
"using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using CsvHelper;
using PacketDotNet;
using PcapDotNet.Packets;
using SharpPcap;
using SharpPcap.LibPcap;
using Spectre.Console;
using TinyIDS.Models;
using TinyIDS.Utils;
namespace TinyIDS.Services
{
    public enum CaptureMode
    {
        Csv,
        Cap,
        Flow
    }
    public class PacketCaptureService
    {
        private ICaptureDevice _device;
        private static CaptureFileWriterDevice captureFileWriter;
        private static StreamWriter csvWriter;
        private static CsvWriter csv;
        private static Verbosity _verbosity;
        private CaptureMode _captureMode;
        private static PacketProcessor _packetProcessor;
        private static Logger _logger;
        public PacketCaptureService(Verbosity verbosity)
        {
            _logger = new Logger(verbosity);
            _packetProcessor = new PacketProcessor(_logger, );
        }
        public void ListDevices()
        {
            var devices = CaptureDeviceList.Instance;
            if (devices.Count == 0)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            var table = new Table();
            table.AddColumn();
            table.AddColumn();
            foreach (var device in devices)
            {
                table.AddRow(device.Name, device.Description);
            }
            AnsiConsole.Write(table);
        }
        public void PrintSharpPcapVersion()
        {
            var ver = Pcap.SharpPcapVersion;
            Log($, Verbosity.Basic);
        }
        private LibPcapLiveDeviceList GetDevices()
        {
            return LibPcapLiveDeviceList.Instance;
        }
        private void DisplayAvailableDevices(LibPcapLiveDeviceList devices)
        {
            var table = new Table();
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            for (int i = 0; i < devices.Count; i++)
            {
                var dev = devices[i];
                table.AddRow(i.ToString(), dev.Name, dev.Description);
            }
            AnsiConsole.Write(table);
        }
        private int GetDeviceIndexFromUser()
        {","return AnsiConsole.Prompt(
                new TextPrompt<int>()
                    .PromptStyle()",".Validate(index =>
                        index >= 0 ? ValidationResult.Success() : ValidationResult.Error()));
        }
        private string GetOutputFileNameFromUser(string fileType)
        {
            return AnsiConsole.Ask<string>($);
        }
        public void StartCapture(CaptureMode captureMode)
        {
            _captureMode = captureMode;
            Log(, Verbosity.Basic);
            PrintSharpPcapVersion();
            var devices = GetDevices();
            if (devices.Count < 1)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            DisplayAvailableDevices(devices);
            int deviceIndex = GetDeviceIndexFromUser();
            string capFile = null;
            string csvFile = null;
            if (_captureMode == CaptureMode.Cap)
            {
                capFile = GetOutputFileNameFromUser();
            }
            if (_captureMode == CaptureMode.Csv)
            {
                csvFile = GetOutputFileNameFromUser();
            }
            CapturePackets(devices[deviceIndex], capFile, csvFile);
        }
        private void CapturePackets(ICaptureDevice device, string capFile, string csvFile)
        {
            device.OnPacketArrival += new PacketArrivalEventHandler(device_OnPacketArrivalCapture);
            device.Open(DeviceModes.Promiscuous | DeviceModes.DataTransferUdp | DeviceModes.NoCaptureLocal, read_timeout: 1000);
            Log($, Verbosity.Basic);
            if (_captureMode == CaptureMode.Cap && capFile != null)
            {
                captureFileWriter = new CaptureFileWriterDevice(capFile);
                captureFileWriter.Open(device);
            }
            if (_captureMode == CaptureMode.Csv && csvFile != null)
            {
                csvWriter = new StreamWriter(csvFile);
                csv = new CsvWriter(csvWriter, CultureInfo.InvariantCulture);
                csv.WriteHeader<PacketRecord>();
                csv.NextRecord();
            }
            device.StartCapture();
            if (_verbosity >= Verbosity.Detailed)
            {
                Console.WriteLine();
                AnsiConsole.Write(
                 new Rule()
                     .RuleStyle()
                     .Centered());
                Console.WriteLine();
            }
            Console.ReadLine();
            device.StopCapture();
            if (_captureMode == CaptureMode.Cap && captureFileWriter != null)
            {
                captureFileWriter.Close();
            }
            if (_captureMode == CaptureMode.Csv && csvWriter != null)
            {
                csvWriter.Close();
            }
            Log(, Verbosity.Basic);
            LogDeviceStatistics(device.Statistics.ToString());
        }
        private static void device_OnPacketArrivalCapture(object sender, PacketCapture e)
        {
            var rawPacket = e.GetPacket();
            _packetProcessor.ProcessPacket(rawPacket);
            if (captureFileWriter != null)
            {
                captureFileWriter.Write(rawPacket);
            }
            if (rawPacket.LinkLayerType == PacketDotNet.LinkLayers.Ethernet)
            {
                var packet = PacketDotNet.Packet.ParsePacket(rawPacket.LinkLayerType, rawPacket.Data);
                var ethernetPacket = packet.Extract<EthernetPacket>();
                if (ethernetPacket != null)
                {
                    var ipPacket = ethernetPacket.Extract<IPPacket>();
                    var tcpPacket = ipPacket?.Extract<TcpPacket>();
                    var udpPacket = ipPacket?.Extract<UdpPacket>();
                    LogPacketInfo(packet, Verbosity.Detailed);
                    var record = FeatureExtractor.ExtractFeatures(rawPacket);
                    if (csv != null)
                    {
                        csv.WriteRecord(record);
                        csv.NextRecord();
                        csv.Flush();
                    }
                }
            }
        }
        private void Log(string message, Verbosity requiredVerbosity)
        {
            _logger.Log(message, requiredVerbosity);
        }
        private void LogDeviceStatistics(string statistics)
        {
            _logger.LogDeviceStatistics(statistics);
        }
        public static void LogPacketInfo(PacketDotNet.Packet packet, Verbosity requiredVerbosity)
        {
            _logger.LogPacketInfo(packet, requiredVerbosity);
        }
    }
}",ClassificationPacketCaptureService.cs
"using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using CsvHelper;
using PacketDotNet;
using PcapDotNet.Packets;
using SharpPcap;
using SharpPcap.LibPcap;
using Spectre.Console;
using TinyIDS.Models;
using TinyIDS.Utils;
namespace TinyIDS.Services
{
    public enum CaptureMode
    {
        Csv,
        Cap,
        Flow
    }
    public class PacketCaptureService
    {
        private ICaptureDevice _device;
        private static CaptureFileWriterDevice captureFileWriter;
        private static StreamWriter csvWriter;
        private static CsvWriter csv;
        private static Verbosity _verbosity;
        private CaptureMode _captureMode;
        private static PacketProcessor _packetProcessor;
        private static Logger _logger;
        public PacketCaptureService(Verbosity verbosity)
        {
            _logger = new Logger(verbosity);
            _packetProcessor = new PacketProcessor(_logger, );
        }
        public void ListDevices()
        {
            var devices = CaptureDeviceList.Instance;
            if (devices.Count == 0)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            var table = new Table();
            table.AddColumn();
            table.AddColumn();
            foreach (var device in devices)
            {
                table.AddRow(device.Name, device.Description);
            }
            AnsiConsole.Write(table);
        }
        public void PrintSharpPcapVersion()
        {
            var ver = Pcap.SharpPcapVersion;
            Log($, Verbosity.Basic);
        }
        private LibPcapLiveDeviceList GetDevices()
        {
            return LibPcapLiveDeviceList.Instance;
        }
        private void DisplayAvailableDevices(LibPcapLiveDeviceList devices)
        {
            var table = new Table();
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            for (int i = 0; i < devices.Count; i++)
            {
                var dev = devices[i];
                table.AddRow(i.ToString(), dev.Name, dev.Description);
            }
            AnsiConsole.Write(table);
        }
        private int GetDeviceIndexFromUser()
        {
            return AnsiConsole.Prompt(
                new TextPrompt<int>()
                    .PromptStyle()
                    .Validate(index =>
                        index >= 0 ? ValidationResult.Success() : ValidationResult.Error()));
        }
        private string GetOutputFileNameFromUser(string fileType)
        {
            return AnsiConsole.Ask<string>($);
        }
        public void StartCapture(CaptureMode captureMode)
        {
            _captureMode = captureMode;
            Log(, Verbosity.Basic);
            PrintSharpPcapVersion();
            var devices = GetDevices();
            if (devices.Count < 1)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            DisplayAvailableDevices(devices);
            int deviceIndex = GetDeviceIndexFromUser();
            string capFile = null;
            string csvFile = null;
            if (_captureMode == CaptureMode.Cap)
            {
                capFile = GetOutputFileNameFromUser();
            }
            if (_captureMode == CaptureMode.Csv)
            {
                csvFile = GetOutputFileNameFromUser();
            }
            CapturePackets(devices[deviceIndex], capFile, csvFile);
        }
        private void CapturePackets(ICaptureDevice device, string capFile, string csvFile)
        {
            device.OnPacketArrival += new PacketArrivalEventHandler(device_OnPacketArrivalCapture);
            device.Open(DeviceModes.Promiscuous | DeviceModes.DataTransferUdp | DeviceModes.NoCaptureLocal, read_timeout: 1000);
            Log($, Verbosity.Basic);
            if (_captureMode == CaptureMode.Cap && capFile != null)
            {
                captureFileWriter = new CaptureFileWriterDevice(capFile);
                captureFileWriter.Open(device);
            }","if (_captureMode == CaptureMode.Csv && csvFile != null)
            {
                csvWriter = new StreamWriter(csvFile);","csv = new CsvWriter(csvWriter, CultureInfo.InvariantCulture);
                csv.WriteHeader<PacketRecord>();
                csv.NextRecord();
            }
            device.StartCapture();
            if (_verbosity >= Verbosity.Detailed)
            {
                Console.WriteLine();
                AnsiConsole.Write(
                 new Rule()
                     .RuleStyle()
                     .Centered());
                Console.WriteLine();
            }
            Console.ReadLine();
            device.StopCapture();
            if (_captureMode == CaptureMode.Cap && captureFileWriter != null)
            {
                captureFileWriter.Close();
            }
            if (_captureMode == CaptureMode.Csv && csvWriter != null)
            {
                csvWriter.Close();
            }
            Log(, Verbosity.Basic);
            LogDeviceStatistics(device.Statistics.ToString());
        }
        private static void device_OnPacketArrivalCapture(object sender, PacketCapture e)
        {
            var rawPacket = e.GetPacket();
            _packetProcessor.ProcessPacket(rawPacket);
            if (captureFileWriter != null)
            {
                captureFileWriter.Write(rawPacket);
            }
            if (rawPacket.LinkLayerType == PacketDotNet.LinkLayers.Ethernet)
            {
                var packet = PacketDotNet.Packet.ParsePacket(rawPacket.LinkLayerType, rawPacket.Data);
                var ethernetPacket = packet.Extract<EthernetPacket>();
                if (ethernetPacket != null)
                {
                    var ipPacket = ethernetPacket.Extract<IPPacket>();
                    var tcpPacket = ipPacket?.Extract<TcpPacket>();
                    var udpPacket = ipPacket?.Extract<UdpPacket>();
                    LogPacketInfo(packet, Verbosity.Detailed);
                    var record = FeatureExtractor.ExtractFeatures(rawPacket);
                    if (csv != null)
                    {
                        csv.WriteRecord(record);
                        csv.NextRecord();
                        csv.Flush();
                    }
                }
            }
        }
        private void Log(string message, Verbosity requiredVerbosity)
        {
            _logger.Log(message, requiredVerbosity);
        }
        private void LogDeviceStatistics(string statistics)
        {
            _logger.LogDeviceStatistics(statistics);
        }
        public static void LogPacketInfo(PacketDotNet.Packet packet, Verbosity requiredVerbosity)
        {
            _logger.LogPacketInfo(packet, requiredVerbosity);
        }
    }
}",ClassificationPacketCaptureService.cs
"using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using CsvHelper;
using PacketDotNet;
using PcapDotNet.Packets;
using SharpPcap;
using SharpPcap.LibPcap;
using Spectre.Console;
using TinyIDS.Models;
using TinyIDS.Utils;
namespace TinyIDS.Services
{
    public enum CaptureMode
    {
        Csv,
        Cap,
        Flow
    }
    public class PacketCaptureService
    {
        private ICaptureDevice _device;
        private static CaptureFileWriterDevice captureFileWriter;
        private static StreamWriter csvWriter;
        private static CsvWriter csv;
        private static Verbosity _verbosity;
        private CaptureMode _captureMode;
        private static PacketProcessor _packetProcessor;
        private static Logger _logger;
        public PacketCaptureService(Verbosity verbosity)
        {
            _logger = new Logger(verbosity);
            _packetProcessor = new PacketProcessor(_logger, );
        }
        public void ListDevices()
        {
            var devices = CaptureDeviceList.Instance;
            if (devices.Count == 0)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            var table = new Table();
            table.AddColumn();
            table.AddColumn();
            foreach (var device in devices)
            {
                table.AddRow(device.Name, device.Description);
            }
            AnsiConsole.Write(table);
        }
        public void PrintSharpPcapVersion()
        {
            var ver = Pcap.SharpPcapVersion;
            Log($, Verbosity.Basic);
        }
        private LibPcapLiveDeviceList GetDevices()
        {
            return LibPcapLiveDeviceList.Instance;
        }
        private void DisplayAvailableDevices(LibPcapLiveDeviceList devices)
        {
            var table = new Table();
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            for (int i = 0; i < devices.Count; i++)
            {
                var dev = devices[i];","table.AddRow(i.ToString(), dev.Name, dev.Description);
            }
            AnsiConsole.Write(table);","}
        private int GetDeviceIndexFromUser()
        {
            return AnsiConsole.Prompt(
                new TextPrompt<int>()
                    .PromptStyle()
                    .Validate(index =>
                        index >= 0 ? ValidationResult.Success() : ValidationResult.Error()));
        }
        private string GetOutputFileNameFromUser(string fileType)
        {
            return AnsiConsole.Ask<string>($);
        }
        public void StartCapture(CaptureMode captureMode)
        {
            _captureMode = captureMode;
            Log(, Verbosity.Basic);
            PrintSharpPcapVersion();
            var devices = GetDevices();
            if (devices.Count < 1)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            DisplayAvailableDevices(devices);
            int deviceIndex = GetDeviceIndexFromUser();
            string capFile = null;
            string csvFile = null;
            if (_captureMode == CaptureMode.Cap)
            {
                capFile = GetOutputFileNameFromUser();
            }
            if (_captureMode == CaptureMode.Csv)
            {
                csvFile = GetOutputFileNameFromUser();
            }
            CapturePackets(devices[deviceIndex], capFile, csvFile);
        }
        private void CapturePackets(ICaptureDevice device, string capFile, string csvFile)
        {
            device.OnPacketArrival += new PacketArrivalEventHandler(device_OnPacketArrivalCapture);
            device.Open(DeviceModes.Promiscuous | DeviceModes.DataTransferUdp | DeviceModes.NoCaptureLocal, read_timeout: 1000);
            Log($, Verbosity.Basic);
            if (_captureMode == CaptureMode.Cap && capFile != null)
            {
                captureFileWriter = new CaptureFileWriterDevice(capFile);
                captureFileWriter.Open(device);
            }
            if (_captureMode == CaptureMode.Csv && csvFile != null)
            {
                csvWriter = new StreamWriter(csvFile);
                csv = new CsvWriter(csvWriter, CultureInfo.InvariantCulture);
                csv.WriteHeader<PacketRecord>();
                csv.NextRecord();
            }
            device.StartCapture();
            if (_verbosity >= Verbosity.Detailed)
            {
                Console.WriteLine();
                AnsiConsole.Write(
                 new Rule()
                     .RuleStyle()
                     .Centered());
                Console.WriteLine();
            }
            Console.ReadLine();
            device.StopCapture();
            if (_captureMode == CaptureMode.Cap && captureFileWriter != null)
            {
                captureFileWriter.Close();
            }
            if (_captureMode == CaptureMode.Csv && csvWriter != null)
            {
                csvWriter.Close();
            }
            Log(, Verbosity.Basic);
            LogDeviceStatistics(device.Statistics.ToString());
        }
        private static void device_OnPacketArrivalCapture(object sender, PacketCapture e)
        {
            var rawPacket = e.GetPacket();
            _packetProcessor.ProcessPacket(rawPacket);
            if (captureFileWriter != null)
            {
                captureFileWriter.Write(rawPacket);
            }
            if (rawPacket.LinkLayerType == PacketDotNet.LinkLayers.Ethernet)
            {
                var packet = PacketDotNet.Packet.ParsePacket(rawPacket.LinkLayerType, rawPacket.Data);
                var ethernetPacket = packet.Extract<EthernetPacket>();
                if (ethernetPacket != null)
                {
                    var ipPacket = ethernetPacket.Extract<IPPacket>();
                    var tcpPacket = ipPacket?.Extract<TcpPacket>();
                    var udpPacket = ipPacket?.Extract<UdpPacket>();
                    LogPacketInfo(packet, Verbosity.Detailed);
                    var record = FeatureExtractor.ExtractFeatures(rawPacket);
                    if (csv != null)
                    {
                        csv.WriteRecord(record);
                        csv.NextRecord();
                        csv.Flush();
                    }
                }
            }
        }
        private void Log(string message, Verbosity requiredVerbosity)
        {
            _logger.Log(message, requiredVerbosity);
        }
        private void LogDeviceStatistics(string statistics)
        {
            _logger.LogDeviceStatistics(statistics);
        }
        public static void LogPacketInfo(PacketDotNet.Packet packet, Verbosity requiredVerbosity)
        {
            _logger.LogPacketInfo(packet, requiredVerbosity);
        }
    }
}",ClassificationPacketCaptureService.cs
"using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using CsvHelper;
using PacketDotNet;
using PcapDotNet.Packets;
using SharpPcap;
using SharpPcap.LibPcap;
using Spectre.Console;
using TinyIDS.Models;
using TinyIDS.Utils;
namespace TinyIDS.Services
{
    public enum CaptureMode
    {
        Csv,
        Cap,
        Flow
    }
    public class PacketCaptureService
    {
        private ICaptureDevice _device;
        private static CaptureFileWriterDevice captureFileWriter;
        private static StreamWriter csvWriter;
        private static CsvWriter csv;
        private static Verbosity _verbosity;
        private CaptureMode _captureMode;
        private static PacketProcessor _packetProcessor;
        private static Logger _logger;
        public PacketCaptureService(Verbosity verbosity)
        {
            _logger = new Logger(verbosity);
            _packetProcessor = new PacketProcessor(_logger, );
        }
        public void ListDevices()
        {
            var devices = CaptureDeviceList.Instance;
            if (devices.Count == 0)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            var table = new Table();
            table.AddColumn();
            table.AddColumn();
            foreach (var device in devices)
            {
                table.AddRow(device.Name, device.Description);
            }
            AnsiConsole.Write(table);
        }
        public void PrintSharpPcapVersion()
        {
            var ver = Pcap.SharpPcapVersion;
            Log($, Verbosity.Basic);
        }
        private LibPcapLiveDeviceList GetDevices()
        {
            return LibPcapLiveDeviceList.Instance;
        }
        private void DisplayAvailableDevices(LibPcapLiveDeviceList devices)
        {
            var table = new Table();
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            for (int i = 0; i < devices.Count; i++)
            {
                var dev = devices[i];
                table.AddRow(i.ToString(), dev.Name, dev.Description);
            }
            AnsiConsole.Write(table);","}
        private int GetDeviceIndexFromUser()
        {","return AnsiConsole.Prompt(
                new TextPrompt<int>()
                    .PromptStyle()
                    .Validate(index =>
                        index >= 0 ? ValidationResult.Success() : ValidationResult.Error()));
        }
        private string GetOutputFileNameFromUser(string fileType)
        {
            return AnsiConsole.Ask<string>($);
        }
        public void StartCapture(CaptureMode captureMode)
        {
            _captureMode = captureMode;
            Log(, Verbosity.Basic);
            PrintSharpPcapVersion();
            var devices = GetDevices();
            if (devices.Count < 1)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            DisplayAvailableDevices(devices);
            int deviceIndex = GetDeviceIndexFromUser();
            string capFile = null;
            string csvFile = null;
            if (_captureMode == CaptureMode.Cap)
            {
                capFile = GetOutputFileNameFromUser();
            }
            if (_captureMode == CaptureMode.Csv)
            {
                csvFile = GetOutputFileNameFromUser();
            }
            CapturePackets(devices[deviceIndex], capFile, csvFile);
        }
        private void CapturePackets(ICaptureDevice device, string capFile, string csvFile)
        {
            device.OnPacketArrival += new PacketArrivalEventHandler(device_OnPacketArrivalCapture);
            device.Open(DeviceModes.Promiscuous | DeviceModes.DataTransferUdp | DeviceModes.NoCaptureLocal, read_timeout: 1000);
            Log($, Verbosity.Basic);
            if (_captureMode == CaptureMode.Cap && capFile != null)
            {
                captureFileWriter = new CaptureFileWriterDevice(capFile);
                captureFileWriter.Open(device);
            }
            if (_captureMode == CaptureMode.Csv && csvFile != null)
            {
                csvWriter = new StreamWriter(csvFile);
                csv = new CsvWriter(csvWriter, CultureInfo.InvariantCulture);
                csv.WriteHeader<PacketRecord>();
                csv.NextRecord();
            }
            device.StartCapture();
            if (_verbosity >= Verbosity.Detailed)
            {
                Console.WriteLine();
                AnsiConsole.Write(
                 new Rule()
                     .RuleStyle()
                     .Centered());
                Console.WriteLine();
            }
            Console.ReadLine();
            device.StopCapture();
            if (_captureMode == CaptureMode.Cap && captureFileWriter != null)
            {
                captureFileWriter.Close();
            }
            if (_captureMode == CaptureMode.Csv && csvWriter != null)
            {
                csvWriter.Close();
            }
            Log(, Verbosity.Basic);
            LogDeviceStatistics(device.Statistics.ToString());
        }
        private static void device_OnPacketArrivalCapture(object sender, PacketCapture e)
        {
            var rawPacket = e.GetPacket();
            _packetProcessor.ProcessPacket(rawPacket);
            if (captureFileWriter != null)
            {
                captureFileWriter.Write(rawPacket);
            }
            if (rawPacket.LinkLayerType == PacketDotNet.LinkLayers.Ethernet)
            {
                var packet = PacketDotNet.Packet.ParsePacket(rawPacket.LinkLayerType, rawPacket.Data);
                var ethernetPacket = packet.Extract<EthernetPacket>();
                if (ethernetPacket != null)
                {
                    var ipPacket = ethernetPacket.Extract<IPPacket>();
                    var tcpPacket = ipPacket?.Extract<TcpPacket>();
                    var udpPacket = ipPacket?.Extract<UdpPacket>();
                    LogPacketInfo(packet, Verbosity.Detailed);
                    var record = FeatureExtractor.ExtractFeatures(rawPacket);
                    if (csv != null)
                    {
                        csv.WriteRecord(record);
                        csv.NextRecord();
                        csv.Flush();
                    }
                }
            }
        }
        private void Log(string message, Verbosity requiredVerbosity)
        {
            _logger.Log(message, requiredVerbosity);
        }
        private void LogDeviceStatistics(string statistics)
        {
            _logger.LogDeviceStatistics(statistics);
        }
        public static void LogPacketInfo(PacketDotNet.Packet packet, Verbosity requiredVerbosity)
        {
            _logger.LogPacketInfo(packet, requiredVerbosity);
        }
    }
}",ClassificationPacketCaptureService.cs
"using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using CsvHelper;
using PacketDotNet;
using PcapDotNet.Packets;
using SharpPcap;
using SharpPcap.LibPcap;
using Spectre.Console;
using TinyIDS.Models;
using TinyIDS.Utils;
namespace TinyIDS.Services
{
    public enum CaptureMode
    {
        Csv,
        Cap,
        Flow
    }
    public class PacketCaptureService
    {
        private ICaptureDevice _device;
        private static CaptureFileWriterDevice captureFileWriter;
        private static StreamWriter csvWriter;
        private static CsvWriter csv;
        private static Verbosity _verbosity;
        private CaptureMode _captureMode;
        private static PacketProcessor _packetProcessor;
        private static Logger _logger;
        public PacketCaptureService(Verbosity verbosity)
        {
            _logger = new Logger(verbosity);
            _packetProcessor = new PacketProcessor(_logger, );
        }
        public void ListDevices()
        {
            var devices = CaptureDeviceList.Instance;
            if (devices.Count == 0)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            var table = new Table();
            table.AddColumn();
            table.AddColumn();
            foreach (var device in devices)
            {
                table.AddRow(device.Name, device.Description);
            }
            AnsiConsole.Write(table);
        }
        public void PrintSharpPcapVersion()
        {
            var ver = Pcap.SharpPcapVersion;
            Log($, Verbosity.Basic);
        }
        private LibPcapLiveDeviceList GetDevices()
        {
            return LibPcapLiveDeviceList.Instance;
        }
        private void DisplayAvailableDevices(LibPcapLiveDeviceList devices)
        {
            var table = new Table();
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            for (int i = 0; i < devices.Count; i++)
            {
                var dev = devices[i];
                table.AddRow(i.ToString(), dev.Name, dev.Description);
            }
            AnsiConsole.Write(table);
        }
        private int GetDeviceIndexFromUser()
        {
            return AnsiConsole.Prompt(
                new TextPrompt<int>()
                    .PromptStyle()
                    .Validate(index =>
                        index >= 0 ? ValidationResult.Success() : ValidationResult.Error()));
        }
        private string GetOutputFileNameFromUser(string fileType)
        {
            return AnsiConsole.Ask<string>($);
        }
        public void StartCapture(CaptureMode captureMode)
        {
            _captureMode = captureMode;
            Log(, Verbosity.Basic);
            PrintSharpPcapVersion();
            var devices = GetDevices();
            if (devices.Count < 1)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            DisplayAvailableDevices(devices);
            int deviceIndex = GetDeviceIndexFromUser();
            string capFile = null;
            string csvFile = null;
            if (_captureMode == CaptureMode.Cap)
            {
                capFile = GetOutputFileNameFromUser();
            }
            if (_captureMode == CaptureMode.Csv)
            {
                csvFile = GetOutputFileNameFromUser();
            }
            CapturePackets(devices[deviceIndex], capFile, csvFile);
        }
        private void CapturePackets(ICaptureDevice device, string capFile, string csvFile)
        {
            device.OnPacketArrival += new PacketArrivalEventHandler(device_OnPacketArrivalCapture);
            device.Open(DeviceModes.Promiscuous | DeviceModes.DataTransferUdp | DeviceModes.NoCaptureLocal, read_timeout: 1000);
            Log($, Verbosity.Basic);
            if (_captureMode == CaptureMode.Cap && capFile != null)
            {
                captureFileWriter = new CaptureFileWriterDevice(capFile);
                captureFileWriter.Open(device);
            }
            if (_captureMode == CaptureMode.Csv && csvFile != null)
            {
                csvWriter = new StreamWriter(csvFile);
                csv = new CsvWriter(csvWriter, CultureInfo.InvariantCulture);
                csv.WriteHeader<PacketRecord>();
                csv.NextRecord();
            }
            device.StartCapture();
            if (_verbosity >= Verbosity.Detailed)
            {
                Console.WriteLine();
                AnsiConsole.Write(
                 new Rule()",".RuleStyle()
                     .Centered());
                Console.WriteLine();","}
            Console.ReadLine();
            device.StopCapture();
            if (_captureMode == CaptureMode.Cap && captureFileWriter != null)
            {
                captureFileWriter.Close();
            }
            if (_captureMode == CaptureMode.Csv && csvWriter != null)
            {
                csvWriter.Close();
            }
            Log(, Verbosity.Basic);
            LogDeviceStatistics(device.Statistics.ToString());
        }
        private static void device_OnPacketArrivalCapture(object sender, PacketCapture e)
        {
            var rawPacket = e.GetPacket();
            _packetProcessor.ProcessPacket(rawPacket);
            if (captureFileWriter != null)
            {
                captureFileWriter.Write(rawPacket);
            }
            if (rawPacket.LinkLayerType == PacketDotNet.LinkLayers.Ethernet)
            {
                var packet = PacketDotNet.Packet.ParsePacket(rawPacket.LinkLayerType, rawPacket.Data);
                var ethernetPacket = packet.Extract<EthernetPacket>();
                if (ethernetPacket != null)
                {
                    var ipPacket = ethernetPacket.Extract<IPPacket>();
                    var tcpPacket = ipPacket?.Extract<TcpPacket>();
                    var udpPacket = ipPacket?.Extract<UdpPacket>();
                    LogPacketInfo(packet, Verbosity.Detailed);
                    var record = FeatureExtractor.ExtractFeatures(rawPacket);
                    if (csv != null)
                    {
                        csv.WriteRecord(record);
                        csv.NextRecord();
                        csv.Flush();
                    }
                }
            }
        }
        private void Log(string message, Verbosity requiredVerbosity)
        {
            _logger.Log(message, requiredVerbosity);
        }
        private void LogDeviceStatistics(string statistics)
        {
            _logger.LogDeviceStatistics(statistics);
        }
        public static void LogPacketInfo(PacketDotNet.Packet packet, Verbosity requiredVerbosity)
        {
            _logger.LogPacketInfo(packet, requiredVerbosity);
        }
    }
}",ClassificationPacketCaptureService.cs
"using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using CsvHelper;
using PacketDotNet;
using PcapDotNet.Packets;
using SharpPcap;
using SharpPcap.LibPcap;
using Spectre.Console;
using TinyIDS.Models;
using TinyIDS.Utils;
namespace TinyIDS.Services
{
    public enum CaptureMode
    {
        Csv,
        Cap,
        Flow
    }
    public class PacketCaptureService
    {
        private ICaptureDevice _device;
        private static CaptureFileWriterDevice captureFileWriter;
        private static StreamWriter csvWriter;
        private static CsvWriter csv;
        private static Verbosity _verbosity;
        private CaptureMode _captureMode;
        private static PacketProcessor _packetProcessor;
        private static Logger _logger;
        public PacketCaptureService(Verbosity verbosity)
        {
            _logger = new Logger(verbosity);
            _packetProcessor = new PacketProcessor(_logger, );
        }
        public void ListDevices()
        {
            var devices = CaptureDeviceList.Instance;
            if (devices.Count == 0)
            {
                AnsiConsole.MarkupLine();
                return;
            }","var table = new Table();
            table.AddColumn();
            table.AddColumn();","foreach (var device in devices)
            {
                table.AddRow(device.Name, device.Description);
            }
            AnsiConsole.Write(table);
        }
        public void PrintSharpPcapVersion()
        {
            var ver = Pcap.SharpPcapVersion;
            Log($, Verbosity.Basic);
        }
        private LibPcapLiveDeviceList GetDevices()
        {
            return LibPcapLiveDeviceList.Instance;
        }
        private void DisplayAvailableDevices(LibPcapLiveDeviceList devices)
        {
            var table = new Table();
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            for (int i = 0; i < devices.Count; i++)
            {
                var dev = devices[i];
                table.AddRow(i.ToString(), dev.Name, dev.Description);
            }
            AnsiConsole.Write(table);
        }
        private int GetDeviceIndexFromUser()
        {
            return AnsiConsole.Prompt(
                new TextPrompt<int>()
                    .PromptStyle()
                    .Validate(index =>
                        index >= 0 ? ValidationResult.Success() : ValidationResult.Error()));
        }
        private string GetOutputFileNameFromUser(string fileType)
        {
            return AnsiConsole.Ask<string>($);
        }
        public void StartCapture(CaptureMode captureMode)
        {
            _captureMode = captureMode;
            Log(, Verbosity.Basic);
            PrintSharpPcapVersion();
            var devices = GetDevices();
            if (devices.Count < 1)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            DisplayAvailableDevices(devices);
            int deviceIndex = GetDeviceIndexFromUser();
            string capFile = null;
            string csvFile = null;
            if (_captureMode == CaptureMode.Cap)
            {
                capFile = GetOutputFileNameFromUser();
            }
            if (_captureMode == CaptureMode.Csv)
            {
                csvFile = GetOutputFileNameFromUser();
            }
            CapturePackets(devices[deviceIndex], capFile, csvFile);
        }
        private void CapturePackets(ICaptureDevice device, string capFile, string csvFile)
        {
            device.OnPacketArrival += new PacketArrivalEventHandler(device_OnPacketArrivalCapture);
            device.Open(DeviceModes.Promiscuous | DeviceModes.DataTransferUdp | DeviceModes.NoCaptureLocal, read_timeout: 1000);
            Log($, Verbosity.Basic);
            if (_captureMode == CaptureMode.Cap && capFile != null)
            {
                captureFileWriter = new CaptureFileWriterDevice(capFile);
                captureFileWriter.Open(device);
            }
            if (_captureMode == CaptureMode.Csv && csvFile != null)
            {
                csvWriter = new StreamWriter(csvFile);
                csv = new CsvWriter(csvWriter, CultureInfo.InvariantCulture);
                csv.WriteHeader<PacketRecord>();
                csv.NextRecord();
            }
            device.StartCapture();
            if (_verbosity >= Verbosity.Detailed)
            {
                Console.WriteLine();
                AnsiConsole.Write(
                 new Rule()
                     .RuleStyle()
                     .Centered());
                Console.WriteLine();
            }
            Console.ReadLine();
            device.StopCapture();
            if (_captureMode == CaptureMode.Cap && captureFileWriter != null)
            {
                captureFileWriter.Close();
            }
            if (_captureMode == CaptureMode.Csv && csvWriter != null)
            {
                csvWriter.Close();
            }
            Log(, Verbosity.Basic);
            LogDeviceStatistics(device.Statistics.ToString());
        }
        private static void device_OnPacketArrivalCapture(object sender, PacketCapture e)
        {
            var rawPacket = e.GetPacket();
            _packetProcessor.ProcessPacket(rawPacket);
            if (captureFileWriter != null)
            {
                captureFileWriter.Write(rawPacket);
            }
            if (rawPacket.LinkLayerType == PacketDotNet.LinkLayers.Ethernet)
            {
                var packet = PacketDotNet.Packet.ParsePacket(rawPacket.LinkLayerType, rawPacket.Data);
                var ethernetPacket = packet.Extract<EthernetPacket>();
                if (ethernetPacket != null)
                {
                    var ipPacket = ethernetPacket.Extract<IPPacket>();
                    var tcpPacket = ipPacket?.Extract<TcpPacket>();
                    var udpPacket = ipPacket?.Extract<UdpPacket>();
                    LogPacketInfo(packet, Verbosity.Detailed);
                    var record = FeatureExtractor.ExtractFeatures(rawPacket);
                    if (csv != null)
                    {
                        csv.WriteRecord(record);
                        csv.NextRecord();
                        csv.Flush();
                    }
                }
            }
        }
        private void Log(string message, Verbosity requiredVerbosity)
        {
            _logger.Log(message, requiredVerbosity);
        }
        private void LogDeviceStatistics(string statistics)
        {
            _logger.LogDeviceStatistics(statistics);
        }
        public static void LogPacketInfo(PacketDotNet.Packet packet, Verbosity requiredVerbosity)
        {
            _logger.LogPacketInfo(packet, requiredVerbosity);
        }
    }
}",ClassificationPacketCaptureService.cs
"using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using CsvHelper;
using PacketDotNet;
using PcapDotNet.Packets;
using SharpPcap;
using SharpPcap.LibPcap;
using Spectre.Console;
using TinyIDS.Models;
using TinyIDS.Utils;
namespace TinyIDS.Services
{
    public enum CaptureMode
    {
        Csv,
        Cap,
        Flow
    }
    public class PacketCaptureService
    {
        private ICaptureDevice _device;
        private static CaptureFileWriterDevice captureFileWriter;
        private static StreamWriter csvWriter;
        private static CsvWriter csv;
        private static Verbosity _verbosity;
        private CaptureMode _captureMode;
        private static PacketProcessor _packetProcessor;
        private static Logger _logger;
        public PacketCaptureService(Verbosity verbosity)","{
            _logger = new Logger(verbosity);
            _packetProcessor = new PacketProcessor(_logger, );","}
        public void ListDevices()
        {
            var devices = CaptureDeviceList.Instance;
            if (devices.Count == 0)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            var table = new Table();
            table.AddColumn();
            table.AddColumn();
            foreach (var device in devices)
            {
                table.AddRow(device.Name, device.Description);
            }
            AnsiConsole.Write(table);
        }
        public void PrintSharpPcapVersion()
        {
            var ver = Pcap.SharpPcapVersion;
            Log($, Verbosity.Basic);
        }
        private LibPcapLiveDeviceList GetDevices()
        {
            return LibPcapLiveDeviceList.Instance;
        }
        private void DisplayAvailableDevices(LibPcapLiveDeviceList devices)
        {
            var table = new Table();
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            for (int i = 0; i < devices.Count; i++)
            {
                var dev = devices[i];
                table.AddRow(i.ToString(), dev.Name, dev.Description);
            }
            AnsiConsole.Write(table);
        }
        private int GetDeviceIndexFromUser()
        {
            return AnsiConsole.Prompt(
                new TextPrompt<int>()
                    .PromptStyle()
                    .Validate(index =>
                        index >= 0 ? ValidationResult.Success() : ValidationResult.Error()));
        }
        private string GetOutputFileNameFromUser(string fileType)
        {
            return AnsiConsole.Ask<string>($);
        }
        public void StartCapture(CaptureMode captureMode)
        {
            _captureMode = captureMode;
            Log(, Verbosity.Basic);
            PrintSharpPcapVersion();
            var devices = GetDevices();
            if (devices.Count < 1)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            DisplayAvailableDevices(devices);
            int deviceIndex = GetDeviceIndexFromUser();
            string capFile = null;
            string csvFile = null;
            if (_captureMode == CaptureMode.Cap)
            {
                capFile = GetOutputFileNameFromUser();
            }
            if (_captureMode == CaptureMode.Csv)
            {
                csvFile = GetOutputFileNameFromUser();
            }
            CapturePackets(devices[deviceIndex], capFile, csvFile);
        }
        private void CapturePackets(ICaptureDevice device, string capFile, string csvFile)
        {
            device.OnPacketArrival += new PacketArrivalEventHandler(device_OnPacketArrivalCapture);
            device.Open(DeviceModes.Promiscuous | DeviceModes.DataTransferUdp | DeviceModes.NoCaptureLocal, read_timeout: 1000);
            Log($, Verbosity.Basic);
            if (_captureMode == CaptureMode.Cap && capFile != null)
            {
                captureFileWriter = new CaptureFileWriterDevice(capFile);
                captureFileWriter.Open(device);
            }
            if (_captureMode == CaptureMode.Csv && csvFile != null)
            {
                csvWriter = new StreamWriter(csvFile);
                csv = new CsvWriter(csvWriter, CultureInfo.InvariantCulture);
                csv.WriteHeader<PacketRecord>();
                csv.NextRecord();
            }
            device.StartCapture();
            if (_verbosity >= Verbosity.Detailed)
            {
                Console.WriteLine();
                AnsiConsole.Write(
                 new Rule()
                     .RuleStyle()
                     .Centered());
                Console.WriteLine();
            }
            Console.ReadLine();
            device.StopCapture();
            if (_captureMode == CaptureMode.Cap && captureFileWriter != null)
            {
                captureFileWriter.Close();
            }
            if (_captureMode == CaptureMode.Csv && csvWriter != null)
            {
                csvWriter.Close();
            }
            Log(, Verbosity.Basic);
            LogDeviceStatistics(device.Statistics.ToString());
        }
        private static void device_OnPacketArrivalCapture(object sender, PacketCapture e)
        {
            var rawPacket = e.GetPacket();
            _packetProcessor.ProcessPacket(rawPacket);
            if (captureFileWriter != null)
            {
                captureFileWriter.Write(rawPacket);
            }
            if (rawPacket.LinkLayerType == PacketDotNet.LinkLayers.Ethernet)
            {
                var packet = PacketDotNet.Packet.ParsePacket(rawPacket.LinkLayerType, rawPacket.Data);
                var ethernetPacket = packet.Extract<EthernetPacket>();
                if (ethernetPacket != null)
                {
                    var ipPacket = ethernetPacket.Extract<IPPacket>();
                    var tcpPacket = ipPacket?.Extract<TcpPacket>();
                    var udpPacket = ipPacket?.Extract<UdpPacket>();
                    LogPacketInfo(packet, Verbosity.Detailed);
                    var record = FeatureExtractor.ExtractFeatures(rawPacket);
                    if (csv != null)
                    {
                        csv.WriteRecord(record);
                        csv.NextRecord();
                        csv.Flush();
                    }
                }
            }
        }
        private void Log(string message, Verbosity requiredVerbosity)
        {
            _logger.Log(message, requiredVerbosity);
        }
        private void LogDeviceStatistics(string statistics)
        {
            _logger.LogDeviceStatistics(statistics);
        }
        public static void LogPacketInfo(PacketDotNet.Packet packet, Verbosity requiredVerbosity)
        {
            _logger.LogPacketInfo(packet, requiredVerbosity);
        }
    }
}",ClassificationPacketCaptureService.cs
"using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using CsvHelper;
using PacketDotNet;
using PcapDotNet.Packets;
using SharpPcap;
using SharpPcap.LibPcap;
using Spectre.Console;
using TinyIDS.Models;
using TinyIDS.Utils;
namespace TinyIDS.Services
{
    public enum CaptureMode
    {
        Csv,
        Cap,
        Flow
    }
    public class PacketCaptureService
    {
        private ICaptureDevice _device;
        private static CaptureFileWriterDevice captureFileWriter;
        private static StreamWriter csvWriter;
        private static CsvWriter csv;
        private static Verbosity _verbosity;
        private CaptureMode _captureMode;
        private static PacketProcessor _packetProcessor;
        private static Logger _logger;
        public PacketCaptureService(Verbosity verbosity)
        {
            _logger = new Logger(verbosity);
            _packetProcessor = new PacketProcessor(_logger, );
        }
        public void ListDevices()
        {
            var devices = CaptureDeviceList.Instance;
            if (devices.Count == 0)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            var table = new Table();
            table.AddColumn();","table.AddColumn();
            foreach (var device in devices)
            {","table.AddRow(device.Name, device.Description);
            }
            AnsiConsole.Write(table);
        }
        public void PrintSharpPcapVersion()
        {
            var ver = Pcap.SharpPcapVersion;
            Log($, Verbosity.Basic);
        }
        private LibPcapLiveDeviceList GetDevices()
        {
            return LibPcapLiveDeviceList.Instance;
        }
        private void DisplayAvailableDevices(LibPcapLiveDeviceList devices)
        {
            var table = new Table();
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            for (int i = 0; i < devices.Count; i++)
            {
                var dev = devices[i];
                table.AddRow(i.ToString(), dev.Name, dev.Description);
            }
            AnsiConsole.Write(table);
        }
        private int GetDeviceIndexFromUser()
        {
            return AnsiConsole.Prompt(
                new TextPrompt<int>()
                    .PromptStyle()
                    .Validate(index =>
                        index >= 0 ? ValidationResult.Success() : ValidationResult.Error()));
        }
        private string GetOutputFileNameFromUser(string fileType)
        {
            return AnsiConsole.Ask<string>($);
        }
        public void StartCapture(CaptureMode captureMode)
        {
            _captureMode = captureMode;
            Log(, Verbosity.Basic);
            PrintSharpPcapVersion();
            var devices = GetDevices();
            if (devices.Count < 1)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            DisplayAvailableDevices(devices);
            int deviceIndex = GetDeviceIndexFromUser();
            string capFile = null;
            string csvFile = null;
            if (_captureMode == CaptureMode.Cap)
            {
                capFile = GetOutputFileNameFromUser();
            }
            if (_captureMode == CaptureMode.Csv)
            {
                csvFile = GetOutputFileNameFromUser();
            }
            CapturePackets(devices[deviceIndex], capFile, csvFile);
        }
        private void CapturePackets(ICaptureDevice device, string capFile, string csvFile)
        {
            device.OnPacketArrival += new PacketArrivalEventHandler(device_OnPacketArrivalCapture);
            device.Open(DeviceModes.Promiscuous | DeviceModes.DataTransferUdp | DeviceModes.NoCaptureLocal, read_timeout: 1000);
            Log($, Verbosity.Basic);
            if (_captureMode == CaptureMode.Cap && capFile != null)
            {
                captureFileWriter = new CaptureFileWriterDevice(capFile);
                captureFileWriter.Open(device);
            }
            if (_captureMode == CaptureMode.Csv && csvFile != null)
            {
                csvWriter = new StreamWriter(csvFile);
                csv = new CsvWriter(csvWriter, CultureInfo.InvariantCulture);
                csv.WriteHeader<PacketRecord>();
                csv.NextRecord();
            }
            device.StartCapture();
            if (_verbosity >= Verbosity.Detailed)
            {
                Console.WriteLine();
                AnsiConsole.Write(
                 new Rule()
                     .RuleStyle()
                     .Centered());
                Console.WriteLine();
            }
            Console.ReadLine();
            device.StopCapture();
            if (_captureMode == CaptureMode.Cap && captureFileWriter != null)
            {
                captureFileWriter.Close();
            }
            if (_captureMode == CaptureMode.Csv && csvWriter != null)
            {
                csvWriter.Close();
            }
            Log(, Verbosity.Basic);
            LogDeviceStatistics(device.Statistics.ToString());
        }
        private static void device_OnPacketArrivalCapture(object sender, PacketCapture e)
        {
            var rawPacket = e.GetPacket();
            _packetProcessor.ProcessPacket(rawPacket);
            if (captureFileWriter != null)
            {
                captureFileWriter.Write(rawPacket);
            }
            if (rawPacket.LinkLayerType == PacketDotNet.LinkLayers.Ethernet)
            {
                var packet = PacketDotNet.Packet.ParsePacket(rawPacket.LinkLayerType, rawPacket.Data);
                var ethernetPacket = packet.Extract<EthernetPacket>();
                if (ethernetPacket != null)
                {
                    var ipPacket = ethernetPacket.Extract<IPPacket>();
                    var tcpPacket = ipPacket?.Extract<TcpPacket>();
                    var udpPacket = ipPacket?.Extract<UdpPacket>();
                    LogPacketInfo(packet, Verbosity.Detailed);
                    var record = FeatureExtractor.ExtractFeatures(rawPacket);
                    if (csv != null)
                    {
                        csv.WriteRecord(record);
                        csv.NextRecord();
                        csv.Flush();
                    }
                }
            }
        }
        private void Log(string message, Verbosity requiredVerbosity)
        {
            _logger.Log(message, requiredVerbosity);
        }
        private void LogDeviceStatistics(string statistics)
        {
            _logger.LogDeviceStatistics(statistics);
        }
        public static void LogPacketInfo(PacketDotNet.Packet packet, Verbosity requiredVerbosity)
        {
            _logger.LogPacketInfo(packet, requiredVerbosity);
        }
    }
}",ClassificationPacketCaptureService.cs
"using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using CsvHelper;
using PacketDotNet;
using PcapDotNet.Packets;
using SharpPcap;
using SharpPcap.LibPcap;
using Spectre.Console;
using TinyIDS.Models;
using TinyIDS.Utils;
namespace TinyIDS.Services
{
    public enum CaptureMode
    {
        Csv,
        Cap,
        Flow
    }
    public class PacketCaptureService
    {
        private ICaptureDevice _device;
        private static CaptureFileWriterDevice captureFileWriter;
        private static StreamWriter csvWriter;
        private static CsvWriter csv;
        private static Verbosity _verbosity;
        private CaptureMode _captureMode;
        private static PacketProcessor _packetProcessor;
        private static Logger _logger;
        public PacketCaptureService(Verbosity verbosity)
        {
            _logger = new Logger(verbosity);
            _packetProcessor = new PacketProcessor(_logger, );
        }
        public void ListDevices()
        {
            var devices = CaptureDeviceList.Instance;
            if (devices.Count == 0)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            var table = new Table();
            table.AddColumn();
            table.AddColumn();
            foreach (var device in devices)
            {
                table.AddRow(device.Name, device.Description);
            }
            AnsiConsole.Write(table);
        }
        public void PrintSharpPcapVersion()
        {
            var ver = Pcap.SharpPcapVersion;
            Log($, Verbosity.Basic);
        }
        private LibPcapLiveDeviceList GetDevices()
        {
            return LibPcapLiveDeviceList.Instance;
        }
        private void DisplayAvailableDevices(LibPcapLiveDeviceList devices)
        {
            var table = new Table();
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            table.AddColumn(new TableColumn().Centered());
            for (int i = 0; i < devices.Count; i++)
            {
                var dev = devices[i];
                table.AddRow(i.ToString(), dev.Name, dev.Description);
            }
            AnsiConsole.Write(table);
        }
        private int GetDeviceIndexFromUser()
        {
            return AnsiConsole.Prompt(
                new TextPrompt<int>()
                    .PromptStyle()
                    .Validate(index =>
                        index >= 0 ? ValidationResult.Success() : ValidationResult.Error()));
        }
        private string GetOutputFileNameFromUser(string fileType)
        {
            return AnsiConsole.Ask<string>($);
        }
        public void StartCapture(CaptureMode captureMode)
        {
            _captureMode = captureMode;
            Log(, Verbosity.Basic);
            PrintSharpPcapVersion();
            var devices = GetDevices();
            if (devices.Count < 1)
            {
                AnsiConsole.MarkupLine();
                return;
            }
            DisplayAvailableDevices(devices);
            int deviceIndex = GetDeviceIndexFromUser();
            string capFile = null;
            string csvFile = null;
            if (_captureMode == CaptureMode.Cap)
            {
                capFile = GetOutputFileNameFromUser();
            }
            if (_captureMode == CaptureMode.Csv)
            {
                csvFile = GetOutputFileNameFromUser();
            }
            CapturePackets(devices[deviceIndex], capFile, csvFile);
        }
        private void CapturePackets(ICaptureDevice device, string capFile, string csvFile)
        {
            device.OnPacketArrival += new PacketArrivalEventHandler(device_OnPacketArrivalCapture);
            device.Open(DeviceModes.Promiscuous | DeviceModes.DataTransferUdp | DeviceModes.NoCaptureLocal, read_timeout: 1000);
            Log($, Verbosity.Basic);
            if (_captureMode == CaptureMode.Cap && capFile != null)
            {
                captureFileWriter = new CaptureFileWriterDevice(capFile);
                captureFileWriter.Open(device);
            }
            if (_captureMode == CaptureMode.Csv && csvFile != null)
            {
                csvWriter = new StreamWriter(csvFile);
                csv = new CsvWriter(csvWriter, CultureInfo.InvariantCulture);
                csv.WriteHeader<PacketRecord>();
                csv.NextRecord();
            }
            device.StartCapture();
            if (_verbosity >= Verbosity.Detailed)
            {
                Console.WriteLine();
                AnsiConsole.Write(
                 new Rule()
                     .RuleStyle()
                     .Centered());
                Console.WriteLine();
            }
            Console.ReadLine();
            device.StopCapture();
            if (_captureMode == CaptureMode.Cap && captureFileWriter != null)
            {
                captureFileWriter.Close();
            }
            if (_captureMode == CaptureMode.Csv && csvWriter != null)
            {
                csvWriter.Close();
            }
            Log(, Verbosity.Basic);
            LogDeviceStatistics(device.Statistics.ToString());
        }
        private static void device_OnPacketArrivalCapture(object sender, PacketCapture e)
        {
            var rawPacket = e.GetPacket();
            _packetProcessor.ProcessPacket(rawPacket);
            if (captureFileWriter != null)
            {
                captureFileWriter.Write(rawPacket);
            }
            if (rawPacket.LinkLayerType == PacketDotNet.LinkLayers.Ethernet)
            {
                var packet = PacketDotNet.Packet.ParsePacket(rawPacket.LinkLayerType, rawPacket.Data);
                var ethernetPacket = packet.Extract<EthernetPacket>();
                if (ethernetPacket != null)
                {
                    var ipPacket = ethernetPacket.Extract<IPPacket>();
                    var tcpPacket = ipPacket?.Extract<TcpPacket>();
                    var udpPacket = ipPacket?.Extract<UdpPacket>();
                    LogPacketInfo(packet, Verbosity.Detailed);
                    var record = FeatureExtractor.ExtractFeatures(rawPacket);
                    if (csv != null)
                    {
                        csv.WriteRecord(record);
                        csv.NextRecord();
                        csv.Flush();
                    }","}
            }
        }","private void Log(string message, Verbosity requiredVerbosity)
        {
            _logger.Log(message, requiredVerbosity);
        }
        private void LogDeviceStatistics(string statistics)
        {
            _logger.LogDeviceStatistics(statistics);
        }
        public static void LogPacketInfo(PacketDotNet.Packet packet, Verbosity requiredVerbosity)
        {
            _logger.LogPacketInfo(packet, requiredVerbosity);
        }
    }
}",ClassificationPacketCaptureService.cs
"using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using Spectre.Console;
namespace Implementation
{
    public class PasswordGenerator
    {
        private static readonly string LowercaseChars = ;
        private static readonly string UppercaseChars = ;
        private static readonly string NumberChars = ;
        private static readonly string SpecialChars = ;
        public static string GeneratePassword(bool useLowercase, bool useUppercase, bool useNumbers, bool useSpecial, int length)
        {
            if (length <= 0 || (!useLowercase && !useUppercase && !useNumbers && !useSpecial))
            {
                throw new ArgumentException();
            }
            string charPool = (useLowercase ? LowercaseChars : ) +
                              (useUppercase ? UppercaseChars : ) +
                              (useNumbers ? NumberChars : ) +
                              (useSpecial ? SpecialChars : );
            var bytes = new byte[length];
            RandomNumberGenerator.Fill(bytes);
            return new string(bytes.Select(b => charPool[b % charPool.Length]).ToArray());
        }
    }
    public class EntropyCalculator
    {
        public static double CalculateStringEntropy(string input)
        {
            if (string.IsNullOrEmpty(input))
                return 0.0; 
            Dictionary<char, int> charCounts = new Dictionary<char, int>();
            foreach (char c in input)
            {
                if (charCounts.ContainsKey(c))
                    charCounts[c]++;
                else
                    charCounts[c] = 1;
            }
            double entropy = 0.0;
            int totalChars = input.Length;
            foreach (var count in charCounts.Values)
            {
                double probability = (double)count / totalChars;
                entropy += probability * Math.Log2(probability);
            }
            return -entropy;
        }
    }
    public class Encrypt
    {
        public static void EncryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16]; 
                RandomNumberGenerator.Fill(salt);
                int iterations = 100000;
                Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                aes.Key = pdb.GetBytes(32);
                aes.IV = pdb.GetBytes(16);
                using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                {
                    fsOutput.Write(salt, 0, salt.Length);
                    using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                    using (CryptoStream cs = new CryptoStream(fsOutput, aes.CreateEncryptor(), CryptoStreamMode.Write))
                    {
                        int data;
                        while ((data = fsInput.ReadByte()) != -1)
                        {
                            cs.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Decrypt
    {
        public static void DecryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16];
                using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                {
                    fsInput.Read(salt, 0, salt.Length);
                    int iterations = 100000;
                    Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                    aes.Key = pdb.GetBytes(32);
                    aes.IV = pdb.GetBytes(16);
                    using (CryptoStream cs = new CryptoStream(fsInput, aes.CreateDecryptor(), CryptoStreamMode.Read))
                    using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                    {
                        int data;
                        while ((data = cs.ReadByte()) != -1)
                        {
                            fsOutput.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Hashing
    {
        public static string HashingFileWithSHA256(string filePath)
        {
            using SHA256 sha256 = SHA256.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha256.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithSHA1(string filePath)
        {
            using SHA1 sha1 = SHA1.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha1.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithMD5(string filePath)
        {
            using MD5 md5 = MD5.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(md5.ComputeHash(stream)).Replace(, ).ToLower();
        }
    }
    public class ImageSteganography
    {
        public enum State
        {
            Hiding,
            Filling_With_Zeros
        };
        public static void embedText(string text, string inputImagePath)
        {
            string originalFilePath = inputImagePath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            Bitmap bmp = new Bitmap(inputImagePath);
            State state = State.Hiding;
            int charIndex = 0;
            int charValue = 0;
            long pixelElementIndex = 0;
            int zeros = 0;
            int R = 0, G = 0, B = 0;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                { 
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    R = pixel.R - pixel.R % 2;
                    G = pixel.G - pixel.G % 2;
                    B = pixel.B - pixel.B % 2;
                    for (int n = 0; n < 3; n++)
                    {
                        if (pixelElementIndex % 8 == 0)
                        { 
                            if (state == State.Filling_With_Zeros && zeros == 8)
                            {
                                if ((pixelElementIndex - 1) % 3 < 2)
                                {
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                bmp.Save(newFilePath, ImageFormat.Png);
                            }
                            if (charIndex >= text.Length)
                            {
                                state = State.Filling_With_Zeros;
                            }","else
                            {
                                charValue = text[charIndex++];","}
                        }
                        switch (pixelElementIndex % 3)
                        {
                            case 0:
                                {
                                    if (state == State.Hiding)
                                    {
                                        R += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 1:
                                {
                                    if (state == State.Hiding)
                                    {
                                        G += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 2:
                                {
                                    if (state == State.Hiding)
                                    {
                                        B += charValue % 2;
                                        charValue /= 2;
                                    }
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                break;
                        }
                        pixelElementIndex++;
                        if (state == State.Filling_With_Zeros)
                        {
                            zeros++;
                        }
                    }
                }
            }
            bmp.Save(newFilePath, ImageFormat.Png);
        }
        public static string extractText(Bitmap bmp)
        {
            int colorUnitIndex = 0;
            int charValue = 0;
            string extractedText = String.Empty;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                {
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    for (int n = 0; n < 3; n++)
                    {
                        switch (colorUnitIndex % 3)
                        {
                            case 0:
                                {
                                    charValue = charValue * 2 + pixel.R % 2;
                                }
                                break;
                            case 1:
                                {
                                    charValue = charValue * 2 + pixel.G % 2;
                                }
                                break;
                            case 2:
                                {
                                    charValue = charValue * 2 + pixel.B % 2;
                                }
                                break;
                        }
                        colorUnitIndex++;
                        if (colorUnitIndex % 8 == 0)
                        {
                            charValue = reverseBits(charValue);
                            if (charValue == 0)
                            {
                                return extractedText;
                            }
                            char c = (char)charValue;
                            extractedText += c.ToString();
                        }
                    }
                }
            }
            return extractedText;
        }
        public static int reverseBits(int n)
        {
            int result = 0;
            for (int i = 0; i < 8; i++)
            {
                result = result * 2 + n % 2;
                n /= 2;
            }
            return result;
        }
    }
    class AudioSteganography
    {
        const int HEADER_SIZE = 4; 
        const int BYTE_INTERVAL = 16; 
        public static void HideMessageInAudio(string inputAudioPath, string message)
        {
            byte[] messageBytes = Encoding.ASCII.GetBytes(message);
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes.Length >> (i * 8 + j)) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit); 
                    audioIndex += BYTE_INTERVAL;
                }
            }
            for (int i = 0; i < messageBytes.Length; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes[i] >> j) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            string originalFilePath = inputAudioPath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            File.WriteAllBytes(newFilePath, audioBytes);
        }
        public static string ExtractMessageFromAudio(string inputAudioPath)
        {
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            int messageLength = 0;
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageLength |= (bit << (i * 8 + j));
                    audioIndex += BYTE_INTERVAL;
                }
            }
            byte[] messageBytes = new byte[messageLength];
            for (int i = 0; i < messageLength; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageBytes[i] |= (byte)(bit << j);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            return Encoding.ASCII.GetString(messageBytes);
        }
    }
    public class DigitalSignature
    {
        static RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(2048);
        static RSAParameters publicKey;
        static RSAParameters privateKey;
        public static void GenerateKeys(string publicKeyPath)
        {
            publicKey = rsa.ExportParameters(false);
            privateKey = rsa.ExportParameters(true);
            var publicKeyXml = rsa.ToXmlString(false);
            var privateKeyXml = rsa.ToXmlString(true);
            var publicKeyFullPath = Path.Combine(publicKeyPath, );
            var privateKeyFullPath = Path.Combine(publicKeyPath, );
            File.WriteAllText(publicKeyFullPath, publicKeyXml);
            File.WriteAllText(privateKeyFullPath, privateKeyXml);
            AnsiConsole.MarkupLine($);
        }
        public static void UploadKeys(string privateKeyPath)
        {
            var privateKeyXml = File.ReadAllText(privateKeyPath);
            rsa.FromXmlString(privateKeyXml);
            privateKey = rsa.ExportParameters(true);
        }
        public static void SignDocument(string documentPath)
        {
            if (privateKey.D == null)
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            if (!File.Exists(documentPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = SignData(data, privateKey);
            var signaturePath = documentPath + ;
            File.WriteAllBytes(signaturePath, signature);
            AnsiConsole.MarkupLine($);
        }
        public static void VerifyDocumentSignature(string documentPath, string signaturePath, string publicKeyPath)
        {
            if (!File.Exists(publicKeyPath))
            {
                Console.WriteLine();
                return;
            }
            var publicKeyXml = File.ReadAllText(publicKeyPath);
            rsa.FromXmlString(publicKeyXml);
            if (!File.Exists(signaturePath))
            {
                Console.WriteLine();
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = File.ReadAllBytes(signaturePath);
            var isVerified = VerifyData(data, signature);
            AnsiConsole.MarkupLine($);
        }
        public static byte[] SignData(byte[] data, RSAParameters privateKey)
        {
            rsa.ImportParameters(privateKey);
            var signedData = rsa.SignData(data, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            return signedData;
        }
        static bool VerifyData(byte[] data, byte[] signature)
        {
            return rsa.VerifyData(data, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
        }
    }
    public class AesRsaEncryption
    {
        public static void EncryptFile(string inputFilePath, string outputFilePath, RSAParameters publicKey)
        {
            using (Aes aes = Aes.Create())
            {
                aes.GenerateKey();
                aes.GenerateIV();
                using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    byte[] buffer = new byte[1024];
                    int bytesRead;
                    while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                    {
                        cryptoStream.Write(buffer, 0, bytesRead);
                    }
                }
                using (RSA rsa = new RSACryptoServiceProvider())
                {
                    rsa.ImportParameters(publicKey);
                    byte[] encryptedKey = rsa.Encrypt(aes.Key, RSAEncryptionPadding.Pkcs1);
                    File.WriteAllBytes(outputFilePath + , encryptedKey.Concat(aes.IV).ToArray());
                }
            }
        }
        public static void DecryptFile(string inputFilePath, string keyFilePath, string outputFilePath, RSAParameters privateKey)
        {
            byte[] encryptedData = File.ReadAllBytes(keyFilePath);
            byte[] encryptedKey = encryptedData.Take(encryptedData.Length - 16).ToArray();
            byte[] iv = encryptedData.Skip(encryptedData.Length - 16).ToArray();
            using (RSA rsa = new RSACryptoServiceProvider())
            {
                rsa.ImportParameters(privateKey);
                byte[] decryptedKey = rsa.Decrypt(encryptedKey, RSAEncryptionPadding.Pkcs1);
                using (Aes aes = Aes.Create())
                {
                    aes.Key = decryptedKey;
                    aes.IV = iv;
                    using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                    using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                    using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        byte[] buffer = new byte[1024];
                        int bytesRead;
                        while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                        {
                            cryptoStream.Write(buffer, 0, bytesRead);
                        }
                    }
                }
            }
        }
    }
}",CryptoAlgorithmsImplementations.cs
using System;,"using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;","using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using Spectre.Console;
namespace Implementation
{
    public class PasswordGenerator
    {
        private static readonly string LowercaseChars = ;
        private static readonly string UppercaseChars = ;
        private static readonly string NumberChars = ;
        private static readonly string SpecialChars = ;
        public static string GeneratePassword(bool useLowercase, bool useUppercase, bool useNumbers, bool useSpecial, int length)
        {
            if (length <= 0 || (!useLowercase && !useUppercase && !useNumbers && !useSpecial))
            {
                throw new ArgumentException();
            }
            string charPool = (useLowercase ? LowercaseChars : ) +
                              (useUppercase ? UppercaseChars : ) +
                              (useNumbers ? NumberChars : ) +
                              (useSpecial ? SpecialChars : );
            var bytes = new byte[length];
            RandomNumberGenerator.Fill(bytes);
            return new string(bytes.Select(b => charPool[b % charPool.Length]).ToArray());
        }
    }
    public class EntropyCalculator
    {
        public static double CalculateStringEntropy(string input)
        {
            if (string.IsNullOrEmpty(input))
                return 0.0; 
            Dictionary<char, int> charCounts = new Dictionary<char, int>();
            foreach (char c in input)
            {
                if (charCounts.ContainsKey(c))
                    charCounts[c]++;
                else
                    charCounts[c] = 1;
            }
            double entropy = 0.0;
            int totalChars = input.Length;
            foreach (var count in charCounts.Values)
            {
                double probability = (double)count / totalChars;
                entropy += probability * Math.Log2(probability);
            }
            return -entropy;
        }
    }
    public class Encrypt
    {
        public static void EncryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16]; 
                RandomNumberGenerator.Fill(salt);
                int iterations = 100000;
                Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                aes.Key = pdb.GetBytes(32);
                aes.IV = pdb.GetBytes(16);
                using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                {
                    fsOutput.Write(salt, 0, salt.Length);
                    using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                    using (CryptoStream cs = new CryptoStream(fsOutput, aes.CreateEncryptor(), CryptoStreamMode.Write))
                    {
                        int data;
                        while ((data = fsInput.ReadByte()) != -1)
                        {
                            cs.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Decrypt
    {
        public static void DecryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16];
                using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                {
                    fsInput.Read(salt, 0, salt.Length);
                    int iterations = 100000;
                    Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                    aes.Key = pdb.GetBytes(32);
                    aes.IV = pdb.GetBytes(16);
                    using (CryptoStream cs = new CryptoStream(fsInput, aes.CreateDecryptor(), CryptoStreamMode.Read))
                    using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                    {
                        int data;
                        while ((data = cs.ReadByte()) != -1)
                        {
                            fsOutput.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Hashing
    {
        public static string HashingFileWithSHA256(string filePath)
        {
            using SHA256 sha256 = SHA256.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha256.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithSHA1(string filePath)
        {
            using SHA1 sha1 = SHA1.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha1.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithMD5(string filePath)
        {
            using MD5 md5 = MD5.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(md5.ComputeHash(stream)).Replace(, ).ToLower();
        }
    }
    public class ImageSteganography
    {
        public enum State
        {
            Hiding,
            Filling_With_Zeros
        };
        public static void embedText(string text, string inputImagePath)
        {
            string originalFilePath = inputImagePath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            Bitmap bmp = new Bitmap(inputImagePath);
            State state = State.Hiding;
            int charIndex = 0;
            int charValue = 0;
            long pixelElementIndex = 0;
            int zeros = 0;
            int R = 0, G = 0, B = 0;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                { 
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    R = pixel.R - pixel.R % 2;
                    G = pixel.G - pixel.G % 2;
                    B = pixel.B - pixel.B % 2;
                    for (int n = 0; n < 3; n++)
                    {
                        if (pixelElementIndex % 8 == 0)
                        { 
                            if (state == State.Filling_With_Zeros && zeros == 8)
                            {
                                if ((pixelElementIndex - 1) % 3 < 2)
                                {
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                bmp.Save(newFilePath, ImageFormat.Png);
                            }
                            if (charIndex >= text.Length)
                            {
                                state = State.Filling_With_Zeros;
                            }
                            else
                            {
                                charValue = text[charIndex++];
                            }
                        }
                        switch (pixelElementIndex % 3)
                        {
                            case 0:
                                {
                                    if (state == State.Hiding)
                                    {
                                        R += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 1:
                                {
                                    if (state == State.Hiding)
                                    {
                                        G += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 2:
                                {
                                    if (state == State.Hiding)
                                    {
                                        B += charValue % 2;
                                        charValue /= 2;
                                    }
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                break;
                        }
                        pixelElementIndex++;
                        if (state == State.Filling_With_Zeros)
                        {
                            zeros++;
                        }
                    }
                }
            }
            bmp.Save(newFilePath, ImageFormat.Png);
        }
        public static string extractText(Bitmap bmp)
        {
            int colorUnitIndex = 0;
            int charValue = 0;
            string extractedText = String.Empty;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                {
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    for (int n = 0; n < 3; n++)
                    {
                        switch (colorUnitIndex % 3)
                        {
                            case 0:
                                {
                                    charValue = charValue * 2 + pixel.R % 2;
                                }
                                break;
                            case 1:
                                {
                                    charValue = charValue * 2 + pixel.G % 2;
                                }
                                break;
                            case 2:
                                {
                                    charValue = charValue * 2 + pixel.B % 2;
                                }
                                break;
                        }
                        colorUnitIndex++;
                        if (colorUnitIndex % 8 == 0)
                        {
                            charValue = reverseBits(charValue);
                            if (charValue == 0)
                            {
                                return extractedText;
                            }
                            char c = (char)charValue;
                            extractedText += c.ToString();
                        }
                    }
                }
            }
            return extractedText;
        }
        public static int reverseBits(int n)
        {
            int result = 0;
            for (int i = 0; i < 8; i++)
            {
                result = result * 2 + n % 2;
                n /= 2;
            }
            return result;
        }
    }
    class AudioSteganography
    {
        const int HEADER_SIZE = 4; 
        const int BYTE_INTERVAL = 16; 
        public static void HideMessageInAudio(string inputAudioPath, string message)
        {
            byte[] messageBytes = Encoding.ASCII.GetBytes(message);
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes.Length >> (i * 8 + j)) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit); 
                    audioIndex += BYTE_INTERVAL;
                }
            }
            for (int i = 0; i < messageBytes.Length; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes[i] >> j) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            string originalFilePath = inputAudioPath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            File.WriteAllBytes(newFilePath, audioBytes);
        }
        public static string ExtractMessageFromAudio(string inputAudioPath)
        {
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            int messageLength = 0;
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageLength |= (bit << (i * 8 + j));
                    audioIndex += BYTE_INTERVAL;
                }
            }
            byte[] messageBytes = new byte[messageLength];
            for (int i = 0; i < messageLength; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageBytes[i] |= (byte)(bit << j);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            return Encoding.ASCII.GetString(messageBytes);
        }
    }
    public class DigitalSignature
    {
        static RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(2048);
        static RSAParameters publicKey;
        static RSAParameters privateKey;
        public static void GenerateKeys(string publicKeyPath)
        {
            publicKey = rsa.ExportParameters(false);
            privateKey = rsa.ExportParameters(true);
            var publicKeyXml = rsa.ToXmlString(false);
            var privateKeyXml = rsa.ToXmlString(true);
            var publicKeyFullPath = Path.Combine(publicKeyPath, );
            var privateKeyFullPath = Path.Combine(publicKeyPath, );
            File.WriteAllText(publicKeyFullPath, publicKeyXml);
            File.WriteAllText(privateKeyFullPath, privateKeyXml);
            AnsiConsole.MarkupLine($);
        }
        public static void UploadKeys(string privateKeyPath)
        {
            var privateKeyXml = File.ReadAllText(privateKeyPath);
            rsa.FromXmlString(privateKeyXml);
            privateKey = rsa.ExportParameters(true);
        }
        public static void SignDocument(string documentPath)
        {
            if (privateKey.D == null)
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            if (!File.Exists(documentPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = SignData(data, privateKey);
            var signaturePath = documentPath + ;
            File.WriteAllBytes(signaturePath, signature);
            AnsiConsole.MarkupLine($);
        }
        public static void VerifyDocumentSignature(string documentPath, string signaturePath, string publicKeyPath)
        {
            if (!File.Exists(publicKeyPath))
            {
                Console.WriteLine();
                return;
            }
            var publicKeyXml = File.ReadAllText(publicKeyPath);
            rsa.FromXmlString(publicKeyXml);
            if (!File.Exists(signaturePath))
            {
                Console.WriteLine();
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = File.ReadAllBytes(signaturePath);
            var isVerified = VerifyData(data, signature);
            AnsiConsole.MarkupLine($);
        }
        public static byte[] SignData(byte[] data, RSAParameters privateKey)
        {
            rsa.ImportParameters(privateKey);
            var signedData = rsa.SignData(data, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            return signedData;
        }
        static bool VerifyData(byte[] data, byte[] signature)
        {
            return rsa.VerifyData(data, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
        }
    }
    public class AesRsaEncryption
    {
        public static void EncryptFile(string inputFilePath, string outputFilePath, RSAParameters publicKey)
        {
            using (Aes aes = Aes.Create())
            {
                aes.GenerateKey();
                aes.GenerateIV();
                using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    byte[] buffer = new byte[1024];
                    int bytesRead;
                    while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                    {
                        cryptoStream.Write(buffer, 0, bytesRead);
                    }
                }
                using (RSA rsa = new RSACryptoServiceProvider())
                {
                    rsa.ImportParameters(publicKey);
                    byte[] encryptedKey = rsa.Encrypt(aes.Key, RSAEncryptionPadding.Pkcs1);
                    File.WriteAllBytes(outputFilePath + , encryptedKey.Concat(aes.IV).ToArray());
                }
            }
        }
        public static void DecryptFile(string inputFilePath, string keyFilePath, string outputFilePath, RSAParameters privateKey)
        {
            byte[] encryptedData = File.ReadAllBytes(keyFilePath);
            byte[] encryptedKey = encryptedData.Take(encryptedData.Length - 16).ToArray();
            byte[] iv = encryptedData.Skip(encryptedData.Length - 16).ToArray();
            using (RSA rsa = new RSACryptoServiceProvider())
            {
                rsa.ImportParameters(privateKey);
                byte[] decryptedKey = rsa.Decrypt(encryptedKey, RSAEncryptionPadding.Pkcs1);
                using (Aes aes = Aes.Create())
                {
                    aes.Key = decryptedKey;
                    aes.IV = iv;
                    using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                    using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                    using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        byte[] buffer = new byte[1024];
                        int bytesRead;
                        while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                        {
                            cryptoStream.Write(buffer, 0, bytesRead);
                        }
                    }
                }
            }
        }
    }
}",CryptoAlgorithmsImplementations.cs
"using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using Spectre.Console;
namespace Implementation
{
    public class PasswordGenerator
    {
        private static readonly string LowercaseChars = ;
        private static readonly string UppercaseChars = ;
        private static readonly string NumberChars = ;
        private static readonly string SpecialChars = ;
        public static string GeneratePassword(bool useLowercase, bool useUppercase, bool useNumbers, bool useSpecial, int length)
        {
            if (length <= 0 || (!useLowercase && !useUppercase && !useNumbers && !useSpecial))
            {
                throw new ArgumentException();
            }
            string charPool = (useLowercase ? LowercaseChars : ) +
                              (useUppercase ? UppercaseChars : ) +
                              (useNumbers ? NumberChars : ) +
                              (useSpecial ? SpecialChars : );
            var bytes = new byte[length];
            RandomNumberGenerator.Fill(bytes);
            return new string(bytes.Select(b => charPool[b % charPool.Length]).ToArray());
        }
    }
    public class EntropyCalculator
    {
        public static double CalculateStringEntropy(string input)
        {
            if (string.IsNullOrEmpty(input))
                return 0.0; 
            Dictionary<char, int> charCounts = new Dictionary<char, int>();
            foreach (char c in input)
            {
                if (charCounts.ContainsKey(c))
                    charCounts[c]++;
                else
                    charCounts[c] = 1;
            }
            double entropy = 0.0;
            int totalChars = input.Length;
            foreach (var count in charCounts.Values)
            {
                double probability = (double)count / totalChars;
                entropy += probability * Math.Log2(probability);
            }
            return -entropy;
        }
    }
    public class Encrypt
    {
        public static void EncryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16]; 
                RandomNumberGenerator.Fill(salt);
                int iterations = 100000;
                Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                aes.Key = pdb.GetBytes(32);
                aes.IV = pdb.GetBytes(16);
                using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                {
                    fsOutput.Write(salt, 0, salt.Length);
                    using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                    using (CryptoStream cs = new CryptoStream(fsOutput, aes.CreateEncryptor(), CryptoStreamMode.Write))
                    {
                        int data;
                        while ((data = fsInput.ReadByte()) != -1)
                        {
                            cs.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Decrypt
    {
        public static void DecryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16];
                using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                {
                    fsInput.Read(salt, 0, salt.Length);
                    int iterations = 100000;
                    Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                    aes.Key = pdb.GetBytes(32);
                    aes.IV = pdb.GetBytes(16);
                    using (CryptoStream cs = new CryptoStream(fsInput, aes.CreateDecryptor(), CryptoStreamMode.Read))
                    using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                    {
                        int data;
                        while ((data = cs.ReadByte()) != -1)
                        {
                            fsOutput.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Hashing
    {
        public static string HashingFileWithSHA256(string filePath)
        {
            using SHA256 sha256 = SHA256.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha256.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithSHA1(string filePath)
        {
            using SHA1 sha1 = SHA1.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha1.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithMD5(string filePath)
        {
            using MD5 md5 = MD5.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(md5.ComputeHash(stream)).Replace(, ).ToLower();
        }
    }
    public class ImageSteganography
    {
        public enum State
        {
            Hiding,
            Filling_With_Zeros
        };
        public static void embedText(string text, string inputImagePath)
        {
            string originalFilePath = inputImagePath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            Bitmap bmp = new Bitmap(inputImagePath);
            State state = State.Hiding;
            int charIndex = 0;
            int charValue = 0;
            long pixelElementIndex = 0;
            int zeros = 0;
            int R = 0, G = 0, B = 0;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                { 
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    R = pixel.R - pixel.R % 2;
                    G = pixel.G - pixel.G % 2;
                    B = pixel.B - pixel.B % 2;
                    for (int n = 0; n < 3; n++)
                    {
                        if (pixelElementIndex % 8 == 0)
                        { 
                            if (state == State.Filling_With_Zeros && zeros == 8)
                            {
                                if ((pixelElementIndex - 1) % 3 < 2)
                                {
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                bmp.Save(newFilePath, ImageFormat.Png);
                            }
                            if (charIndex >= text.Length)
                            {
                                state = State.Filling_With_Zeros;
                            }
                            else
                            {
                                charValue = text[charIndex++];
                            }
                        }
                        switch (pixelElementIndex % 3)
                        {
                            case 0:
                                {
                                    if (state == State.Hiding)
                                    {
                                        R += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 1:
                                {
                                    if (state == State.Hiding)
                                    {
                                        G += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 2:
                                {
                                    if (state == State.Hiding)
                                    {
                                        B += charValue % 2;
                                        charValue /= 2;
                                    }
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                break;
                        }
                        pixelElementIndex++;
                        if (state == State.Filling_With_Zeros)
                        {
                            zeros++;
                        }
                    }
                }
            }
            bmp.Save(newFilePath, ImageFormat.Png);
        }
        public static string extractText(Bitmap bmp)
        {
            int colorUnitIndex = 0;
            int charValue = 0;
            string extractedText = String.Empty;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                {
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    for (int n = 0; n < 3; n++)
                    {
                        switch (colorUnitIndex % 3)
                        {
                            case 0:
                                {
                                    charValue = charValue * 2 + pixel.R % 2;
                                }
                                break;
                            case 1:
                                {
                                    charValue = charValue * 2 + pixel.G % 2;
                                }
                                break;
                            case 2:
                                {
                                    charValue = charValue * 2 + pixel.B % 2;
                                }
                                break;
                        }
                        colorUnitIndex++;
                        if (colorUnitIndex % 8 == 0)
                        {
                            charValue = reverseBits(charValue);
                            if (charValue == 0)
                            {
                                return extractedText;
                            }
                            char c = (char)charValue;
                            extractedText += c.ToString();
                        }","}
                }
            }","return extractedText;
        }
        public static int reverseBits(int n)
        {
            int result = 0;
            for (int i = 0; i < 8; i++)
            {
                result = result * 2 + n % 2;
                n /= 2;
            }
            return result;
        }
    }
    class AudioSteganography
    {
        const int HEADER_SIZE = 4; 
        const int BYTE_INTERVAL = 16; 
        public static void HideMessageInAudio(string inputAudioPath, string message)
        {
            byte[] messageBytes = Encoding.ASCII.GetBytes(message);
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes.Length >> (i * 8 + j)) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit); 
                    audioIndex += BYTE_INTERVAL;
                }
            }
            for (int i = 0; i < messageBytes.Length; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes[i] >> j) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            string originalFilePath = inputAudioPath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            File.WriteAllBytes(newFilePath, audioBytes);
        }
        public static string ExtractMessageFromAudio(string inputAudioPath)
        {
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            int messageLength = 0;
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageLength |= (bit << (i * 8 + j));
                    audioIndex += BYTE_INTERVAL;
                }
            }
            byte[] messageBytes = new byte[messageLength];
            for (int i = 0; i < messageLength; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageBytes[i] |= (byte)(bit << j);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            return Encoding.ASCII.GetString(messageBytes);
        }
    }
    public class DigitalSignature
    {
        static RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(2048);
        static RSAParameters publicKey;
        static RSAParameters privateKey;
        public static void GenerateKeys(string publicKeyPath)
        {
            publicKey = rsa.ExportParameters(false);
            privateKey = rsa.ExportParameters(true);
            var publicKeyXml = rsa.ToXmlString(false);
            var privateKeyXml = rsa.ToXmlString(true);
            var publicKeyFullPath = Path.Combine(publicKeyPath, );
            var privateKeyFullPath = Path.Combine(publicKeyPath, );
            File.WriteAllText(publicKeyFullPath, publicKeyXml);
            File.WriteAllText(privateKeyFullPath, privateKeyXml);
            AnsiConsole.MarkupLine($);
        }
        public static void UploadKeys(string privateKeyPath)
        {
            var privateKeyXml = File.ReadAllText(privateKeyPath);
            rsa.FromXmlString(privateKeyXml);
            privateKey = rsa.ExportParameters(true);
        }
        public static void SignDocument(string documentPath)
        {
            if (privateKey.D == null)
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            if (!File.Exists(documentPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = SignData(data, privateKey);
            var signaturePath = documentPath + ;
            File.WriteAllBytes(signaturePath, signature);
            AnsiConsole.MarkupLine($);
        }
        public static void VerifyDocumentSignature(string documentPath, string signaturePath, string publicKeyPath)
        {
            if (!File.Exists(publicKeyPath))
            {
                Console.WriteLine();
                return;
            }
            var publicKeyXml = File.ReadAllText(publicKeyPath);
            rsa.FromXmlString(publicKeyXml);
            if (!File.Exists(signaturePath))
            {
                Console.WriteLine();
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = File.ReadAllBytes(signaturePath);
            var isVerified = VerifyData(data, signature);
            AnsiConsole.MarkupLine($);
        }
        public static byte[] SignData(byte[] data, RSAParameters privateKey)
        {
            rsa.ImportParameters(privateKey);
            var signedData = rsa.SignData(data, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            return signedData;
        }
        static bool VerifyData(byte[] data, byte[] signature)
        {
            return rsa.VerifyData(data, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
        }
    }
    public class AesRsaEncryption
    {
        public static void EncryptFile(string inputFilePath, string outputFilePath, RSAParameters publicKey)
        {
            using (Aes aes = Aes.Create())
            {
                aes.GenerateKey();
                aes.GenerateIV();
                using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    byte[] buffer = new byte[1024];
                    int bytesRead;
                    while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                    {
                        cryptoStream.Write(buffer, 0, bytesRead);
                    }
                }
                using (RSA rsa = new RSACryptoServiceProvider())
                {
                    rsa.ImportParameters(publicKey);
                    byte[] encryptedKey = rsa.Encrypt(aes.Key, RSAEncryptionPadding.Pkcs1);
                    File.WriteAllBytes(outputFilePath + , encryptedKey.Concat(aes.IV).ToArray());
                }
            }
        }
        public static void DecryptFile(string inputFilePath, string keyFilePath, string outputFilePath, RSAParameters privateKey)
        {
            byte[] encryptedData = File.ReadAllBytes(keyFilePath);
            byte[] encryptedKey = encryptedData.Take(encryptedData.Length - 16).ToArray();
            byte[] iv = encryptedData.Skip(encryptedData.Length - 16).ToArray();
            using (RSA rsa = new RSACryptoServiceProvider())
            {
                rsa.ImportParameters(privateKey);
                byte[] decryptedKey = rsa.Decrypt(encryptedKey, RSAEncryptionPadding.Pkcs1);
                using (Aes aes = Aes.Create())
                {
                    aes.Key = decryptedKey;
                    aes.IV = iv;
                    using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                    using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                    using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        byte[] buffer = new byte[1024];
                        int bytesRead;
                        while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                        {
                            cryptoStream.Write(buffer, 0, bytesRead);
                        }
                    }
                }
            }
        }
    }
}",CryptoAlgorithmsImplementations.cs
"using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using Spectre.Console;
namespace Implementation
{
    public class PasswordGenerator
    {
        private static readonly string LowercaseChars = ;
        private static readonly string UppercaseChars = ;
        private static readonly string NumberChars = ;
        private static readonly string SpecialChars = ;
        public static string GeneratePassword(bool useLowercase, bool useUppercase, bool useNumbers, bool useSpecial, int length)
        {
            if (length <= 0 || (!useLowercase && !useUppercase && !useNumbers && !useSpecial))
            {
                throw new ArgumentException();
            }
            string charPool = (useLowercase ? LowercaseChars : ) +
                              (useUppercase ? UppercaseChars : ) +
                              (useNumbers ? NumberChars : ) +
                              (useSpecial ? SpecialChars : );
            var bytes = new byte[length];
            RandomNumberGenerator.Fill(bytes);
            return new string(bytes.Select(b => charPool[b % charPool.Length]).ToArray());
        }
    }
    public class EntropyCalculator
    {
        public static double CalculateStringEntropy(string input)
        {
            if (string.IsNullOrEmpty(input))
                return 0.0; 
            Dictionary<char, int> charCounts = new Dictionary<char, int>();
            foreach (char c in input)
            {
                if (charCounts.ContainsKey(c))
                    charCounts[c]++;
                else
                    charCounts[c] = 1;
            }
            double entropy = 0.0;
            int totalChars = input.Length;
            foreach (var count in charCounts.Values)
            {
                double probability = (double)count / totalChars;
                entropy += probability * Math.Log2(probability);
            }
            return -entropy;
        }
    }
    public class Encrypt
    {
        public static void EncryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16]; 
                RandomNumberGenerator.Fill(salt);
                int iterations = 100000;
                Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                aes.Key = pdb.GetBytes(32);
                aes.IV = pdb.GetBytes(16);
                using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                {
                    fsOutput.Write(salt, 0, salt.Length);
                    using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                    using (CryptoStream cs = new CryptoStream(fsOutput, aes.CreateEncryptor(), CryptoStreamMode.Write))
                    {
                        int data;
                        while ((data = fsInput.ReadByte()) != -1)
                        {
                            cs.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Decrypt
    {
        public static void DecryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16];
                using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                {
                    fsInput.Read(salt, 0, salt.Length);
                    int iterations = 100000;
                    Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                    aes.Key = pdb.GetBytes(32);
                    aes.IV = pdb.GetBytes(16);
                    using (CryptoStream cs = new CryptoStream(fsInput, aes.CreateDecryptor(), CryptoStreamMode.Read))
                    using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                    {
                        int data;
                        while ((data = cs.ReadByte()) != -1)
                        {
                            fsOutput.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Hashing
    {
        public static string HashingFileWithSHA256(string filePath)
        {
            using SHA256 sha256 = SHA256.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha256.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithSHA1(string filePath)
        {
            using SHA1 sha1 = SHA1.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha1.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithMD5(string filePath)
        {
            using MD5 md5 = MD5.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(md5.ComputeHash(stream)).Replace(, ).ToLower();
        }
    }
    public class ImageSteganography
    {
        public enum State
        {
            Hiding,
            Filling_With_Zeros
        };
        public static void embedText(string text, string inputImagePath)
        {
            string originalFilePath = inputImagePath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            Bitmap bmp = new Bitmap(inputImagePath);
            State state = State.Hiding;
            int charIndex = 0;
            int charValue = 0;
            long pixelElementIndex = 0;
            int zeros = 0;
            int R = 0, G = 0, B = 0;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                { 
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    R = pixel.R - pixel.R % 2;
                    G = pixel.G - pixel.G % 2;
                    B = pixel.B - pixel.B % 2;
                    for (int n = 0; n < 3; n++)
                    {
                        if (pixelElementIndex % 8 == 0)
                        { 
                            if (state == State.Filling_With_Zeros && zeros == 8)
                            {
                                if ((pixelElementIndex - 1) % 3 < 2)
                                {
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                bmp.Save(newFilePath, ImageFormat.Png);
                            }
                            if (charIndex >= text.Length)
                            {
                                state = State.Filling_With_Zeros;
                            }
                            else
                            {
                                charValue = text[charIndex++];
                            }
                        }
                        switch (pixelElementIndex % 3)
                        {
                            case 0:
                                {
                                    if (state == State.Hiding)
                                    {
                                        R += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 1:
                                {
                                    if (state == State.Hiding)
                                    {
                                        G += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 2:
                                {
                                    if (state == State.Hiding)
                                    {
                                        B += charValue % 2;
                                        charValue /= 2;
                                    }
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                break;
                        }
                        pixelElementIndex++;
                        if (state == State.Filling_With_Zeros)
                        {
                            zeros++;
                        }
                    }
                }
            }
            bmp.Save(newFilePath, ImageFormat.Png);
        }
        public static string extractText(Bitmap bmp)
        {
            int colorUnitIndex = 0;
            int charValue = 0;
            string extractedText = String.Empty;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                {
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    for (int n = 0; n < 3; n++)
                    {
                        switch (colorUnitIndex % 3)
                        {
                            case 0:
                                {
                                    charValue = charValue * 2 + pixel.R % 2;
                                }
                                break;
                            case 1:
                                {
                                    charValue = charValue * 2 + pixel.G % 2;
                                }
                                break;
                            case 2:
                                {
                                    charValue = charValue * 2 + pixel.B % 2;
                                }
                                break;
                        }
                        colorUnitIndex++;
                        if (colorUnitIndex % 8 == 0)
                        {
                            charValue = reverseBits(charValue);
                            if (charValue == 0)
                            {
                                return extractedText;
                            }
                            char c = (char)charValue;
                            extractedText += c.ToString();
                        }
                    }
                }
            }
            return extractedText;
        }
        public static int reverseBits(int n)
        {
            int result = 0;
            for (int i = 0; i < 8; i++)
            {
                result = result * 2 + n % 2;
                n /= 2;
            }
            return result;
        }","}
    class AudioSteganography
    {","const int HEADER_SIZE = 4; 
        const int BYTE_INTERVAL = 16; 
        public static void HideMessageInAudio(string inputAudioPath, string message)
        {
            byte[] messageBytes = Encoding.ASCII.GetBytes(message);
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes.Length >> (i * 8 + j)) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit); 
                    audioIndex += BYTE_INTERVAL;
                }
            }
            for (int i = 0; i < messageBytes.Length; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes[i] >> j) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            string originalFilePath = inputAudioPath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            File.WriteAllBytes(newFilePath, audioBytes);
        }
        public static string ExtractMessageFromAudio(string inputAudioPath)
        {
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            int messageLength = 0;
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageLength |= (bit << (i * 8 + j));
                    audioIndex += BYTE_INTERVAL;
                }
            }
            byte[] messageBytes = new byte[messageLength];
            for (int i = 0; i < messageLength; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageBytes[i] |= (byte)(bit << j);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            return Encoding.ASCII.GetString(messageBytes);
        }
    }
    public class DigitalSignature
    {
        static RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(2048);
        static RSAParameters publicKey;
        static RSAParameters privateKey;
        public static void GenerateKeys(string publicKeyPath)
        {
            publicKey = rsa.ExportParameters(false);
            privateKey = rsa.ExportParameters(true);
            var publicKeyXml = rsa.ToXmlString(false);
            var privateKeyXml = rsa.ToXmlString(true);
            var publicKeyFullPath = Path.Combine(publicKeyPath, );
            var privateKeyFullPath = Path.Combine(publicKeyPath, );
            File.WriteAllText(publicKeyFullPath, publicKeyXml);
            File.WriteAllText(privateKeyFullPath, privateKeyXml);
            AnsiConsole.MarkupLine($);
        }
        public static void UploadKeys(string privateKeyPath)
        {
            var privateKeyXml = File.ReadAllText(privateKeyPath);
            rsa.FromXmlString(privateKeyXml);
            privateKey = rsa.ExportParameters(true);
        }
        public static void SignDocument(string documentPath)
        {
            if (privateKey.D == null)
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            if (!File.Exists(documentPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = SignData(data, privateKey);
            var signaturePath = documentPath + ;
            File.WriteAllBytes(signaturePath, signature);
            AnsiConsole.MarkupLine($);
        }
        public static void VerifyDocumentSignature(string documentPath, string signaturePath, string publicKeyPath)
        {
            if (!File.Exists(publicKeyPath))
            {
                Console.WriteLine();
                return;
            }
            var publicKeyXml = File.ReadAllText(publicKeyPath);
            rsa.FromXmlString(publicKeyXml);
            if (!File.Exists(signaturePath))
            {
                Console.WriteLine();
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = File.ReadAllBytes(signaturePath);
            var isVerified = VerifyData(data, signature);
            AnsiConsole.MarkupLine($);
        }
        public static byte[] SignData(byte[] data, RSAParameters privateKey)
        {
            rsa.ImportParameters(privateKey);
            var signedData = rsa.SignData(data, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            return signedData;
        }
        static bool VerifyData(byte[] data, byte[] signature)
        {
            return rsa.VerifyData(data, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
        }
    }
    public class AesRsaEncryption
    {
        public static void EncryptFile(string inputFilePath, string outputFilePath, RSAParameters publicKey)
        {
            using (Aes aes = Aes.Create())
            {
                aes.GenerateKey();
                aes.GenerateIV();
                using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    byte[] buffer = new byte[1024];
                    int bytesRead;
                    while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                    {
                        cryptoStream.Write(buffer, 0, bytesRead);
                    }
                }
                using (RSA rsa = new RSACryptoServiceProvider())
                {
                    rsa.ImportParameters(publicKey);
                    byte[] encryptedKey = rsa.Encrypt(aes.Key, RSAEncryptionPadding.Pkcs1);
                    File.WriteAllBytes(outputFilePath + , encryptedKey.Concat(aes.IV).ToArray());
                }
            }
        }
        public static void DecryptFile(string inputFilePath, string keyFilePath, string outputFilePath, RSAParameters privateKey)
        {
            byte[] encryptedData = File.ReadAllBytes(keyFilePath);
            byte[] encryptedKey = encryptedData.Take(encryptedData.Length - 16).ToArray();
            byte[] iv = encryptedData.Skip(encryptedData.Length - 16).ToArray();
            using (RSA rsa = new RSACryptoServiceProvider())
            {
                rsa.ImportParameters(privateKey);
                byte[] decryptedKey = rsa.Decrypt(encryptedKey, RSAEncryptionPadding.Pkcs1);
                using (Aes aes = Aes.Create())
                {
                    aes.Key = decryptedKey;
                    aes.IV = iv;
                    using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                    using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                    using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        byte[] buffer = new byte[1024];
                        int bytesRead;
                        while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                        {
                            cryptoStream.Write(buffer, 0, bytesRead);
                        }
                    }
                }
            }
        }
    }
}",CryptoAlgorithmsImplementations.cs
"using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using Spectre.Console;
namespace Implementation
{
    public class PasswordGenerator
    {
        private static readonly string LowercaseChars = ;
        private static readonly string UppercaseChars = ;
        private static readonly string NumberChars = ;
        private static readonly string SpecialChars = ;
        public static string GeneratePassword(bool useLowercase, bool useUppercase, bool useNumbers, bool useSpecial, int length)
        {
            if (length <= 0 || (!useLowercase && !useUppercase && !useNumbers && !useSpecial))
            {
                throw new ArgumentException();
            }
            string charPool = (useLowercase ? LowercaseChars : ) +
                              (useUppercase ? UppercaseChars : ) +
                              (useNumbers ? NumberChars : ) +
                              (useSpecial ? SpecialChars : );
            var bytes = new byte[length];
            RandomNumberGenerator.Fill(bytes);
            return new string(bytes.Select(b => charPool[b % charPool.Length]).ToArray());
        }
    }
    public class EntropyCalculator
    {
        public static double CalculateStringEntropy(string input)
        {
            if (string.IsNullOrEmpty(input))
                return 0.0; 
            Dictionary<char, int> charCounts = new Dictionary<char, int>();
            foreach (char c in input)
            {
                if (charCounts.ContainsKey(c))
                    charCounts[c]++;
                else
                    charCounts[c] = 1;
            }
            double entropy = 0.0;
            int totalChars = input.Length;
            foreach (var count in charCounts.Values)
            {
                double probability = (double)count / totalChars;
                entropy += probability * Math.Log2(probability);
            }
            return -entropy;
        }
    }
    public class Encrypt
    {
        public static void EncryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16]; 
                RandomNumberGenerator.Fill(salt);
                int iterations = 100000;
                Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                aes.Key = pdb.GetBytes(32);
                aes.IV = pdb.GetBytes(16);
                using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                {
                    fsOutput.Write(salt, 0, salt.Length);
                    using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                    using (CryptoStream cs = new CryptoStream(fsOutput, aes.CreateEncryptor(), CryptoStreamMode.Write))
                    {
                        int data;
                        while ((data = fsInput.ReadByte()) != -1)
                        {
                            cs.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Decrypt
    {
        public static void DecryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16];
                using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                {
                    fsInput.Read(salt, 0, salt.Length);
                    int iterations = 100000;
                    Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                    aes.Key = pdb.GetBytes(32);
                    aes.IV = pdb.GetBytes(16);
                    using (CryptoStream cs = new CryptoStream(fsInput, aes.CreateDecryptor(), CryptoStreamMode.Read))
                    using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                    {
                        int data;
                        while ((data = cs.ReadByte()) != -1)
                        {
                            fsOutput.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Hashing
    {
        public static string HashingFileWithSHA256(string filePath)
        {
            using SHA256 sha256 = SHA256.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha256.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithSHA1(string filePath)
        {
            using SHA1 sha1 = SHA1.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha1.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithMD5(string filePath)
        {
            using MD5 md5 = MD5.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(md5.ComputeHash(stream)).Replace(, ).ToLower();
        }
    }
    public class ImageSteganography
    {
        public enum State
        {
            Hiding,
            Filling_With_Zeros
        };
        public static void embedText(string text, string inputImagePath)
        {
            string originalFilePath = inputImagePath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            Bitmap bmp = new Bitmap(inputImagePath);
            State state = State.Hiding;
            int charIndex = 0;
            int charValue = 0;
            long pixelElementIndex = 0;
            int zeros = 0;
            int R = 0, G = 0, B = 0;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                { 
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    R = pixel.R - pixel.R % 2;
                    G = pixel.G - pixel.G % 2;
                    B = pixel.B - pixel.B % 2;
                    for (int n = 0; n < 3; n++)
                    {
                        if (pixelElementIndex % 8 == 0)
                        { 
                            if (state == State.Filling_With_Zeros && zeros == 8)
                            {
                                if ((pixelElementIndex - 1) % 3 < 2)
                                {
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                bmp.Save(newFilePath, ImageFormat.Png);
                            }
                            if (charIndex >= text.Length)
                            {
                                state = State.Filling_With_Zeros;
                            }
                            else
                            {
                                charValue = text[charIndex++];
                            }
                        }
                        switch (pixelElementIndex % 3)
                        {
                            case 0:
                                {
                                    if (state == State.Hiding)
                                    {
                                        R += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 1:
                                {
                                    if (state == State.Hiding)
                                    {
                                        G += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 2:
                                {
                                    if (state == State.Hiding)
                                    {
                                        B += charValue % 2;
                                        charValue /= 2;
                                    }
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                break;
                        }
                        pixelElementIndex++;
                        if (state == State.Filling_With_Zeros)
                        {
                            zeros++;
                        }
                    }
                }
            }
            bmp.Save(newFilePath, ImageFormat.Png);
        }
        public static string extractText(Bitmap bmp)
        {
            int colorUnitIndex = 0;
            int charValue = 0;
            string extractedText = String.Empty;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                {
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    for (int n = 0; n < 3; n++)
                    {
                        switch (colorUnitIndex % 3)
                        {
                            case 0:
                                {
                                    charValue = charValue * 2 + pixel.R % 2;
                                }
                                break;
                            case 1:
                                {
                                    charValue = charValue * 2 + pixel.G % 2;
                                }
                                break;
                            case 2:
                                {
                                    charValue = charValue * 2 + pixel.B % 2;
                                }
                                break;
                        }
                        colorUnitIndex++;
                        if (colorUnitIndex % 8 == 0)
                        {
                            charValue = reverseBits(charValue);
                            if (charValue == 0)
                            {
                                return extractedText;
                            }
                            char c = (char)charValue;
                            extractedText += c.ToString();
                        }
                    }
                }
            }
            return extractedText;
        }
        public static int reverseBits(int n)
        {
            int result = 0;
            for (int i = 0; i < 8; i++)
            {
                result = result * 2 + n % 2;
                n /= 2;
            }
            return result;
        }
    }
    class AudioSteganography
    {
        const int HEADER_SIZE = 4; 
        const int BYTE_INTERVAL = 16; 
        public static void HideMessageInAudio(string inputAudioPath, string message)
        {
            byte[] messageBytes = Encoding.ASCII.GetBytes(message);
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes.Length >> (i * 8 + j)) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit); 
                    audioIndex += BYTE_INTERVAL;
                }
            }
            for (int i = 0; i < messageBytes.Length; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes[i] >> j) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            string originalFilePath = inputAudioPath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            File.WriteAllBytes(newFilePath, audioBytes);
        }
        public static string ExtractMessageFromAudio(string inputAudioPath)
        {
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            int messageLength = 0;
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageLength |= (bit << (i * 8 + j));
                    audioIndex += BYTE_INTERVAL;
                }
            }
            byte[] messageBytes = new byte[messageLength];
            for (int i = 0; i < messageLength; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageBytes[i] |= (byte)(bit << j);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            return Encoding.ASCII.GetString(messageBytes);
        }
    }
    public class DigitalSignature
    {
        static RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(2048);
        static RSAParameters publicKey;
        static RSAParameters privateKey;
        public static void GenerateKeys(string publicKeyPath)
        {
            publicKey = rsa.ExportParameters(false);
            privateKey = rsa.ExportParameters(true);
            var publicKeyXml = rsa.ToXmlString(false);
            var privateKeyXml = rsa.ToXmlString(true);
            var publicKeyFullPath = Path.Combine(publicKeyPath, );
            var privateKeyFullPath = Path.Combine(publicKeyPath, );
            File.WriteAllText(publicKeyFullPath, publicKeyXml);
            File.WriteAllText(privateKeyFullPath, privateKeyXml);
            AnsiConsole.MarkupLine($);
        }
        public static void UploadKeys(string privateKeyPath)
        {
            var privateKeyXml = File.ReadAllText(privateKeyPath);
            rsa.FromXmlString(privateKeyXml);
            privateKey = rsa.ExportParameters(true);
        }
        public static void SignDocument(string documentPath)
        {
            if (privateKey.D == null)
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            if (!File.Exists(documentPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = SignData(data, privateKey);
            var signaturePath = documentPath + ;
            File.WriteAllBytes(signaturePath, signature);
            AnsiConsole.MarkupLine($);
        }
        public static void VerifyDocumentSignature(string documentPath, string signaturePath, string publicKeyPath)
        {
            if (!File.Exists(publicKeyPath))
            {
                Console.WriteLine();
                return;
            }
            var publicKeyXml = File.ReadAllText(publicKeyPath);
            rsa.FromXmlString(publicKeyXml);
            if (!File.Exists(signaturePath))
            {
                Console.WriteLine();
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = File.ReadAllBytes(signaturePath);
            var isVerified = VerifyData(data, signature);
            AnsiConsole.MarkupLine($);
        }
        public static byte[] SignData(byte[] data, RSAParameters privateKey)
        {
            rsa.ImportParameters(privateKey);
            var signedData = rsa.SignData(data, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            return signedData;
        }
        static bool VerifyData(byte[] data, byte[] signature)
        {
            return rsa.VerifyData(data, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
        }
    }
    public class AesRsaEncryption
    {
        public static void EncryptFile(string inputFilePath, string outputFilePath, RSAParameters publicKey)
        {
            using (Aes aes = Aes.Create())
            {
                aes.GenerateKey();
                aes.GenerateIV();
                using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    byte[] buffer = new byte[1024];
                    int bytesRead;
                    while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                    {
                        cryptoStream.Write(buffer, 0, bytesRead);
                    }
                }
                using (RSA rsa = new RSACryptoServiceProvider())
                {
                    rsa.ImportParameters(publicKey);
                    byte[] encryptedKey = rsa.Encrypt(aes.Key, RSAEncryptionPadding.Pkcs1);
                    File.WriteAllBytes(outputFilePath + , encryptedKey.Concat(aes.IV).ToArray());
                }
            }
        }
        public static void DecryptFile(string inputFilePath, string keyFilePath, string outputFilePath, RSAParameters privateKey)
        {
            byte[] encryptedData = File.ReadAllBytes(keyFilePath);
            byte[] encryptedKey = encryptedData.Take(encryptedData.Length - 16).ToArray();
            byte[] iv = encryptedData.Skip(encryptedData.Length - 16).ToArray();
            using (RSA rsa = new RSACryptoServiceProvider())
            {
                rsa.ImportParameters(privateKey);
                byte[] decryptedKey = rsa.Decrypt(encryptedKey, RSAEncryptionPadding.Pkcs1);
                using (Aes aes = Aes.Create())
                {
                    aes.Key = decryptedKey;","aes.IV = iv;
                    using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                    using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))","using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        byte[] buffer = new byte[1024];
                        int bytesRead;
                        while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                        {
                            cryptoStream.Write(buffer, 0, bytesRead);
                        }
                    }
                }
            }
        }
    }
}",CryptoAlgorithmsImplementations.cs
"using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using Spectre.Console;
namespace Implementation
{
    public class PasswordGenerator
    {
        private static readonly string LowercaseChars = ;
        private static readonly string UppercaseChars = ;
        private static readonly string NumberChars = ;
        private static readonly string SpecialChars = ;
        public static string GeneratePassword(bool useLowercase, bool useUppercase, bool useNumbers, bool useSpecial, int length)
        {
            if (length <= 0 || (!useLowercase && !useUppercase && !useNumbers && !useSpecial))
            {
                throw new ArgumentException();
            }
            string charPool = (useLowercase ? LowercaseChars : ) +
                              (useUppercase ? UppercaseChars : ) +
                              (useNumbers ? NumberChars : ) +
                              (useSpecial ? SpecialChars : );
            var bytes = new byte[length];
            RandomNumberGenerator.Fill(bytes);
            return new string(bytes.Select(b => charPool[b % charPool.Length]).ToArray());
        }
    }
    public class EntropyCalculator
    {
        public static double CalculateStringEntropy(string input)
        {
            if (string.IsNullOrEmpty(input))
                return 0.0; 
            Dictionary<char, int> charCounts = new Dictionary<char, int>();
            foreach (char c in input)
            {
                if (charCounts.ContainsKey(c))
                    charCounts[c]++;
                else
                    charCounts[c] = 1;
            }
            double entropy = 0.0;
            int totalChars = input.Length;
            foreach (var count in charCounts.Values)
            {
                double probability = (double)count / totalChars;
                entropy += probability * Math.Log2(probability);
            }
            return -entropy;
        }
    }
    public class Encrypt
    {
        public static void EncryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16]; 
                RandomNumberGenerator.Fill(salt);
                int iterations = 100000;
                Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                aes.Key = pdb.GetBytes(32);
                aes.IV = pdb.GetBytes(16);
                using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                {
                    fsOutput.Write(salt, 0, salt.Length);
                    using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                    using (CryptoStream cs = new CryptoStream(fsOutput, aes.CreateEncryptor(), CryptoStreamMode.Write))
                    {
                        int data;
                        while ((data = fsInput.ReadByte()) != -1)
                        {
                            cs.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Decrypt
    {
        public static void DecryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16];
                using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                {
                    fsInput.Read(salt, 0, salt.Length);
                    int iterations = 100000;
                    Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                    aes.Key = pdb.GetBytes(32);
                    aes.IV = pdb.GetBytes(16);
                    using (CryptoStream cs = new CryptoStream(fsInput, aes.CreateDecryptor(), CryptoStreamMode.Read))
                    using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                    {
                        int data;
                        while ((data = cs.ReadByte()) != -1)
                        {
                            fsOutput.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Hashing
    {
        public static string HashingFileWithSHA256(string filePath)
        {
            using SHA256 sha256 = SHA256.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha256.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithSHA1(string filePath)
        {
            using SHA1 sha1 = SHA1.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha1.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithMD5(string filePath)
        {
            using MD5 md5 = MD5.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(md5.ComputeHash(stream)).Replace(, ).ToLower();
        }
    }
    public class ImageSteganography
    {
        public enum State
        {
            Hiding,
            Filling_With_Zeros
        };
        public static void embedText(string text, string inputImagePath)
        {
            string originalFilePath = inputImagePath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            Bitmap bmp = new Bitmap(inputImagePath);
            State state = State.Hiding;
            int charIndex = 0;
            int charValue = 0;
            long pixelElementIndex = 0;
            int zeros = 0;
            int R = 0, G = 0, B = 0;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                { 
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    R = pixel.R - pixel.R % 2;
                    G = pixel.G - pixel.G % 2;
                    B = pixel.B - pixel.B % 2;
                    for (int n = 0; n < 3; n++)
                    {
                        if (pixelElementIndex % 8 == 0)
                        { 
                            if (state == State.Filling_With_Zeros && zeros == 8)
                            {
                                if ((pixelElementIndex - 1) % 3 < 2)
                                {
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                bmp.Save(newFilePath, ImageFormat.Png);
                            }
                            if (charIndex >= text.Length)
                            {
                                state = State.Filling_With_Zeros;
                            }
                            else
                            {
                                charValue = text[charIndex++];
                            }
                        }
                        switch (pixelElementIndex % 3)
                        {
                            case 0:
                                {
                                    if (state == State.Hiding)
                                    {
                                        R += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 1:
                                {
                                    if (state == State.Hiding)
                                    {
                                        G += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 2:
                                {
                                    if (state == State.Hiding)
                                    {
                                        B += charValue % 2;
                                        charValue /= 2;
                                    }
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                break;
                        }
                        pixelElementIndex++;
                        if (state == State.Filling_With_Zeros)
                        {
                            zeros++;
                        }
                    }
                }
            }
            bmp.Save(newFilePath, ImageFormat.Png);
        }
        public static string extractText(Bitmap bmp)
        {
            int colorUnitIndex = 0;
            int charValue = 0;
            string extractedText = String.Empty;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                {
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    for (int n = 0; n < 3; n++)
                    {
                        switch (colorUnitIndex % 3)
                        {
                            case 0:
                                {
                                    charValue = charValue * 2 + pixel.R % 2;
                                }
                                break;
                            case 1:
                                {
                                    charValue = charValue * 2 + pixel.G % 2;
                                }
                                break;
                            case 2:
                                {
                                    charValue = charValue * 2 + pixel.B % 2;
                                }
                                break;","}
                        colorUnitIndex++;
                        if (colorUnitIndex % 8 == 0)","{
                            charValue = reverseBits(charValue);
                            if (charValue == 0)
                            {
                                return extractedText;
                            }
                            char c = (char)charValue;
                            extractedText += c.ToString();
                        }
                    }
                }
            }
            return extractedText;
        }
        public static int reverseBits(int n)
        {
            int result = 0;
            for (int i = 0; i < 8; i++)
            {
                result = result * 2 + n % 2;
                n /= 2;
            }
            return result;
        }
    }
    class AudioSteganography
    {
        const int HEADER_SIZE = 4; 
        const int BYTE_INTERVAL = 16; 
        public static void HideMessageInAudio(string inputAudioPath, string message)
        {
            byte[] messageBytes = Encoding.ASCII.GetBytes(message);
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes.Length >> (i * 8 + j)) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit); 
                    audioIndex += BYTE_INTERVAL;
                }
            }
            for (int i = 0; i < messageBytes.Length; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes[i] >> j) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            string originalFilePath = inputAudioPath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            File.WriteAllBytes(newFilePath, audioBytes);
        }
        public static string ExtractMessageFromAudio(string inputAudioPath)
        {
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            int messageLength = 0;
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageLength |= (bit << (i * 8 + j));
                    audioIndex += BYTE_INTERVAL;
                }
            }
            byte[] messageBytes = new byte[messageLength];
            for (int i = 0; i < messageLength; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageBytes[i] |= (byte)(bit << j);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            return Encoding.ASCII.GetString(messageBytes);
        }
    }
    public class DigitalSignature
    {
        static RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(2048);
        static RSAParameters publicKey;
        static RSAParameters privateKey;
        public static void GenerateKeys(string publicKeyPath)
        {
            publicKey = rsa.ExportParameters(false);
            privateKey = rsa.ExportParameters(true);
            var publicKeyXml = rsa.ToXmlString(false);
            var privateKeyXml = rsa.ToXmlString(true);
            var publicKeyFullPath = Path.Combine(publicKeyPath, );
            var privateKeyFullPath = Path.Combine(publicKeyPath, );
            File.WriteAllText(publicKeyFullPath, publicKeyXml);
            File.WriteAllText(privateKeyFullPath, privateKeyXml);
            AnsiConsole.MarkupLine($);
        }
        public static void UploadKeys(string privateKeyPath)
        {
            var privateKeyXml = File.ReadAllText(privateKeyPath);
            rsa.FromXmlString(privateKeyXml);
            privateKey = rsa.ExportParameters(true);
        }
        public static void SignDocument(string documentPath)
        {
            if (privateKey.D == null)
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            if (!File.Exists(documentPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = SignData(data, privateKey);
            var signaturePath = documentPath + ;
            File.WriteAllBytes(signaturePath, signature);
            AnsiConsole.MarkupLine($);
        }
        public static void VerifyDocumentSignature(string documentPath, string signaturePath, string publicKeyPath)
        {
            if (!File.Exists(publicKeyPath))
            {
                Console.WriteLine();
                return;
            }
            var publicKeyXml = File.ReadAllText(publicKeyPath);
            rsa.FromXmlString(publicKeyXml);
            if (!File.Exists(signaturePath))
            {
                Console.WriteLine();
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = File.ReadAllBytes(signaturePath);
            var isVerified = VerifyData(data, signature);
            AnsiConsole.MarkupLine($);
        }
        public static byte[] SignData(byte[] data, RSAParameters privateKey)
        {
            rsa.ImportParameters(privateKey);
            var signedData = rsa.SignData(data, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            return signedData;
        }
        static bool VerifyData(byte[] data, byte[] signature)
        {
            return rsa.VerifyData(data, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
        }
    }
    public class AesRsaEncryption
    {
        public static void EncryptFile(string inputFilePath, string outputFilePath, RSAParameters publicKey)
        {
            using (Aes aes = Aes.Create())
            {
                aes.GenerateKey();
                aes.GenerateIV();
                using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    byte[] buffer = new byte[1024];
                    int bytesRead;
                    while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                    {
                        cryptoStream.Write(buffer, 0, bytesRead);
                    }
                }
                using (RSA rsa = new RSACryptoServiceProvider())
                {
                    rsa.ImportParameters(publicKey);
                    byte[] encryptedKey = rsa.Encrypt(aes.Key, RSAEncryptionPadding.Pkcs1);
                    File.WriteAllBytes(outputFilePath + , encryptedKey.Concat(aes.IV).ToArray());
                }
            }
        }
        public static void DecryptFile(string inputFilePath, string keyFilePath, string outputFilePath, RSAParameters privateKey)
        {
            byte[] encryptedData = File.ReadAllBytes(keyFilePath);
            byte[] encryptedKey = encryptedData.Take(encryptedData.Length - 16).ToArray();
            byte[] iv = encryptedData.Skip(encryptedData.Length - 16).ToArray();
            using (RSA rsa = new RSACryptoServiceProvider())
            {
                rsa.ImportParameters(privateKey);
                byte[] decryptedKey = rsa.Decrypt(encryptedKey, RSAEncryptionPadding.Pkcs1);
                using (Aes aes = Aes.Create())
                {
                    aes.Key = decryptedKey;
                    aes.IV = iv;
                    using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                    using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                    using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        byte[] buffer = new byte[1024];
                        int bytesRead;
                        while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                        {
                            cryptoStream.Write(buffer, 0, bytesRead);
                        }
                    }
                }
            }
        }
    }
}",CryptoAlgorithmsImplementations.cs
"using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using Spectre.Console;
namespace Implementation
{
    public class PasswordGenerator
    {
        private static readonly string LowercaseChars = ;
        private static readonly string UppercaseChars = ;
        private static readonly string NumberChars = ;
        private static readonly string SpecialChars = ;
        public static string GeneratePassword(bool useLowercase, bool useUppercase, bool useNumbers, bool useSpecial, int length)
        {
            if (length <= 0 || (!useLowercase && !useUppercase && !useNumbers && !useSpecial))
            {
                throw new ArgumentException();
            }
            string charPool = (useLowercase ? LowercaseChars : ) +
                              (useUppercase ? UppercaseChars : ) +
                              (useNumbers ? NumberChars : ) +
                              (useSpecial ? SpecialChars : );
            var bytes = new byte[length];
            RandomNumberGenerator.Fill(bytes);
            return new string(bytes.Select(b => charPool[b % charPool.Length]).ToArray());
        }
    }
    public class EntropyCalculator
    {
        public static double CalculateStringEntropy(string input)
        {
            if (string.IsNullOrEmpty(input))
                return 0.0; 
            Dictionary<char, int> charCounts = new Dictionary<char, int>();
            foreach (char c in input)
            {
                if (charCounts.ContainsKey(c))
                    charCounts[c]++;
                else
                    charCounts[c] = 1;
            }
            double entropy = 0.0;
            int totalChars = input.Length;
            foreach (var count in charCounts.Values)
            {
                double probability = (double)count / totalChars;
                entropy += probability * Math.Log2(probability);
            }
            return -entropy;
        }
    }
    public class Encrypt
    {
        public static void EncryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16]; 
                RandomNumberGenerator.Fill(salt);
                int iterations = 100000;
                Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                aes.Key = pdb.GetBytes(32);
                aes.IV = pdb.GetBytes(16);
                using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                {
                    fsOutput.Write(salt, 0, salt.Length);
                    using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                    using (CryptoStream cs = new CryptoStream(fsOutput, aes.CreateEncryptor(), CryptoStreamMode.Write))
                    {
                        int data;
                        while ((data = fsInput.ReadByte()) != -1)
                        {
                            cs.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Decrypt
    {
        public static void DecryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16];
                using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                {
                    fsInput.Read(salt, 0, salt.Length);
                    int iterations = 100000;
                    Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                    aes.Key = pdb.GetBytes(32);
                    aes.IV = pdb.GetBytes(16);
                    using (CryptoStream cs = new CryptoStream(fsInput, aes.CreateDecryptor(), CryptoStreamMode.Read))
                    using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                    {
                        int data;
                        while ((data = cs.ReadByte()) != -1)
                        {
                            fsOutput.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Hashing
    {
        public static string HashingFileWithSHA256(string filePath)
        {
            using SHA256 sha256 = SHA256.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha256.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithSHA1(string filePath)
        {
            using SHA1 sha1 = SHA1.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha1.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithMD5(string filePath)
        {
            using MD5 md5 = MD5.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(md5.ComputeHash(stream)).Replace(, ).ToLower();
        }
    }
    public class ImageSteganography
    {
        public enum State
        {
            Hiding,
            Filling_With_Zeros
        };
        public static void embedText(string text, string inputImagePath)
        {","string originalFilePath = inputImagePath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);","string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            Bitmap bmp = new Bitmap(inputImagePath);
            State state = State.Hiding;
            int charIndex = 0;
            int charValue = 0;
            long pixelElementIndex = 0;
            int zeros = 0;
            int R = 0, G = 0, B = 0;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                { 
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    R = pixel.R - pixel.R % 2;
                    G = pixel.G - pixel.G % 2;
                    B = pixel.B - pixel.B % 2;
                    for (int n = 0; n < 3; n++)
                    {
                        if (pixelElementIndex % 8 == 0)
                        { 
                            if (state == State.Filling_With_Zeros && zeros == 8)
                            {
                                if ((pixelElementIndex - 1) % 3 < 2)
                                {
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                bmp.Save(newFilePath, ImageFormat.Png);
                            }
                            if (charIndex >= text.Length)
                            {
                                state = State.Filling_With_Zeros;
                            }
                            else
                            {
                                charValue = text[charIndex++];
                            }
                        }
                        switch (pixelElementIndex % 3)
                        {
                            case 0:
                                {
                                    if (state == State.Hiding)
                                    {
                                        R += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 1:
                                {
                                    if (state == State.Hiding)
                                    {
                                        G += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 2:
                                {
                                    if (state == State.Hiding)
                                    {
                                        B += charValue % 2;
                                        charValue /= 2;
                                    }
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                break;
                        }
                        pixelElementIndex++;
                        if (state == State.Filling_With_Zeros)
                        {
                            zeros++;
                        }
                    }
                }
            }
            bmp.Save(newFilePath, ImageFormat.Png);
        }
        public static string extractText(Bitmap bmp)
        {
            int colorUnitIndex = 0;
            int charValue = 0;
            string extractedText = String.Empty;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                {
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    for (int n = 0; n < 3; n++)
                    {
                        switch (colorUnitIndex % 3)
                        {
                            case 0:
                                {
                                    charValue = charValue * 2 + pixel.R % 2;
                                }
                                break;
                            case 1:
                                {
                                    charValue = charValue * 2 + pixel.G % 2;
                                }
                                break;
                            case 2:
                                {
                                    charValue = charValue * 2 + pixel.B % 2;
                                }
                                break;
                        }
                        colorUnitIndex++;
                        if (colorUnitIndex % 8 == 0)
                        {
                            charValue = reverseBits(charValue);
                            if (charValue == 0)
                            {
                                return extractedText;
                            }
                            char c = (char)charValue;
                            extractedText += c.ToString();
                        }
                    }
                }
            }
            return extractedText;
        }
        public static int reverseBits(int n)
        {
            int result = 0;
            for (int i = 0; i < 8; i++)
            {
                result = result * 2 + n % 2;
                n /= 2;
            }
            return result;
        }
    }
    class AudioSteganography
    {
        const int HEADER_SIZE = 4; 
        const int BYTE_INTERVAL = 16; 
        public static void HideMessageInAudio(string inputAudioPath, string message)
        {
            byte[] messageBytes = Encoding.ASCII.GetBytes(message);
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes.Length >> (i * 8 + j)) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit); 
                    audioIndex += BYTE_INTERVAL;
                }
            }
            for (int i = 0; i < messageBytes.Length; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes[i] >> j) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            string originalFilePath = inputAudioPath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            File.WriteAllBytes(newFilePath, audioBytes);
        }
        public static string ExtractMessageFromAudio(string inputAudioPath)
        {
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            int messageLength = 0;
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageLength |= (bit << (i * 8 + j));
                    audioIndex += BYTE_INTERVAL;
                }
            }
            byte[] messageBytes = new byte[messageLength];
            for (int i = 0; i < messageLength; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageBytes[i] |= (byte)(bit << j);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            return Encoding.ASCII.GetString(messageBytes);
        }
    }
    public class DigitalSignature
    {
        static RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(2048);
        static RSAParameters publicKey;
        static RSAParameters privateKey;
        public static void GenerateKeys(string publicKeyPath)
        {
            publicKey = rsa.ExportParameters(false);
            privateKey = rsa.ExportParameters(true);
            var publicKeyXml = rsa.ToXmlString(false);
            var privateKeyXml = rsa.ToXmlString(true);
            var publicKeyFullPath = Path.Combine(publicKeyPath, );
            var privateKeyFullPath = Path.Combine(publicKeyPath, );
            File.WriteAllText(publicKeyFullPath, publicKeyXml);
            File.WriteAllText(privateKeyFullPath, privateKeyXml);
            AnsiConsole.MarkupLine($);
        }
        public static void UploadKeys(string privateKeyPath)
        {
            var privateKeyXml = File.ReadAllText(privateKeyPath);
            rsa.FromXmlString(privateKeyXml);
            privateKey = rsa.ExportParameters(true);
        }
        public static void SignDocument(string documentPath)
        {
            if (privateKey.D == null)
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            if (!File.Exists(documentPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = SignData(data, privateKey);
            var signaturePath = documentPath + ;
            File.WriteAllBytes(signaturePath, signature);
            AnsiConsole.MarkupLine($);
        }
        public static void VerifyDocumentSignature(string documentPath, string signaturePath, string publicKeyPath)
        {
            if (!File.Exists(publicKeyPath))
            {
                Console.WriteLine();
                return;
            }
            var publicKeyXml = File.ReadAllText(publicKeyPath);
            rsa.FromXmlString(publicKeyXml);
            if (!File.Exists(signaturePath))
            {
                Console.WriteLine();
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = File.ReadAllBytes(signaturePath);
            var isVerified = VerifyData(data, signature);
            AnsiConsole.MarkupLine($);
        }
        public static byte[] SignData(byte[] data, RSAParameters privateKey)
        {
            rsa.ImportParameters(privateKey);
            var signedData = rsa.SignData(data, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            return signedData;
        }
        static bool VerifyData(byte[] data, byte[] signature)
        {
            return rsa.VerifyData(data, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
        }
    }
    public class AesRsaEncryption
    {
        public static void EncryptFile(string inputFilePath, string outputFilePath, RSAParameters publicKey)
        {
            using (Aes aes = Aes.Create())
            {
                aes.GenerateKey();
                aes.GenerateIV();
                using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    byte[] buffer = new byte[1024];
                    int bytesRead;
                    while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                    {
                        cryptoStream.Write(buffer, 0, bytesRead);
                    }
                }
                using (RSA rsa = new RSACryptoServiceProvider())
                {
                    rsa.ImportParameters(publicKey);
                    byte[] encryptedKey = rsa.Encrypt(aes.Key, RSAEncryptionPadding.Pkcs1);
                    File.WriteAllBytes(outputFilePath + , encryptedKey.Concat(aes.IV).ToArray());
                }
            }
        }
        public static void DecryptFile(string inputFilePath, string keyFilePath, string outputFilePath, RSAParameters privateKey)
        {
            byte[] encryptedData = File.ReadAllBytes(keyFilePath);
            byte[] encryptedKey = encryptedData.Take(encryptedData.Length - 16).ToArray();
            byte[] iv = encryptedData.Skip(encryptedData.Length - 16).ToArray();
            using (RSA rsa = new RSACryptoServiceProvider())
            {
                rsa.ImportParameters(privateKey);
                byte[] decryptedKey = rsa.Decrypt(encryptedKey, RSAEncryptionPadding.Pkcs1);
                using (Aes aes = Aes.Create())
                {
                    aes.Key = decryptedKey;
                    aes.IV = iv;
                    using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                    using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                    using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        byte[] buffer = new byte[1024];
                        int bytesRead;
                        while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                        {
                            cryptoStream.Write(buffer, 0, bytesRead);
                        }
                    }
                }
            }
        }
    }
}",CryptoAlgorithmsImplementations.cs
"using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using Spectre.Console;
namespace Implementation
{
    public class PasswordGenerator
    {
        private static readonly string LowercaseChars = ;
        private static readonly string UppercaseChars = ;
        private static readonly string NumberChars = ;
        private static readonly string SpecialChars = ;
        public static string GeneratePassword(bool useLowercase, bool useUppercase, bool useNumbers, bool useSpecial, int length)
        {
            if (length <= 0 || (!useLowercase && !useUppercase && !useNumbers && !useSpecial))
            {
                throw new ArgumentException();
            }
            string charPool = (useLowercase ? LowercaseChars : ) +
                              (useUppercase ? UppercaseChars : ) +
                              (useNumbers ? NumberChars : ) +
                              (useSpecial ? SpecialChars : );
            var bytes = new byte[length];
            RandomNumberGenerator.Fill(bytes);
            return new string(bytes.Select(b => charPool[b % charPool.Length]).ToArray());
        }
    }
    public class EntropyCalculator
    {
        public static double CalculateStringEntropy(string input)
        {
            if (string.IsNullOrEmpty(input))
                return 0.0; 
            Dictionary<char, int> charCounts = new Dictionary<char, int>();
            foreach (char c in input)
            {
                if (charCounts.ContainsKey(c))
                    charCounts[c]++;
                else
                    charCounts[c] = 1;
            }
            double entropy = 0.0;
            int totalChars = input.Length;
            foreach (var count in charCounts.Values)
            {
                double probability = (double)count / totalChars;
                entropy += probability * Math.Log2(probability);
            }
            return -entropy;
        }
    }
    public class Encrypt
    {
        public static void EncryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16]; 
                RandomNumberGenerator.Fill(salt);
                int iterations = 100000;
                Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                aes.Key = pdb.GetBytes(32);
                aes.IV = pdb.GetBytes(16);
                using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                {
                    fsOutput.Write(salt, 0, salt.Length);
                    using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                    using (CryptoStream cs = new CryptoStream(fsOutput, aes.CreateEncryptor(), CryptoStreamMode.Write))
                    {
                        int data;
                        while ((data = fsInput.ReadByte()) != -1)
                        {
                            cs.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Decrypt
    {
        public static void DecryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16];
                using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                {
                    fsInput.Read(salt, 0, salt.Length);
                    int iterations = 100000;
                    Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                    aes.Key = pdb.GetBytes(32);
                    aes.IV = pdb.GetBytes(16);
                    using (CryptoStream cs = new CryptoStream(fsInput, aes.CreateDecryptor(), CryptoStreamMode.Read))
                    using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                    {
                        int data;
                        while ((data = cs.ReadByte()) != -1)
                        {
                            fsOutput.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Hashing
    {
        public static string HashingFileWithSHA256(string filePath)
        {
            using SHA256 sha256 = SHA256.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha256.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithSHA1(string filePath)
        {
            using SHA1 sha1 = SHA1.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha1.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithMD5(string filePath)
        {
            using MD5 md5 = MD5.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(md5.ComputeHash(stream)).Replace(, ).ToLower();
        }
    }
    public class ImageSteganography
    {
        public enum State
        {
            Hiding,
            Filling_With_Zeros
        };
        public static void embedText(string text, string inputImagePath)
        {
            string originalFilePath = inputImagePath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            Bitmap bmp = new Bitmap(inputImagePath);
            State state = State.Hiding;
            int charIndex = 0;
            int charValue = 0;
            long pixelElementIndex = 0;
            int zeros = 0;
            int R = 0, G = 0, B = 0;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                { 
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    R = pixel.R - pixel.R % 2;
                    G = pixel.G - pixel.G % 2;
                    B = pixel.B - pixel.B % 2;
                    for (int n = 0; n < 3; n++)
                    {
                        if (pixelElementIndex % 8 == 0)
                        { 
                            if (state == State.Filling_With_Zeros && zeros == 8)
                            {
                                if ((pixelElementIndex - 1) % 3 < 2)
                                {
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                bmp.Save(newFilePath, ImageFormat.Png);
                            }
                            if (charIndex >= text.Length)
                            {
                                state = State.Filling_With_Zeros;
                            }
                            else
                            {
                                charValue = text[charIndex++];
                            }
                        }
                        switch (pixelElementIndex % 3)
                        {
                            case 0:
                                {
                                    if (state == State.Hiding)
                                    {
                                        R += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 1:
                                {
                                    if (state == State.Hiding)
                                    {
                                        G += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 2:
                                {
                                    if (state == State.Hiding)
                                    {
                                        B += charValue % 2;
                                        charValue /= 2;
                                    }
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                break;
                        }
                        pixelElementIndex++;
                        if (state == State.Filling_With_Zeros)
                        {
                            zeros++;
                        }
                    }
                }
            }
            bmp.Save(newFilePath, ImageFormat.Png);
        }
        public static string extractText(Bitmap bmp)
        {
            int colorUnitIndex = 0;
            int charValue = 0;
            string extractedText = String.Empty;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                {
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    for (int n = 0; n < 3; n++)
                    {
                        switch (colorUnitIndex % 3)
                        {
                            case 0:
                                {
                                    charValue = charValue * 2 + pixel.R % 2;
                                }
                                break;
                            case 1:
                                {
                                    charValue = charValue * 2 + pixel.G % 2;
                                }
                                break;
                            case 2:
                                {
                                    charValue = charValue * 2 + pixel.B % 2;
                                }
                                break;
                        }
                        colorUnitIndex++;
                        if (colorUnitIndex % 8 == 0)
                        {
                            charValue = reverseBits(charValue);
                            if (charValue == 0)
                            {
                                return extractedText;
                            }
                            char c = (char)charValue;
                            extractedText += c.ToString();
                        }
                    }
                }
            }
            return extractedText;
        }
        public static int reverseBits(int n)
        {
            int result = 0;
            for (int i = 0; i < 8; i++)
            {
                result = result * 2 + n % 2;
                n /= 2;
            }
            return result;
        }
    }
    class AudioSteganography
    {
        const int HEADER_SIZE = 4; 
        const int BYTE_INTERVAL = 16; 
        public static void HideMessageInAudio(string inputAudioPath, string message)
        {
            byte[] messageBytes = Encoding.ASCII.GetBytes(message);
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes.Length >> (i * 8 + j)) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit); 
                    audioIndex += BYTE_INTERVAL;
                }
            }
            for (int i = 0; i < messageBytes.Length; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes[i] >> j) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            string originalFilePath = inputAudioPath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            File.WriteAllBytes(newFilePath, audioBytes);
        }
        public static string ExtractMessageFromAudio(string inputAudioPath)
        {
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            int messageLength = 0;
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageLength |= (bit << (i * 8 + j));
                    audioIndex += BYTE_INTERVAL;
                }
            }
            byte[] messageBytes = new byte[messageLength];
            for (int i = 0; i < messageLength; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageBytes[i] |= (byte)(bit << j);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            return Encoding.ASCII.GetString(messageBytes);
        }
    }
    public class DigitalSignature
    {
        static RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(2048);
        static RSAParameters publicKey;
        static RSAParameters privateKey;
        public static void GenerateKeys(string publicKeyPath)
        {
            publicKey = rsa.ExportParameters(false);
            privateKey = rsa.ExportParameters(true);
            var publicKeyXml = rsa.ToXmlString(false);
            var privateKeyXml = rsa.ToXmlString(true);
            var publicKeyFullPath = Path.Combine(publicKeyPath, );
            var privateKeyFullPath = Path.Combine(publicKeyPath, );
            File.WriteAllText(publicKeyFullPath, publicKeyXml);
            File.WriteAllText(privateKeyFullPath, privateKeyXml);
            AnsiConsole.MarkupLine($);
        }
        public static void UploadKeys(string privateKeyPath)
        {
            var privateKeyXml = File.ReadAllText(privateKeyPath);
            rsa.FromXmlString(privateKeyXml);
            privateKey = rsa.ExportParameters(true);
        }
        public static void SignDocument(string documentPath)
        {
            if (privateKey.D == null)
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            if (!File.Exists(documentPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = SignData(data, privateKey);","var signaturePath = documentPath + ;
            File.WriteAllBytes(signaturePath, signature);
            AnsiConsole.MarkupLine($);","}
        public static void VerifyDocumentSignature(string documentPath, string signaturePath, string publicKeyPath)
        {
            if (!File.Exists(publicKeyPath))
            {
                Console.WriteLine();
                return;
            }
            var publicKeyXml = File.ReadAllText(publicKeyPath);
            rsa.FromXmlString(publicKeyXml);
            if (!File.Exists(signaturePath))
            {
                Console.WriteLine();
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = File.ReadAllBytes(signaturePath);
            var isVerified = VerifyData(data, signature);
            AnsiConsole.MarkupLine($);
        }
        public static byte[] SignData(byte[] data, RSAParameters privateKey)
        {
            rsa.ImportParameters(privateKey);
            var signedData = rsa.SignData(data, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            return signedData;
        }
        static bool VerifyData(byte[] data, byte[] signature)
        {
            return rsa.VerifyData(data, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
        }
    }
    public class AesRsaEncryption
    {
        public static void EncryptFile(string inputFilePath, string outputFilePath, RSAParameters publicKey)
        {
            using (Aes aes = Aes.Create())
            {
                aes.GenerateKey();
                aes.GenerateIV();
                using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    byte[] buffer = new byte[1024];
                    int bytesRead;
                    while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                    {
                        cryptoStream.Write(buffer, 0, bytesRead);
                    }
                }
                using (RSA rsa = new RSACryptoServiceProvider())
                {
                    rsa.ImportParameters(publicKey);
                    byte[] encryptedKey = rsa.Encrypt(aes.Key, RSAEncryptionPadding.Pkcs1);
                    File.WriteAllBytes(outputFilePath + , encryptedKey.Concat(aes.IV).ToArray());
                }
            }
        }
        public static void DecryptFile(string inputFilePath, string keyFilePath, string outputFilePath, RSAParameters privateKey)
        {
            byte[] encryptedData = File.ReadAllBytes(keyFilePath);
            byte[] encryptedKey = encryptedData.Take(encryptedData.Length - 16).ToArray();
            byte[] iv = encryptedData.Skip(encryptedData.Length - 16).ToArray();
            using (RSA rsa = new RSACryptoServiceProvider())
            {
                rsa.ImportParameters(privateKey);
                byte[] decryptedKey = rsa.Decrypt(encryptedKey, RSAEncryptionPadding.Pkcs1);
                using (Aes aes = Aes.Create())
                {
                    aes.Key = decryptedKey;
                    aes.IV = iv;
                    using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                    using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                    using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        byte[] buffer = new byte[1024];
                        int bytesRead;
                        while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                        {
                            cryptoStream.Write(buffer, 0, bytesRead);
                        }
                    }
                }
            }
        }
    }
}",CryptoAlgorithmsImplementations.cs
"using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using Spectre.Console;
namespace Implementation
{
    public class PasswordGenerator
    {
        private static readonly string LowercaseChars = ;
        private static readonly string UppercaseChars = ;
        private static readonly string NumberChars = ;
        private static readonly string SpecialChars = ;
        public static string GeneratePassword(bool useLowercase, bool useUppercase, bool useNumbers, bool useSpecial, int length)
        {
            if (length <= 0 || (!useLowercase && !useUppercase && !useNumbers && !useSpecial))
            {
                throw new ArgumentException();
            }
            string charPool = (useLowercase ? LowercaseChars : ) +
                              (useUppercase ? UppercaseChars : ) +
                              (useNumbers ? NumberChars : ) +
                              (useSpecial ? SpecialChars : );
            var bytes = new byte[length];
            RandomNumberGenerator.Fill(bytes);
            return new string(bytes.Select(b => charPool[b % charPool.Length]).ToArray());
        }
    }
    public class EntropyCalculator
    {
        public static double CalculateStringEntropy(string input)
        {
            if (string.IsNullOrEmpty(input))
                return 0.0; 
            Dictionary<char, int> charCounts = new Dictionary<char, int>();
            foreach (char c in input)
            {
                if (charCounts.ContainsKey(c))
                    charCounts[c]++;
                else
                    charCounts[c] = 1;
            }
            double entropy = 0.0;
            int totalChars = input.Length;
            foreach (var count in charCounts.Values)
            {
                double probability = (double)count / totalChars;
                entropy += probability * Math.Log2(probability);
            }
            return -entropy;
        }
    }
    public class Encrypt
    {
        public static void EncryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16]; 
                RandomNumberGenerator.Fill(salt);
                int iterations = 100000;
                Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                aes.Key = pdb.GetBytes(32);
                aes.IV = pdb.GetBytes(16);
                using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                {
                    fsOutput.Write(salt, 0, salt.Length);
                    using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                    using (CryptoStream cs = new CryptoStream(fsOutput, aes.CreateEncryptor(), CryptoStreamMode.Write))
                    {
                        int data;
                        while ((data = fsInput.ReadByte()) != -1)
                        {
                            cs.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Decrypt
    {
        public static void DecryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16];
                using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                {
                    fsInput.Read(salt, 0, salt.Length);
                    int iterations = 100000;
                    Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                    aes.Key = pdb.GetBytes(32);
                    aes.IV = pdb.GetBytes(16);
                    using (CryptoStream cs = new CryptoStream(fsInput, aes.CreateDecryptor(), CryptoStreamMode.Read))
                    using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                    {
                        int data;
                        while ((data = cs.ReadByte()) != -1)
                        {
                            fsOutput.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Hashing
    {
        public static string HashingFileWithSHA256(string filePath)
        {
            using SHA256 sha256 = SHA256.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha256.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithSHA1(string filePath)
        {
            using SHA1 sha1 = SHA1.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha1.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithMD5(string filePath)","{
            using MD5 md5 = MD5.Create();
            using FileStream stream = File.OpenRead(filePath);","return BitConverter.ToString(md5.ComputeHash(stream)).Replace(, ).ToLower();
        }
    }
    public class ImageSteganography
    {
        public enum State
        {
            Hiding,
            Filling_With_Zeros
        };
        public static void embedText(string text, string inputImagePath)
        {
            string originalFilePath = inputImagePath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            Bitmap bmp = new Bitmap(inputImagePath);
            State state = State.Hiding;
            int charIndex = 0;
            int charValue = 0;
            long pixelElementIndex = 0;
            int zeros = 0;
            int R = 0, G = 0, B = 0;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                { 
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    R = pixel.R - pixel.R % 2;
                    G = pixel.G - pixel.G % 2;
                    B = pixel.B - pixel.B % 2;
                    for (int n = 0; n < 3; n++)
                    {
                        if (pixelElementIndex % 8 == 0)
                        { 
                            if (state == State.Filling_With_Zeros && zeros == 8)
                            {
                                if ((pixelElementIndex - 1) % 3 < 2)
                                {
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                bmp.Save(newFilePath, ImageFormat.Png);
                            }
                            if (charIndex >= text.Length)
                            {
                                state = State.Filling_With_Zeros;
                            }
                            else
                            {
                                charValue = text[charIndex++];
                            }
                        }
                        switch (pixelElementIndex % 3)
                        {
                            case 0:
                                {
                                    if (state == State.Hiding)
                                    {
                                        R += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 1:
                                {
                                    if (state == State.Hiding)
                                    {
                                        G += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 2:
                                {
                                    if (state == State.Hiding)
                                    {
                                        B += charValue % 2;
                                        charValue /= 2;
                                    }
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                break;
                        }
                        pixelElementIndex++;
                        if (state == State.Filling_With_Zeros)
                        {
                            zeros++;
                        }
                    }
                }
            }
            bmp.Save(newFilePath, ImageFormat.Png);
        }
        public static string extractText(Bitmap bmp)
        {
            int colorUnitIndex = 0;
            int charValue = 0;
            string extractedText = String.Empty;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                {
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    for (int n = 0; n < 3; n++)
                    {
                        switch (colorUnitIndex % 3)
                        {
                            case 0:
                                {
                                    charValue = charValue * 2 + pixel.R % 2;
                                }
                                break;
                            case 1:
                                {
                                    charValue = charValue * 2 + pixel.G % 2;
                                }
                                break;
                            case 2:
                                {
                                    charValue = charValue * 2 + pixel.B % 2;
                                }
                                break;
                        }
                        colorUnitIndex++;
                        if (colorUnitIndex % 8 == 0)
                        {
                            charValue = reverseBits(charValue);
                            if (charValue == 0)
                            {
                                return extractedText;
                            }
                            char c = (char)charValue;
                            extractedText += c.ToString();
                        }
                    }
                }
            }
            return extractedText;
        }
        public static int reverseBits(int n)
        {
            int result = 0;
            for (int i = 0; i < 8; i++)
            {
                result = result * 2 + n % 2;
                n /= 2;
            }
            return result;
        }
    }
    class AudioSteganography
    {
        const int HEADER_SIZE = 4; 
        const int BYTE_INTERVAL = 16; 
        public static void HideMessageInAudio(string inputAudioPath, string message)
        {
            byte[] messageBytes = Encoding.ASCII.GetBytes(message);
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes.Length >> (i * 8 + j)) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit); 
                    audioIndex += BYTE_INTERVAL;
                }
            }
            for (int i = 0; i < messageBytes.Length; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes[i] >> j) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            string originalFilePath = inputAudioPath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            File.WriteAllBytes(newFilePath, audioBytes);
        }
        public static string ExtractMessageFromAudio(string inputAudioPath)
        {
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            int messageLength = 0;
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageLength |= (bit << (i * 8 + j));
                    audioIndex += BYTE_INTERVAL;
                }
            }
            byte[] messageBytes = new byte[messageLength];
            for (int i = 0; i < messageLength; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageBytes[i] |= (byte)(bit << j);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            return Encoding.ASCII.GetString(messageBytes);
        }
    }
    public class DigitalSignature
    {
        static RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(2048);
        static RSAParameters publicKey;
        static RSAParameters privateKey;
        public static void GenerateKeys(string publicKeyPath)
        {
            publicKey = rsa.ExportParameters(false);
            privateKey = rsa.ExportParameters(true);
            var publicKeyXml = rsa.ToXmlString(false);
            var privateKeyXml = rsa.ToXmlString(true);
            var publicKeyFullPath = Path.Combine(publicKeyPath, );
            var privateKeyFullPath = Path.Combine(publicKeyPath, );
            File.WriteAllText(publicKeyFullPath, publicKeyXml);
            File.WriteAllText(privateKeyFullPath, privateKeyXml);
            AnsiConsole.MarkupLine($);
        }
        public static void UploadKeys(string privateKeyPath)
        {
            var privateKeyXml = File.ReadAllText(privateKeyPath);
            rsa.FromXmlString(privateKeyXml);
            privateKey = rsa.ExportParameters(true);
        }
        public static void SignDocument(string documentPath)
        {
            if (privateKey.D == null)
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            if (!File.Exists(documentPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = SignData(data, privateKey);
            var signaturePath = documentPath + ;
            File.WriteAllBytes(signaturePath, signature);
            AnsiConsole.MarkupLine($);
        }
        public static void VerifyDocumentSignature(string documentPath, string signaturePath, string publicKeyPath)
        {
            if (!File.Exists(publicKeyPath))
            {
                Console.WriteLine();
                return;
            }
            var publicKeyXml = File.ReadAllText(publicKeyPath);
            rsa.FromXmlString(publicKeyXml);
            if (!File.Exists(signaturePath))
            {
                Console.WriteLine();
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = File.ReadAllBytes(signaturePath);
            var isVerified = VerifyData(data, signature);
            AnsiConsole.MarkupLine($);
        }
        public static byte[] SignData(byte[] data, RSAParameters privateKey)
        {
            rsa.ImportParameters(privateKey);
            var signedData = rsa.SignData(data, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            return signedData;
        }
        static bool VerifyData(byte[] data, byte[] signature)
        {
            return rsa.VerifyData(data, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
        }
    }
    public class AesRsaEncryption
    {
        public static void EncryptFile(string inputFilePath, string outputFilePath, RSAParameters publicKey)
        {
            using (Aes aes = Aes.Create())
            {
                aes.GenerateKey();
                aes.GenerateIV();
                using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    byte[] buffer = new byte[1024];
                    int bytesRead;
                    while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                    {
                        cryptoStream.Write(buffer, 0, bytesRead);
                    }
                }
                using (RSA rsa = new RSACryptoServiceProvider())
                {
                    rsa.ImportParameters(publicKey);
                    byte[] encryptedKey = rsa.Encrypt(aes.Key, RSAEncryptionPadding.Pkcs1);
                    File.WriteAllBytes(outputFilePath + , encryptedKey.Concat(aes.IV).ToArray());
                }
            }
        }
        public static void DecryptFile(string inputFilePath, string keyFilePath, string outputFilePath, RSAParameters privateKey)
        {
            byte[] encryptedData = File.ReadAllBytes(keyFilePath);
            byte[] encryptedKey = encryptedData.Take(encryptedData.Length - 16).ToArray();
            byte[] iv = encryptedData.Skip(encryptedData.Length - 16).ToArray();
            using (RSA rsa = new RSACryptoServiceProvider())
            {
                rsa.ImportParameters(privateKey);
                byte[] decryptedKey = rsa.Decrypt(encryptedKey, RSAEncryptionPadding.Pkcs1);
                using (Aes aes = Aes.Create())
                {
                    aes.Key = decryptedKey;
                    aes.IV = iv;
                    using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                    using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                    using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        byte[] buffer = new byte[1024];
                        int bytesRead;
                        while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                        {
                            cryptoStream.Write(buffer, 0, bytesRead);
                        }
                    }
                }
            }
        }
    }
}",CryptoAlgorithmsImplementations.cs
"using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using Spectre.Console;
namespace Implementation
{
    public class PasswordGenerator
    {
        private static readonly string LowercaseChars = ;
        private static readonly string UppercaseChars = ;
        private static readonly string NumberChars = ;
        private static readonly string SpecialChars = ;
        public static string GeneratePassword(bool useLowercase, bool useUppercase, bool useNumbers, bool useSpecial, int length)
        {
            if (length <= 0 || (!useLowercase && !useUppercase && !useNumbers && !useSpecial))
            {
                throw new ArgumentException();
            }
            string charPool = (useLowercase ? LowercaseChars : ) +
                              (useUppercase ? UppercaseChars : ) +
                              (useNumbers ? NumberChars : ) +
                              (useSpecial ? SpecialChars : );
            var bytes = new byte[length];
            RandomNumberGenerator.Fill(bytes);
            return new string(bytes.Select(b => charPool[b % charPool.Length]).ToArray());
        }
    }
    public class EntropyCalculator
    {
        public static double CalculateStringEntropy(string input)
        {
            if (string.IsNullOrEmpty(input))
                return 0.0; 
            Dictionary<char, int> charCounts = new Dictionary<char, int>();
            foreach (char c in input)
            {
                if (charCounts.ContainsKey(c))
                    charCounts[c]++;
                else
                    charCounts[c] = 1;
            }
            double entropy = 0.0;
            int totalChars = input.Length;
            foreach (var count in charCounts.Values)
            {
                double probability = (double)count / totalChars;
                entropy += probability * Math.Log2(probability);
            }
            return -entropy;
        }
    }
    public class Encrypt
    {
        public static void EncryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16]; 
                RandomNumberGenerator.Fill(salt);
                int iterations = 100000;
                Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                aes.Key = pdb.GetBytes(32);
                aes.IV = pdb.GetBytes(16);
                using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                {
                    fsOutput.Write(salt, 0, salt.Length);
                    using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                    using (CryptoStream cs = new CryptoStream(fsOutput, aes.CreateEncryptor(), CryptoStreamMode.Write))
                    {
                        int data;
                        while ((data = fsInput.ReadByte()) != -1)
                        {
                            cs.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Decrypt
    {
        public static void DecryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16];
                using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                {
                    fsInput.Read(salt, 0, salt.Length);
                    int iterations = 100000;
                    Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                    aes.Key = pdb.GetBytes(32);
                    aes.IV = pdb.GetBytes(16);
                    using (CryptoStream cs = new CryptoStream(fsInput, aes.CreateDecryptor(), CryptoStreamMode.Read))
                    using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                    {
                        int data;
                        while ((data = cs.ReadByte()) != -1)
                        {
                            fsOutput.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Hashing
    {
        public static string HashingFileWithSHA256(string filePath)
        {
            using SHA256 sha256 = SHA256.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha256.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithSHA1(string filePath)
        {
            using SHA1 sha1 = SHA1.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha1.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithMD5(string filePath)
        {
            using MD5 md5 = MD5.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(md5.ComputeHash(stream)).Replace(, ).ToLower();
        }
    }
    public class ImageSteganography
    {
        public enum State
        {
            Hiding,
            Filling_With_Zeros
        };
        public static void embedText(string text, string inputImagePath)
        {
            string originalFilePath = inputImagePath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            Bitmap bmp = new Bitmap(inputImagePath);
            State state = State.Hiding;
            int charIndex = 0;
            int charValue = 0;
            long pixelElementIndex = 0;
            int zeros = 0;
            int R = 0, G = 0, B = 0;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                { 
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    R = pixel.R - pixel.R % 2;
                    G = pixel.G - pixel.G % 2;
                    B = pixel.B - pixel.B % 2;
                    for (int n = 0; n < 3; n++)
                    {
                        if (pixelElementIndex % 8 == 0)
                        { 
                            if (state == State.Filling_With_Zeros && zeros == 8)
                            {
                                if ((pixelElementIndex - 1) % 3 < 2)
                                {
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                bmp.Save(newFilePath, ImageFormat.Png);
                            }
                            if (charIndex >= text.Length)
                            {
                                state = State.Filling_With_Zeros;
                            }
                            else
                            {
                                charValue = text[charIndex++];
                            }
                        }
                        switch (pixelElementIndex % 3)
                        {
                            case 0:
                                {
                                    if (state == State.Hiding)
                                    {
                                        R += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 1:
                                {
                                    if (state == State.Hiding)
                                    {
                                        G += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 2:
                                {
                                    if (state == State.Hiding)
                                    {
                                        B += charValue % 2;
                                        charValue /= 2;
                                    }
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                break;
                        }
                        pixelElementIndex++;
                        if (state == State.Filling_With_Zeros)
                        {
                            zeros++;
                        }
                    }
                }
            }
            bmp.Save(newFilePath, ImageFormat.Png);
        }
        public static string extractText(Bitmap bmp)
        {
            int colorUnitIndex = 0;
            int charValue = 0;
            string extractedText = String.Empty;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                {
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    for (int n = 0; n < 3; n++)
                    {
                        switch (colorUnitIndex % 3)
                        {
                            case 0:
                                {
                                    charValue = charValue * 2 + pixel.R % 2;
                                }
                                break;
                            case 1:
                                {
                                    charValue = charValue * 2 + pixel.G % 2;
                                }
                                break;
                            case 2:
                                {
                                    charValue = charValue * 2 + pixel.B % 2;
                                }
                                break;
                        }
                        colorUnitIndex++;
                        if (colorUnitIndex % 8 == 0)
                        {
                            charValue = reverseBits(charValue);
                            if (charValue == 0)
                            {
                                return extractedText;
                            }
                            char c = (char)charValue;
                            extractedText += c.ToString();
                        }
                    }
                }
            }
            return extractedText;
        }
        public static int reverseBits(int n)
        {
            int result = 0;
            for (int i = 0; i < 8; i++)
            {
                result = result * 2 + n % 2;
                n /= 2;
            }","return result;
        }
    }","class AudioSteganography
    {
        const int HEADER_SIZE = 4; 
        const int BYTE_INTERVAL = 16; 
        public static void HideMessageInAudio(string inputAudioPath, string message)
        {
            byte[] messageBytes = Encoding.ASCII.GetBytes(message);
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes.Length >> (i * 8 + j)) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit); 
                    audioIndex += BYTE_INTERVAL;
                }
            }
            for (int i = 0; i < messageBytes.Length; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes[i] >> j) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            string originalFilePath = inputAudioPath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            File.WriteAllBytes(newFilePath, audioBytes);
        }
        public static string ExtractMessageFromAudio(string inputAudioPath)
        {
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            int messageLength = 0;
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageLength |= (bit << (i * 8 + j));
                    audioIndex += BYTE_INTERVAL;
                }
            }
            byte[] messageBytes = new byte[messageLength];
            for (int i = 0; i < messageLength; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageBytes[i] |= (byte)(bit << j);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            return Encoding.ASCII.GetString(messageBytes);
        }
    }
    public class DigitalSignature
    {
        static RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(2048);
        static RSAParameters publicKey;
        static RSAParameters privateKey;
        public static void GenerateKeys(string publicKeyPath)
        {
            publicKey = rsa.ExportParameters(false);
            privateKey = rsa.ExportParameters(true);
            var publicKeyXml = rsa.ToXmlString(false);
            var privateKeyXml = rsa.ToXmlString(true);
            var publicKeyFullPath = Path.Combine(publicKeyPath, );
            var privateKeyFullPath = Path.Combine(publicKeyPath, );
            File.WriteAllText(publicKeyFullPath, publicKeyXml);
            File.WriteAllText(privateKeyFullPath, privateKeyXml);
            AnsiConsole.MarkupLine($);
        }
        public static void UploadKeys(string privateKeyPath)
        {
            var privateKeyXml = File.ReadAllText(privateKeyPath);
            rsa.FromXmlString(privateKeyXml);
            privateKey = rsa.ExportParameters(true);
        }
        public static void SignDocument(string documentPath)
        {
            if (privateKey.D == null)
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            if (!File.Exists(documentPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = SignData(data, privateKey);
            var signaturePath = documentPath + ;
            File.WriteAllBytes(signaturePath, signature);
            AnsiConsole.MarkupLine($);
        }
        public static void VerifyDocumentSignature(string documentPath, string signaturePath, string publicKeyPath)
        {
            if (!File.Exists(publicKeyPath))
            {
                Console.WriteLine();
                return;
            }
            var publicKeyXml = File.ReadAllText(publicKeyPath);
            rsa.FromXmlString(publicKeyXml);
            if (!File.Exists(signaturePath))
            {
                Console.WriteLine();
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = File.ReadAllBytes(signaturePath);
            var isVerified = VerifyData(data, signature);
            AnsiConsole.MarkupLine($);
        }
        public static byte[] SignData(byte[] data, RSAParameters privateKey)
        {
            rsa.ImportParameters(privateKey);
            var signedData = rsa.SignData(data, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            return signedData;
        }
        static bool VerifyData(byte[] data, byte[] signature)
        {
            return rsa.VerifyData(data, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
        }
    }
    public class AesRsaEncryption
    {
        public static void EncryptFile(string inputFilePath, string outputFilePath, RSAParameters publicKey)
        {
            using (Aes aes = Aes.Create())
            {
                aes.GenerateKey();
                aes.GenerateIV();
                using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    byte[] buffer = new byte[1024];
                    int bytesRead;
                    while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                    {
                        cryptoStream.Write(buffer, 0, bytesRead);
                    }
                }
                using (RSA rsa = new RSACryptoServiceProvider())
                {
                    rsa.ImportParameters(publicKey);
                    byte[] encryptedKey = rsa.Encrypt(aes.Key, RSAEncryptionPadding.Pkcs1);
                    File.WriteAllBytes(outputFilePath + , encryptedKey.Concat(aes.IV).ToArray());
                }
            }
        }
        public static void DecryptFile(string inputFilePath, string keyFilePath, string outputFilePath, RSAParameters privateKey)
        {
            byte[] encryptedData = File.ReadAllBytes(keyFilePath);
            byte[] encryptedKey = encryptedData.Take(encryptedData.Length - 16).ToArray();
            byte[] iv = encryptedData.Skip(encryptedData.Length - 16).ToArray();
            using (RSA rsa = new RSACryptoServiceProvider())
            {
                rsa.ImportParameters(privateKey);
                byte[] decryptedKey = rsa.Decrypt(encryptedKey, RSAEncryptionPadding.Pkcs1);
                using (Aes aes = Aes.Create())
                {
                    aes.Key = decryptedKey;
                    aes.IV = iv;
                    using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                    using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                    using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        byte[] buffer = new byte[1024];
                        int bytesRead;
                        while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                        {
                            cryptoStream.Write(buffer, 0, bytesRead);
                        }
                    }
                }
            }
        }
    }
}",CryptoAlgorithmsImplementations.cs
"using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using Spectre.Console;
namespace Implementation
{
    public class PasswordGenerator
    {
        private static readonly string LowercaseChars = ;
        private static readonly string UppercaseChars = ;
        private static readonly string NumberChars = ;
        private static readonly string SpecialChars = ;
        public static string GeneratePassword(bool useLowercase, bool useUppercase, bool useNumbers, bool useSpecial, int length)
        {
            if (length <= 0 || (!useLowercase && !useUppercase && !useNumbers && !useSpecial))
            {
                throw new ArgumentException();
            }
            string charPool = (useLowercase ? LowercaseChars : ) +
                              (useUppercase ? UppercaseChars : ) +
                              (useNumbers ? NumberChars : ) +
                              (useSpecial ? SpecialChars : );
            var bytes = new byte[length];
            RandomNumberGenerator.Fill(bytes);
            return new string(bytes.Select(b => charPool[b % charPool.Length]).ToArray());
        }
    }
    public class EntropyCalculator
    {
        public static double CalculateStringEntropy(string input)
        {
            if (string.IsNullOrEmpty(input))
                return 0.0; 
            Dictionary<char, int> charCounts = new Dictionary<char, int>();
            foreach (char c in input)
            {
                if (charCounts.ContainsKey(c))
                    charCounts[c]++;
                else
                    charCounts[c] = 1;
            }
            double entropy = 0.0;
            int totalChars = input.Length;
            foreach (var count in charCounts.Values)
            {
                double probability = (double)count / totalChars;
                entropy += probability * Math.Log2(probability);
            }
            return -entropy;
        }
    }
    public class Encrypt
    {
        public static void EncryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16]; 
                RandomNumberGenerator.Fill(salt);
                int iterations = 100000;
                Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                aes.Key = pdb.GetBytes(32);
                aes.IV = pdb.GetBytes(16);
                using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                {
                    fsOutput.Write(salt, 0, salt.Length);
                    using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                    using (CryptoStream cs = new CryptoStream(fsOutput, aes.CreateEncryptor(), CryptoStreamMode.Write))
                    {
                        int data;
                        while ((data = fsInput.ReadByte()) != -1)
                        {
                            cs.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Decrypt
    {
        public static void DecryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16];
                using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                {
                    fsInput.Read(salt, 0, salt.Length);
                    int iterations = 100000;
                    Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                    aes.Key = pdb.GetBytes(32);
                    aes.IV = pdb.GetBytes(16);
                    using (CryptoStream cs = new CryptoStream(fsInput, aes.CreateDecryptor(), CryptoStreamMode.Read))
                    using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                    {
                        int data;
                        while ((data = cs.ReadByte()) != -1)
                        {
                            fsOutput.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Hashing
    {
        public static string HashingFileWithSHA256(string filePath)
        {
            using SHA256 sha256 = SHA256.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha256.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithSHA1(string filePath)
        {
            using SHA1 sha1 = SHA1.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha1.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithMD5(string filePath)
        {
            using MD5 md5 = MD5.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(md5.ComputeHash(stream)).Replace(, ).ToLower();
        }
    }
    public class ImageSteganography
    {
        public enum State
        {
            Hiding,
            Filling_With_Zeros
        };
        public static void embedText(string text, string inputImagePath)
        {
            string originalFilePath = inputImagePath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            Bitmap bmp = new Bitmap(inputImagePath);
            State state = State.Hiding;
            int charIndex = 0;
            int charValue = 0;
            long pixelElementIndex = 0;
            int zeros = 0;
            int R = 0, G = 0, B = 0;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                { 
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    R = pixel.R - pixel.R % 2;
                    G = pixel.G - pixel.G % 2;
                    B = pixel.B - pixel.B % 2;
                    for (int n = 0; n < 3; n++)
                    {
                        if (pixelElementIndex % 8 == 0)
                        { 
                            if (state == State.Filling_With_Zeros && zeros == 8)
                            {
                                if ((pixelElementIndex - 1) % 3 < 2)
                                {
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                bmp.Save(newFilePath, ImageFormat.Png);
                            }
                            if (charIndex >= text.Length)
                            {
                                state = State.Filling_With_Zeros;
                            }
                            else
                            {
                                charValue = text[charIndex++];
                            }
                        }
                        switch (pixelElementIndex % 3)
                        {
                            case 0:","{
                                    if (state == State.Hiding)
                                    {","R += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 1:
                                {
                                    if (state == State.Hiding)
                                    {
                                        G += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 2:
                                {
                                    if (state == State.Hiding)
                                    {
                                        B += charValue % 2;
                                        charValue /= 2;
                                    }
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                break;
                        }
                        pixelElementIndex++;
                        if (state == State.Filling_With_Zeros)
                        {
                            zeros++;
                        }
                    }
                }
            }
            bmp.Save(newFilePath, ImageFormat.Png);
        }
        public static string extractText(Bitmap bmp)
        {
            int colorUnitIndex = 0;
            int charValue = 0;
            string extractedText = String.Empty;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                {
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    for (int n = 0; n < 3; n++)
                    {
                        switch (colorUnitIndex % 3)
                        {
                            case 0:
                                {
                                    charValue = charValue * 2 + pixel.R % 2;
                                }
                                break;
                            case 1:
                                {
                                    charValue = charValue * 2 + pixel.G % 2;
                                }
                                break;
                            case 2:
                                {
                                    charValue = charValue * 2 + pixel.B % 2;
                                }
                                break;
                        }
                        colorUnitIndex++;
                        if (colorUnitIndex % 8 == 0)
                        {
                            charValue = reverseBits(charValue);
                            if (charValue == 0)
                            {
                                return extractedText;
                            }
                            char c = (char)charValue;
                            extractedText += c.ToString();
                        }
                    }
                }
            }
            return extractedText;
        }
        public static int reverseBits(int n)
        {
            int result = 0;
            for (int i = 0; i < 8; i++)
            {
                result = result * 2 + n % 2;
                n /= 2;
            }
            return result;
        }
    }
    class AudioSteganography
    {
        const int HEADER_SIZE = 4; 
        const int BYTE_INTERVAL = 16; 
        public static void HideMessageInAudio(string inputAudioPath, string message)
        {
            byte[] messageBytes = Encoding.ASCII.GetBytes(message);
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes.Length >> (i * 8 + j)) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit); 
                    audioIndex += BYTE_INTERVAL;
                }
            }
            for (int i = 0; i < messageBytes.Length; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes[i] >> j) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            string originalFilePath = inputAudioPath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            File.WriteAllBytes(newFilePath, audioBytes);
        }
        public static string ExtractMessageFromAudio(string inputAudioPath)
        {
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            int messageLength = 0;
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageLength |= (bit << (i * 8 + j));
                    audioIndex += BYTE_INTERVAL;
                }
            }
            byte[] messageBytes = new byte[messageLength];
            for (int i = 0; i < messageLength; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageBytes[i] |= (byte)(bit << j);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            return Encoding.ASCII.GetString(messageBytes);
        }
    }
    public class DigitalSignature
    {
        static RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(2048);
        static RSAParameters publicKey;
        static RSAParameters privateKey;
        public static void GenerateKeys(string publicKeyPath)
        {
            publicKey = rsa.ExportParameters(false);
            privateKey = rsa.ExportParameters(true);
            var publicKeyXml = rsa.ToXmlString(false);
            var privateKeyXml = rsa.ToXmlString(true);
            var publicKeyFullPath = Path.Combine(publicKeyPath, );
            var privateKeyFullPath = Path.Combine(publicKeyPath, );
            File.WriteAllText(publicKeyFullPath, publicKeyXml);
            File.WriteAllText(privateKeyFullPath, privateKeyXml);
            AnsiConsole.MarkupLine($);
        }
        public static void UploadKeys(string privateKeyPath)
        {
            var privateKeyXml = File.ReadAllText(privateKeyPath);
            rsa.FromXmlString(privateKeyXml);
            privateKey = rsa.ExportParameters(true);
        }
        public static void SignDocument(string documentPath)
        {
            if (privateKey.D == null)
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            if (!File.Exists(documentPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = SignData(data, privateKey);
            var signaturePath = documentPath + ;
            File.WriteAllBytes(signaturePath, signature);
            AnsiConsole.MarkupLine($);
        }
        public static void VerifyDocumentSignature(string documentPath, string signaturePath, string publicKeyPath)
        {
            if (!File.Exists(publicKeyPath))
            {
                Console.WriteLine();
                return;
            }
            var publicKeyXml = File.ReadAllText(publicKeyPath);
            rsa.FromXmlString(publicKeyXml);
            if (!File.Exists(signaturePath))
            {
                Console.WriteLine();
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = File.ReadAllBytes(signaturePath);
            var isVerified = VerifyData(data, signature);
            AnsiConsole.MarkupLine($);
        }
        public static byte[] SignData(byte[] data, RSAParameters privateKey)
        {
            rsa.ImportParameters(privateKey);
            var signedData = rsa.SignData(data, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            return signedData;
        }
        static bool VerifyData(byte[] data, byte[] signature)
        {
            return rsa.VerifyData(data, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
        }
    }
    public class AesRsaEncryption
    {
        public static void EncryptFile(string inputFilePath, string outputFilePath, RSAParameters publicKey)
        {
            using (Aes aes = Aes.Create())
            {
                aes.GenerateKey();
                aes.GenerateIV();
                using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    byte[] buffer = new byte[1024];
                    int bytesRead;
                    while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                    {
                        cryptoStream.Write(buffer, 0, bytesRead);
                    }
                }
                using (RSA rsa = new RSACryptoServiceProvider())
                {
                    rsa.ImportParameters(publicKey);
                    byte[] encryptedKey = rsa.Encrypt(aes.Key, RSAEncryptionPadding.Pkcs1);
                    File.WriteAllBytes(outputFilePath + , encryptedKey.Concat(aes.IV).ToArray());
                }
            }
        }
        public static void DecryptFile(string inputFilePath, string keyFilePath, string outputFilePath, RSAParameters privateKey)
        {
            byte[] encryptedData = File.ReadAllBytes(keyFilePath);
            byte[] encryptedKey = encryptedData.Take(encryptedData.Length - 16).ToArray();
            byte[] iv = encryptedData.Skip(encryptedData.Length - 16).ToArray();
            using (RSA rsa = new RSACryptoServiceProvider())
            {
                rsa.ImportParameters(privateKey);
                byte[] decryptedKey = rsa.Decrypt(encryptedKey, RSAEncryptionPadding.Pkcs1);
                using (Aes aes = Aes.Create())
                {
                    aes.Key = decryptedKey;
                    aes.IV = iv;
                    using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                    using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                    using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        byte[] buffer = new byte[1024];
                        int bytesRead;
                        while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                        {
                            cryptoStream.Write(buffer, 0, bytesRead);
                        }
                    }
                }
            }
        }
    }
}",CryptoAlgorithmsImplementations.cs
"using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using Spectre.Console;
namespace Implementation
{
    public class PasswordGenerator
    {
        private static readonly string LowercaseChars = ;
        private static readonly string UppercaseChars = ;
        private static readonly string NumberChars = ;
        private static readonly string SpecialChars = ;
        public static string GeneratePassword(bool useLowercase, bool useUppercase, bool useNumbers, bool useSpecial, int length)
        {
            if (length <= 0 || (!useLowercase && !useUppercase && !useNumbers && !useSpecial))
            {
                throw new ArgumentException();
            }
            string charPool = (useLowercase ? LowercaseChars : ) +
                              (useUppercase ? UppercaseChars : ) +
                              (useNumbers ? NumberChars : ) +
                              (useSpecial ? SpecialChars : );
            var bytes = new byte[length];
            RandomNumberGenerator.Fill(bytes);
            return new string(bytes.Select(b => charPool[b % charPool.Length]).ToArray());
        }
    }
    public class EntropyCalculator
    {
        public static double CalculateStringEntropy(string input)
        {
            if (string.IsNullOrEmpty(input))
                return 0.0; 
            Dictionary<char, int> charCounts = new Dictionary<char, int>();
            foreach (char c in input)
            {
                if (charCounts.ContainsKey(c))
                    charCounts[c]++;
                else
                    charCounts[c] = 1;
            }
            double entropy = 0.0;
            int totalChars = input.Length;
            foreach (var count in charCounts.Values)
            {
                double probability = (double)count / totalChars;
                entropy += probability * Math.Log2(probability);
            }
            return -entropy;
        }
    }
    public class Encrypt
    {
        public static void EncryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16]; 
                RandomNumberGenerator.Fill(salt);
                int iterations = 100000;
                Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                aes.Key = pdb.GetBytes(32);
                aes.IV = pdb.GetBytes(16);
                using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                {
                    fsOutput.Write(salt, 0, salt.Length);
                    using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                    using (CryptoStream cs = new CryptoStream(fsOutput, aes.CreateEncryptor(), CryptoStreamMode.Write))
                    {
                        int data;
                        while ((data = fsInput.ReadByte()) != -1)
                        {
                            cs.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Decrypt
    {
        public static void DecryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16];
                using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                {
                    fsInput.Read(salt, 0, salt.Length);
                    int iterations = 100000;
                    Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                    aes.Key = pdb.GetBytes(32);
                    aes.IV = pdb.GetBytes(16);
                    using (CryptoStream cs = new CryptoStream(fsInput, aes.CreateDecryptor(), CryptoStreamMode.Read))
                    using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                    {
                        int data;
                        while ((data = cs.ReadByte()) != -1)
                        {
                            fsOutput.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Hashing
    {
        public static string HashingFileWithSHA256(string filePath)
        {
            using SHA256 sha256 = SHA256.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha256.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithSHA1(string filePath)
        {
            using SHA1 sha1 = SHA1.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha1.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithMD5(string filePath)
        {
            using MD5 md5 = MD5.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(md5.ComputeHash(stream)).Replace(, ).ToLower();
        }
    }
    public class ImageSteganography
    {
        public enum State
        {
            Hiding,
            Filling_With_Zeros
        };
        public static void embedText(string text, string inputImagePath)
        {
            string originalFilePath = inputImagePath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);","Bitmap bmp = new Bitmap(inputImagePath);
            State state = State.Hiding;
            int charIndex = 0;","int charValue = 0;
            long pixelElementIndex = 0;
            int zeros = 0;
            int R = 0, G = 0, B = 0;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                { 
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    R = pixel.R - pixel.R % 2;
                    G = pixel.G - pixel.G % 2;
                    B = pixel.B - pixel.B % 2;
                    for (int n = 0; n < 3; n++)
                    {
                        if (pixelElementIndex % 8 == 0)
                        { 
                            if (state == State.Filling_With_Zeros && zeros == 8)
                            {
                                if ((pixelElementIndex - 1) % 3 < 2)
                                {
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                bmp.Save(newFilePath, ImageFormat.Png);
                            }
                            if (charIndex >= text.Length)
                            {
                                state = State.Filling_With_Zeros;
                            }
                            else
                            {
                                charValue = text[charIndex++];
                            }
                        }
                        switch (pixelElementIndex % 3)
                        {
                            case 0:
                                {
                                    if (state == State.Hiding)
                                    {
                                        R += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 1:
                                {
                                    if (state == State.Hiding)
                                    {
                                        G += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 2:
                                {
                                    if (state == State.Hiding)
                                    {
                                        B += charValue % 2;
                                        charValue /= 2;
                                    }
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                break;
                        }
                        pixelElementIndex++;
                        if (state == State.Filling_With_Zeros)
                        {
                            zeros++;
                        }
                    }
                }
            }
            bmp.Save(newFilePath, ImageFormat.Png);
        }
        public static string extractText(Bitmap bmp)
        {
            int colorUnitIndex = 0;
            int charValue = 0;
            string extractedText = String.Empty;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                {
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    for (int n = 0; n < 3; n++)
                    {
                        switch (colorUnitIndex % 3)
                        {
                            case 0:
                                {
                                    charValue = charValue * 2 + pixel.R % 2;
                                }
                                break;
                            case 1:
                                {
                                    charValue = charValue * 2 + pixel.G % 2;
                                }
                                break;
                            case 2:
                                {
                                    charValue = charValue * 2 + pixel.B % 2;
                                }
                                break;
                        }
                        colorUnitIndex++;
                        if (colorUnitIndex % 8 == 0)
                        {
                            charValue = reverseBits(charValue);
                            if (charValue == 0)
                            {
                                return extractedText;
                            }
                            char c = (char)charValue;
                            extractedText += c.ToString();
                        }
                    }
                }
            }
            return extractedText;
        }
        public static int reverseBits(int n)
        {
            int result = 0;
            for (int i = 0; i < 8; i++)
            {
                result = result * 2 + n % 2;
                n /= 2;
            }
            return result;
        }
    }
    class AudioSteganography
    {
        const int HEADER_SIZE = 4; 
        const int BYTE_INTERVAL = 16; 
        public static void HideMessageInAudio(string inputAudioPath, string message)
        {
            byte[] messageBytes = Encoding.ASCII.GetBytes(message);
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes.Length >> (i * 8 + j)) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit); 
                    audioIndex += BYTE_INTERVAL;
                }
            }
            for (int i = 0; i < messageBytes.Length; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes[i] >> j) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            string originalFilePath = inputAudioPath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            File.WriteAllBytes(newFilePath, audioBytes);
        }
        public static string ExtractMessageFromAudio(string inputAudioPath)
        {
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            int messageLength = 0;
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageLength |= (bit << (i * 8 + j));
                    audioIndex += BYTE_INTERVAL;
                }
            }
            byte[] messageBytes = new byte[messageLength];
            for (int i = 0; i < messageLength; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageBytes[i] |= (byte)(bit << j);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            return Encoding.ASCII.GetString(messageBytes);
        }
    }
    public class DigitalSignature
    {
        static RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(2048);
        static RSAParameters publicKey;
        static RSAParameters privateKey;
        public static void GenerateKeys(string publicKeyPath)
        {
            publicKey = rsa.ExportParameters(false);
            privateKey = rsa.ExportParameters(true);
            var publicKeyXml = rsa.ToXmlString(false);
            var privateKeyXml = rsa.ToXmlString(true);
            var publicKeyFullPath = Path.Combine(publicKeyPath, );
            var privateKeyFullPath = Path.Combine(publicKeyPath, );
            File.WriteAllText(publicKeyFullPath, publicKeyXml);
            File.WriteAllText(privateKeyFullPath, privateKeyXml);
            AnsiConsole.MarkupLine($);
        }
        public static void UploadKeys(string privateKeyPath)
        {
            var privateKeyXml = File.ReadAllText(privateKeyPath);
            rsa.FromXmlString(privateKeyXml);
            privateKey = rsa.ExportParameters(true);
        }
        public static void SignDocument(string documentPath)
        {
            if (privateKey.D == null)
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            if (!File.Exists(documentPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = SignData(data, privateKey);
            var signaturePath = documentPath + ;
            File.WriteAllBytes(signaturePath, signature);
            AnsiConsole.MarkupLine($);
        }
        public static void VerifyDocumentSignature(string documentPath, string signaturePath, string publicKeyPath)
        {
            if (!File.Exists(publicKeyPath))
            {
                Console.WriteLine();
                return;
            }
            var publicKeyXml = File.ReadAllText(publicKeyPath);
            rsa.FromXmlString(publicKeyXml);
            if (!File.Exists(signaturePath))
            {
                Console.WriteLine();
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = File.ReadAllBytes(signaturePath);
            var isVerified = VerifyData(data, signature);
            AnsiConsole.MarkupLine($);
        }
        public static byte[] SignData(byte[] data, RSAParameters privateKey)
        {
            rsa.ImportParameters(privateKey);
            var signedData = rsa.SignData(data, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            return signedData;
        }
        static bool VerifyData(byte[] data, byte[] signature)
        {
            return rsa.VerifyData(data, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
        }
    }
    public class AesRsaEncryption
    {
        public static void EncryptFile(string inputFilePath, string outputFilePath, RSAParameters publicKey)
        {
            using (Aes aes = Aes.Create())
            {
                aes.GenerateKey();
                aes.GenerateIV();
                using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    byte[] buffer = new byte[1024];
                    int bytesRead;
                    while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                    {
                        cryptoStream.Write(buffer, 0, bytesRead);
                    }
                }
                using (RSA rsa = new RSACryptoServiceProvider())
                {
                    rsa.ImportParameters(publicKey);
                    byte[] encryptedKey = rsa.Encrypt(aes.Key, RSAEncryptionPadding.Pkcs1);
                    File.WriteAllBytes(outputFilePath + , encryptedKey.Concat(aes.IV).ToArray());
                }
            }
        }
        public static void DecryptFile(string inputFilePath, string keyFilePath, string outputFilePath, RSAParameters privateKey)
        {
            byte[] encryptedData = File.ReadAllBytes(keyFilePath);
            byte[] encryptedKey = encryptedData.Take(encryptedData.Length - 16).ToArray();
            byte[] iv = encryptedData.Skip(encryptedData.Length - 16).ToArray();
            using (RSA rsa = new RSACryptoServiceProvider())
            {
                rsa.ImportParameters(privateKey);
                byte[] decryptedKey = rsa.Decrypt(encryptedKey, RSAEncryptionPadding.Pkcs1);
                using (Aes aes = Aes.Create())
                {
                    aes.Key = decryptedKey;
                    aes.IV = iv;
                    using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                    using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                    using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        byte[] buffer = new byte[1024];
                        int bytesRead;
                        while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                        {
                            cryptoStream.Write(buffer, 0, bytesRead);
                        }
                    }
                }
            }
        }
    }
}",CryptoAlgorithmsImplementations.cs
"using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using Spectre.Console;
namespace Implementation
{
    public class PasswordGenerator
    {
        private static readonly string LowercaseChars = ;
        private static readonly string UppercaseChars = ;
        private static readonly string NumberChars = ;
        private static readonly string SpecialChars = ;
        public static string GeneratePassword(bool useLowercase, bool useUppercase, bool useNumbers, bool useSpecial, int length)
        {
            if (length <= 0 || (!useLowercase && !useUppercase && !useNumbers && !useSpecial))
            {
                throw new ArgumentException();
            }
            string charPool = (useLowercase ? LowercaseChars : ) +
                              (useUppercase ? UppercaseChars : ) +
                              (useNumbers ? NumberChars : ) +
                              (useSpecial ? SpecialChars : );
            var bytes = new byte[length];
            RandomNumberGenerator.Fill(bytes);
            return new string(bytes.Select(b => charPool[b % charPool.Length]).ToArray());
        }
    }
    public class EntropyCalculator
    {
        public static double CalculateStringEntropy(string input)
        {
            if (string.IsNullOrEmpty(input))
                return 0.0; 
            Dictionary<char, int> charCounts = new Dictionary<char, int>();
            foreach (char c in input)
            {
                if (charCounts.ContainsKey(c))
                    charCounts[c]++;
                else
                    charCounts[c] = 1;
            }
            double entropy = 0.0;
            int totalChars = input.Length;
            foreach (var count in charCounts.Values)
            {
                double probability = (double)count / totalChars;
                entropy += probability * Math.Log2(probability);
            }
            return -entropy;
        }
    }
    public class Encrypt
    {
        public static void EncryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16]; 
                RandomNumberGenerator.Fill(salt);
                int iterations = 100000;
                Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                aes.Key = pdb.GetBytes(32);
                aes.IV = pdb.GetBytes(16);
                using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                {
                    fsOutput.Write(salt, 0, salt.Length);
                    using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                    using (CryptoStream cs = new CryptoStream(fsOutput, aes.CreateEncryptor(), CryptoStreamMode.Write))
                    {
                        int data;
                        while ((data = fsInput.ReadByte()) != -1)
                        {
                            cs.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Decrypt
    {
        public static void DecryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16];
                using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                {
                    fsInput.Read(salt, 0, salt.Length);
                    int iterations = 100000;
                    Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                    aes.Key = pdb.GetBytes(32);
                    aes.IV = pdb.GetBytes(16);
                    using (CryptoStream cs = new CryptoStream(fsInput, aes.CreateDecryptor(), CryptoStreamMode.Read))
                    using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                    {
                        int data;
                        while ((data = cs.ReadByte()) != -1)
                        {
                            fsOutput.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Hashing
    {
        public static string HashingFileWithSHA256(string filePath)
        {
            using SHA256 sha256 = SHA256.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha256.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithSHA1(string filePath)
        {
            using SHA1 sha1 = SHA1.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha1.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithMD5(string filePath)
        {
            using MD5 md5 = MD5.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(md5.ComputeHash(stream)).Replace(, ).ToLower();
        }
    }
    public class ImageSteganography
    {
        public enum State
        {","Hiding,
            Filling_With_Zeros
        };","public static void embedText(string text, string inputImagePath)
        {
            string originalFilePath = inputImagePath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            Bitmap bmp = new Bitmap(inputImagePath);
            State state = State.Hiding;
            int charIndex = 0;
            int charValue = 0;
            long pixelElementIndex = 0;
            int zeros = 0;
            int R = 0, G = 0, B = 0;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                { 
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    R = pixel.R - pixel.R % 2;
                    G = pixel.G - pixel.G % 2;
                    B = pixel.B - pixel.B % 2;
                    for (int n = 0; n < 3; n++)
                    {
                        if (pixelElementIndex % 8 == 0)
                        { 
                            if (state == State.Filling_With_Zeros && zeros == 8)
                            {
                                if ((pixelElementIndex - 1) % 3 < 2)
                                {
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                bmp.Save(newFilePath, ImageFormat.Png);
                            }
                            if (charIndex >= text.Length)
                            {
                                state = State.Filling_With_Zeros;
                            }
                            else
                            {
                                charValue = text[charIndex++];
                            }
                        }
                        switch (pixelElementIndex % 3)
                        {
                            case 0:
                                {
                                    if (state == State.Hiding)
                                    {
                                        R += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 1:
                                {
                                    if (state == State.Hiding)
                                    {
                                        G += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 2:
                                {
                                    if (state == State.Hiding)
                                    {
                                        B += charValue % 2;
                                        charValue /= 2;
                                    }
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                break;
                        }
                        pixelElementIndex++;
                        if (state == State.Filling_With_Zeros)
                        {
                            zeros++;
                        }
                    }
                }
            }
            bmp.Save(newFilePath, ImageFormat.Png);
        }
        public static string extractText(Bitmap bmp)
        {
            int colorUnitIndex = 0;
            int charValue = 0;
            string extractedText = String.Empty;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                {
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    for (int n = 0; n < 3; n++)
                    {
                        switch (colorUnitIndex % 3)
                        {
                            case 0:
                                {
                                    charValue = charValue * 2 + pixel.R % 2;
                                }
                                break;
                            case 1:
                                {
                                    charValue = charValue * 2 + pixel.G % 2;
                                }
                                break;
                            case 2:
                                {
                                    charValue = charValue * 2 + pixel.B % 2;
                                }
                                break;
                        }
                        colorUnitIndex++;
                        if (colorUnitIndex % 8 == 0)
                        {
                            charValue = reverseBits(charValue);
                            if (charValue == 0)
                            {
                                return extractedText;
                            }
                            char c = (char)charValue;
                            extractedText += c.ToString();
                        }
                    }
                }
            }
            return extractedText;
        }
        public static int reverseBits(int n)
        {
            int result = 0;
            for (int i = 0; i < 8; i++)
            {
                result = result * 2 + n % 2;
                n /= 2;
            }
            return result;
        }
    }
    class AudioSteganography
    {
        const int HEADER_SIZE = 4; 
        const int BYTE_INTERVAL = 16; 
        public static void HideMessageInAudio(string inputAudioPath, string message)
        {
            byte[] messageBytes = Encoding.ASCII.GetBytes(message);
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes.Length >> (i * 8 + j)) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit); 
                    audioIndex += BYTE_INTERVAL;
                }
            }
            for (int i = 0; i < messageBytes.Length; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes[i] >> j) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            string originalFilePath = inputAudioPath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            File.WriteAllBytes(newFilePath, audioBytes);
        }
        public static string ExtractMessageFromAudio(string inputAudioPath)
        {
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            int messageLength = 0;
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageLength |= (bit << (i * 8 + j));
                    audioIndex += BYTE_INTERVAL;
                }
            }
            byte[] messageBytes = new byte[messageLength];
            for (int i = 0; i < messageLength; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageBytes[i] |= (byte)(bit << j);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            return Encoding.ASCII.GetString(messageBytes);
        }
    }
    public class DigitalSignature
    {
        static RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(2048);
        static RSAParameters publicKey;
        static RSAParameters privateKey;
        public static void GenerateKeys(string publicKeyPath)
        {
            publicKey = rsa.ExportParameters(false);
            privateKey = rsa.ExportParameters(true);
            var publicKeyXml = rsa.ToXmlString(false);
            var privateKeyXml = rsa.ToXmlString(true);
            var publicKeyFullPath = Path.Combine(publicKeyPath, );
            var privateKeyFullPath = Path.Combine(publicKeyPath, );
            File.WriteAllText(publicKeyFullPath, publicKeyXml);
            File.WriteAllText(privateKeyFullPath, privateKeyXml);
            AnsiConsole.MarkupLine($);
        }
        public static void UploadKeys(string privateKeyPath)
        {
            var privateKeyXml = File.ReadAllText(privateKeyPath);
            rsa.FromXmlString(privateKeyXml);
            privateKey = rsa.ExportParameters(true);
        }
        public static void SignDocument(string documentPath)
        {
            if (privateKey.D == null)
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            if (!File.Exists(documentPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = SignData(data, privateKey);
            var signaturePath = documentPath + ;
            File.WriteAllBytes(signaturePath, signature);
            AnsiConsole.MarkupLine($);
        }
        public static void VerifyDocumentSignature(string documentPath, string signaturePath, string publicKeyPath)
        {
            if (!File.Exists(publicKeyPath))
            {
                Console.WriteLine();
                return;
            }
            var publicKeyXml = File.ReadAllText(publicKeyPath);
            rsa.FromXmlString(publicKeyXml);
            if (!File.Exists(signaturePath))
            {
                Console.WriteLine();
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = File.ReadAllBytes(signaturePath);
            var isVerified = VerifyData(data, signature);
            AnsiConsole.MarkupLine($);
        }
        public static byte[] SignData(byte[] data, RSAParameters privateKey)
        {
            rsa.ImportParameters(privateKey);
            var signedData = rsa.SignData(data, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            return signedData;
        }
        static bool VerifyData(byte[] data, byte[] signature)
        {
            return rsa.VerifyData(data, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
        }
    }
    public class AesRsaEncryption
    {
        public static void EncryptFile(string inputFilePath, string outputFilePath, RSAParameters publicKey)
        {
            using (Aes aes = Aes.Create())
            {
                aes.GenerateKey();
                aes.GenerateIV();
                using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    byte[] buffer = new byte[1024];
                    int bytesRead;
                    while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                    {
                        cryptoStream.Write(buffer, 0, bytesRead);
                    }
                }
                using (RSA rsa = new RSACryptoServiceProvider())
                {
                    rsa.ImportParameters(publicKey);
                    byte[] encryptedKey = rsa.Encrypt(aes.Key, RSAEncryptionPadding.Pkcs1);
                    File.WriteAllBytes(outputFilePath + , encryptedKey.Concat(aes.IV).ToArray());
                }
            }
        }
        public static void DecryptFile(string inputFilePath, string keyFilePath, string outputFilePath, RSAParameters privateKey)
        {
            byte[] encryptedData = File.ReadAllBytes(keyFilePath);
            byte[] encryptedKey = encryptedData.Take(encryptedData.Length - 16).ToArray();
            byte[] iv = encryptedData.Skip(encryptedData.Length - 16).ToArray();
            using (RSA rsa = new RSACryptoServiceProvider())
            {
                rsa.ImportParameters(privateKey);
                byte[] decryptedKey = rsa.Decrypt(encryptedKey, RSAEncryptionPadding.Pkcs1);
                using (Aes aes = Aes.Create())
                {
                    aes.Key = decryptedKey;
                    aes.IV = iv;
                    using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                    using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                    using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        byte[] buffer = new byte[1024];
                        int bytesRead;
                        while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                        {
                            cryptoStream.Write(buffer, 0, bytesRead);
                        }
                    }
                }
            }
        }
    }
}",CryptoAlgorithmsImplementations.cs
"using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using Spectre.Console;
namespace Implementation
{
    public class PasswordGenerator
    {
        private static readonly string LowercaseChars = ;
        private static readonly string UppercaseChars = ;
        private static readonly string NumberChars = ;
        private static readonly string SpecialChars = ;
        public static string GeneratePassword(bool useLowercase, bool useUppercase, bool useNumbers, bool useSpecial, int length)
        {
            if (length <= 0 || (!useLowercase && !useUppercase && !useNumbers && !useSpecial))
            {
                throw new ArgumentException();
            }
            string charPool = (useLowercase ? LowercaseChars : ) +
                              (useUppercase ? UppercaseChars : ) +
                              (useNumbers ? NumberChars : ) +
                              (useSpecial ? SpecialChars : );
            var bytes = new byte[length];
            RandomNumberGenerator.Fill(bytes);
            return new string(bytes.Select(b => charPool[b % charPool.Length]).ToArray());
        }
    }
    public class EntropyCalculator
    {
        public static double CalculateStringEntropy(string input)
        {
            if (string.IsNullOrEmpty(input))
                return 0.0; 
            Dictionary<char, int> charCounts = new Dictionary<char, int>();
            foreach (char c in input)
            {
                if (charCounts.ContainsKey(c))
                    charCounts[c]++;
                else
                    charCounts[c] = 1;
            }
            double entropy = 0.0;
            int totalChars = input.Length;
            foreach (var count in charCounts.Values)
            {
                double probability = (double)count / totalChars;
                entropy += probability * Math.Log2(probability);
            }
            return -entropy;
        }
    }
    public class Encrypt
    {
        public static void EncryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16]; 
                RandomNumberGenerator.Fill(salt);
                int iterations = 100000;
                Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                aes.Key = pdb.GetBytes(32);
                aes.IV = pdb.GetBytes(16);
                using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                {
                    fsOutput.Write(salt, 0, salt.Length);
                    using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                    using (CryptoStream cs = new CryptoStream(fsOutput, aes.CreateEncryptor(), CryptoStreamMode.Write))
                    {
                        int data;
                        while ((data = fsInput.ReadByte()) != -1)
                        {
                            cs.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Decrypt
    {
        public static void DecryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16];
                using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                {
                    fsInput.Read(salt, 0, salt.Length);
                    int iterations = 100000;
                    Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                    aes.Key = pdb.GetBytes(32);
                    aes.IV = pdb.GetBytes(16);
                    using (CryptoStream cs = new CryptoStream(fsInput, aes.CreateDecryptor(), CryptoStreamMode.Read))
                    using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                    {
                        int data;
                        while ((data = cs.ReadByte()) != -1)
                        {
                            fsOutput.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Hashing
    {
        public static string HashingFileWithSHA256(string filePath)
        {
            using SHA256 sha256 = SHA256.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha256.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithSHA1(string filePath)
        {
            using SHA1 sha1 = SHA1.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha1.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithMD5(string filePath)
        {
            using MD5 md5 = MD5.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(md5.ComputeHash(stream)).Replace(, ).ToLower();
        }
    }
    public class ImageSteganography
    {
        public enum State
        {
            Hiding,
            Filling_With_Zeros
        };
        public static void embedText(string text, string inputImagePath)
        {
            string originalFilePath = inputImagePath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            Bitmap bmp = new Bitmap(inputImagePath);
            State state = State.Hiding;
            int charIndex = 0;
            int charValue = 0;
            long pixelElementIndex = 0;
            int zeros = 0;
            int R = 0, G = 0, B = 0;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                { 
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    R = pixel.R - pixel.R % 2;
                    G = pixel.G - pixel.G % 2;
                    B = pixel.B - pixel.B % 2;
                    for (int n = 0; n < 3; n++)
                    {
                        if (pixelElementIndex % 8 == 0)
                        { 
                            if (state == State.Filling_With_Zeros && zeros == 8)
                            {
                                if ((pixelElementIndex - 1) % 3 < 2)
                                {
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                bmp.Save(newFilePath, ImageFormat.Png);
                            }
                            if (charIndex >= text.Length)
                            {
                                state = State.Filling_With_Zeros;
                            }
                            else
                            {
                                charValue = text[charIndex++];
                            }
                        }
                        switch (pixelElementIndex % 3)
                        {
                            case 0:
                                {
                                    if (state == State.Hiding)
                                    {
                                        R += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 1:
                                {
                                    if (state == State.Hiding)
                                    {
                                        G += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 2:
                                {
                                    if (state == State.Hiding)
                                    {
                                        B += charValue % 2;
                                        charValue /= 2;
                                    }
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                break;
                        }
                        pixelElementIndex++;
                        if (state == State.Filling_With_Zeros)
                        {
                            zeros++;
                        }
                    }
                }
            }
            bmp.Save(newFilePath, ImageFormat.Png);
        }
        public static string extractText(Bitmap bmp)
        {
            int colorUnitIndex = 0;
            int charValue = 0;
            string extractedText = String.Empty;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                {
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    for (int n = 0; n < 3; n++)
                    {
                        switch (colorUnitIndex % 3)
                        {
                            case 0:
                                {
                                    charValue = charValue * 2 + pixel.R % 2;
                                }
                                break;
                            case 1:
                                {
                                    charValue = charValue * 2 + pixel.G % 2;
                                }
                                break;
                            case 2:
                                {
                                    charValue = charValue * 2 + pixel.B % 2;
                                }
                                break;
                        }
                        colorUnitIndex++;
                        if (colorUnitIndex % 8 == 0)
                        {
                            charValue = reverseBits(charValue);
                            if (charValue == 0)
                            {
                                return extractedText;
                            }
                            char c = (char)charValue;
                            extractedText += c.ToString();
                        }
                    }
                }
            }
            return extractedText;
        }
        public static int reverseBits(int n)
        {
            int result = 0;
            for (int i = 0; i < 8; i++)
            {
                result = result * 2 + n % 2;
                n /= 2;
            }
            return result;
        }
    }
    class AudioSteganography
    {
        const int HEADER_SIZE = 4; 
        const int BYTE_INTERVAL = 16; 
        public static void HideMessageInAudio(string inputAudioPath, string message)
        {
            byte[] messageBytes = Encoding.ASCII.GetBytes(message);
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes.Length >> (i * 8 + j)) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit); 
                    audioIndex += BYTE_INTERVAL;
                }
            }
            for (int i = 0; i < messageBytes.Length; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes[i] >> j) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            string originalFilePath = inputAudioPath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            File.WriteAllBytes(newFilePath, audioBytes);
        }
        public static string ExtractMessageFromAudio(string inputAudioPath)
        {
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            int messageLength = 0;
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageLength |= (bit << (i * 8 + j));
                    audioIndex += BYTE_INTERVAL;
                }
            }
            byte[] messageBytes = new byte[messageLength];
            for (int i = 0; i < messageLength; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageBytes[i] |= (byte)(bit << j);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            return Encoding.ASCII.GetString(messageBytes);
        }
    }
    public class DigitalSignature
    {
        static RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(2048);
        static RSAParameters publicKey;
        static RSAParameters privateKey;
        public static void GenerateKeys(string publicKeyPath)
        {
            publicKey = rsa.ExportParameters(false);
            privateKey = rsa.ExportParameters(true);
            var publicKeyXml = rsa.ToXmlString(false);
            var privateKeyXml = rsa.ToXmlString(true);
            var publicKeyFullPath = Path.Combine(publicKeyPath, );
            var privateKeyFullPath = Path.Combine(publicKeyPath, );
            File.WriteAllText(publicKeyFullPath, publicKeyXml);
            File.WriteAllText(privateKeyFullPath, privateKeyXml);
            AnsiConsole.MarkupLine($);
        }
        public static void UploadKeys(string privateKeyPath)
        {
            var privateKeyXml = File.ReadAllText(privateKeyPath);
            rsa.FromXmlString(privateKeyXml);
            privateKey = rsa.ExportParameters(true);
        }
        public static void SignDocument(string documentPath)
        {
            if (privateKey.D == null)
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            if (!File.Exists(documentPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = SignData(data, privateKey);
            var signaturePath = documentPath + ;
            File.WriteAllBytes(signaturePath, signature);
            AnsiConsole.MarkupLine($);
        }
        public static void VerifyDocumentSignature(string documentPath, string signaturePath, string publicKeyPath)
        {
            if (!File.Exists(publicKeyPath))
            {
                Console.WriteLine();
                return;
            }
            var publicKeyXml = File.ReadAllText(publicKeyPath);
            rsa.FromXmlString(publicKeyXml);
            if (!File.Exists(signaturePath))
            {
                Console.WriteLine();
                return;
            }","var data = File.ReadAllBytes(documentPath);
            var signature = File.ReadAllBytes(signaturePath);
            var isVerified = VerifyData(data, signature);","AnsiConsole.MarkupLine($);
        }
        public static byte[] SignData(byte[] data, RSAParameters privateKey)
        {
            rsa.ImportParameters(privateKey);
            var signedData = rsa.SignData(data, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            return signedData;
        }
        static bool VerifyData(byte[] data, byte[] signature)
        {
            return rsa.VerifyData(data, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
        }
    }
    public class AesRsaEncryption
    {
        public static void EncryptFile(string inputFilePath, string outputFilePath, RSAParameters publicKey)
        {
            using (Aes aes = Aes.Create())
            {
                aes.GenerateKey();
                aes.GenerateIV();
                using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    byte[] buffer = new byte[1024];
                    int bytesRead;
                    while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                    {
                        cryptoStream.Write(buffer, 0, bytesRead);
                    }
                }
                using (RSA rsa = new RSACryptoServiceProvider())
                {
                    rsa.ImportParameters(publicKey);
                    byte[] encryptedKey = rsa.Encrypt(aes.Key, RSAEncryptionPadding.Pkcs1);
                    File.WriteAllBytes(outputFilePath + , encryptedKey.Concat(aes.IV).ToArray());
                }
            }
        }
        public static void DecryptFile(string inputFilePath, string keyFilePath, string outputFilePath, RSAParameters privateKey)
        {
            byte[] encryptedData = File.ReadAllBytes(keyFilePath);
            byte[] encryptedKey = encryptedData.Take(encryptedData.Length - 16).ToArray();
            byte[] iv = encryptedData.Skip(encryptedData.Length - 16).ToArray();
            using (RSA rsa = new RSACryptoServiceProvider())
            {
                rsa.ImportParameters(privateKey);
                byte[] decryptedKey = rsa.Decrypt(encryptedKey, RSAEncryptionPadding.Pkcs1);
                using (Aes aes = Aes.Create())
                {
                    aes.Key = decryptedKey;
                    aes.IV = iv;
                    using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                    using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                    using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        byte[] buffer = new byte[1024];
                        int bytesRead;
                        while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                        {
                            cryptoStream.Write(buffer, 0, bytesRead);
                        }
                    }
                }
            }
        }
    }
}",CryptoAlgorithmsImplementations.cs
"using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using Spectre.Console;
namespace Implementation
{
    public class PasswordGenerator
    {
        private static readonly string LowercaseChars = ;
        private static readonly string UppercaseChars = ;
        private static readonly string NumberChars = ;
        private static readonly string SpecialChars = ;
        public static string GeneratePassword(bool useLowercase, bool useUppercase, bool useNumbers, bool useSpecial, int length)
        {
            if (length <= 0 || (!useLowercase && !useUppercase && !useNumbers && !useSpecial))
            {
                throw new ArgumentException();
            }
            string charPool = (useLowercase ? LowercaseChars : ) +
                              (useUppercase ? UppercaseChars : ) +
                              (useNumbers ? NumberChars : ) +
                              (useSpecial ? SpecialChars : );
            var bytes = new byte[length];
            RandomNumberGenerator.Fill(bytes);
            return new string(bytes.Select(b => charPool[b % charPool.Length]).ToArray());
        }
    }
    public class EntropyCalculator
    {
        public static double CalculateStringEntropy(string input)
        {
            if (string.IsNullOrEmpty(input))
                return 0.0; 
            Dictionary<char, int> charCounts = new Dictionary<char, int>();
            foreach (char c in input)
            {
                if (charCounts.ContainsKey(c))
                    charCounts[c]++;
                else
                    charCounts[c] = 1;
            }
            double entropy = 0.0;
            int totalChars = input.Length;
            foreach (var count in charCounts.Values)
            {
                double probability = (double)count / totalChars;
                entropy += probability * Math.Log2(probability);
            }
            return -entropy;
        }
    }
    public class Encrypt
    {
        public static void EncryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16]; 
                RandomNumberGenerator.Fill(salt);
                int iterations = 100000;
                Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                aes.Key = pdb.GetBytes(32);
                aes.IV = pdb.GetBytes(16);
                using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                {
                    fsOutput.Write(salt, 0, salt.Length);
                    using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                    using (CryptoStream cs = new CryptoStream(fsOutput, aes.CreateEncryptor(), CryptoStreamMode.Write))
                    {
                        int data;
                        while ((data = fsInput.ReadByte()) != -1)
                        {
                            cs.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Decrypt
    {
        public static void DecryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16];
                using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                {
                    fsInput.Read(salt, 0, salt.Length);
                    int iterations = 100000;
                    Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                    aes.Key = pdb.GetBytes(32);
                    aes.IV = pdb.GetBytes(16);
                    using (CryptoStream cs = new CryptoStream(fsInput, aes.CreateDecryptor(), CryptoStreamMode.Read))
                    using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                    {
                        int data;
                        while ((data = cs.ReadByte()) != -1)
                        {
                            fsOutput.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Hashing
    {
        public static string HashingFileWithSHA256(string filePath)
        {
            using SHA256 sha256 = SHA256.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha256.ComputeHash(stream)).Replace(, ).ToLower();","}
        public static string HashFileWithSHA1(string filePath)
        {","using SHA1 sha1 = SHA1.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha1.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithMD5(string filePath)
        {
            using MD5 md5 = MD5.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(md5.ComputeHash(stream)).Replace(, ).ToLower();
        }
    }
    public class ImageSteganography
    {
        public enum State
        {
            Hiding,
            Filling_With_Zeros
        };
        public static void embedText(string text, string inputImagePath)
        {
            string originalFilePath = inputImagePath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            Bitmap bmp = new Bitmap(inputImagePath);
            State state = State.Hiding;
            int charIndex = 0;
            int charValue = 0;
            long pixelElementIndex = 0;
            int zeros = 0;
            int R = 0, G = 0, B = 0;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                { 
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    R = pixel.R - pixel.R % 2;
                    G = pixel.G - pixel.G % 2;
                    B = pixel.B - pixel.B % 2;
                    for (int n = 0; n < 3; n++)
                    {
                        if (pixelElementIndex % 8 == 0)
                        { 
                            if (state == State.Filling_With_Zeros && zeros == 8)
                            {
                                if ((pixelElementIndex - 1) % 3 < 2)
                                {
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                bmp.Save(newFilePath, ImageFormat.Png);
                            }
                            if (charIndex >= text.Length)
                            {
                                state = State.Filling_With_Zeros;
                            }
                            else
                            {
                                charValue = text[charIndex++];
                            }
                        }
                        switch (pixelElementIndex % 3)
                        {
                            case 0:
                                {
                                    if (state == State.Hiding)
                                    {
                                        R += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 1:
                                {
                                    if (state == State.Hiding)
                                    {
                                        G += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 2:
                                {
                                    if (state == State.Hiding)
                                    {
                                        B += charValue % 2;
                                        charValue /= 2;
                                    }
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                break;
                        }
                        pixelElementIndex++;
                        if (state == State.Filling_With_Zeros)
                        {
                            zeros++;
                        }
                    }
                }
            }
            bmp.Save(newFilePath, ImageFormat.Png);
        }
        public static string extractText(Bitmap bmp)
        {
            int colorUnitIndex = 0;
            int charValue = 0;
            string extractedText = String.Empty;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                {
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    for (int n = 0; n < 3; n++)
                    {
                        switch (colorUnitIndex % 3)
                        {
                            case 0:
                                {
                                    charValue = charValue * 2 + pixel.R % 2;
                                }
                                break;
                            case 1:
                                {
                                    charValue = charValue * 2 + pixel.G % 2;
                                }
                                break;
                            case 2:
                                {
                                    charValue = charValue * 2 + pixel.B % 2;
                                }
                                break;
                        }
                        colorUnitIndex++;
                        if (colorUnitIndex % 8 == 0)
                        {
                            charValue = reverseBits(charValue);
                            if (charValue == 0)
                            {
                                return extractedText;
                            }
                            char c = (char)charValue;
                            extractedText += c.ToString();
                        }
                    }
                }
            }
            return extractedText;
        }
        public static int reverseBits(int n)
        {
            int result = 0;
            for (int i = 0; i < 8; i++)
            {
                result = result * 2 + n % 2;
                n /= 2;
            }
            return result;
        }
    }
    class AudioSteganography
    {
        const int HEADER_SIZE = 4; 
        const int BYTE_INTERVAL = 16; 
        public static void HideMessageInAudio(string inputAudioPath, string message)
        {
            byte[] messageBytes = Encoding.ASCII.GetBytes(message);
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes.Length >> (i * 8 + j)) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit); 
                    audioIndex += BYTE_INTERVAL;
                }
            }
            for (int i = 0; i < messageBytes.Length; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes[i] >> j) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            string originalFilePath = inputAudioPath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            File.WriteAllBytes(newFilePath, audioBytes);
        }
        public static string ExtractMessageFromAudio(string inputAudioPath)
        {
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            int messageLength = 0;
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageLength |= (bit << (i * 8 + j));
                    audioIndex += BYTE_INTERVAL;
                }
            }
            byte[] messageBytes = new byte[messageLength];
            for (int i = 0; i < messageLength; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageBytes[i] |= (byte)(bit << j);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            return Encoding.ASCII.GetString(messageBytes);
        }
    }
    public class DigitalSignature
    {
        static RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(2048);
        static RSAParameters publicKey;
        static RSAParameters privateKey;
        public static void GenerateKeys(string publicKeyPath)
        {
            publicKey = rsa.ExportParameters(false);
            privateKey = rsa.ExportParameters(true);
            var publicKeyXml = rsa.ToXmlString(false);
            var privateKeyXml = rsa.ToXmlString(true);
            var publicKeyFullPath = Path.Combine(publicKeyPath, );
            var privateKeyFullPath = Path.Combine(publicKeyPath, );
            File.WriteAllText(publicKeyFullPath, publicKeyXml);
            File.WriteAllText(privateKeyFullPath, privateKeyXml);
            AnsiConsole.MarkupLine($);
        }
        public static void UploadKeys(string privateKeyPath)
        {
            var privateKeyXml = File.ReadAllText(privateKeyPath);
            rsa.FromXmlString(privateKeyXml);
            privateKey = rsa.ExportParameters(true);
        }
        public static void SignDocument(string documentPath)
        {
            if (privateKey.D == null)
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            if (!File.Exists(documentPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = SignData(data, privateKey);
            var signaturePath = documentPath + ;
            File.WriteAllBytes(signaturePath, signature);
            AnsiConsole.MarkupLine($);
        }
        public static void VerifyDocumentSignature(string documentPath, string signaturePath, string publicKeyPath)
        {
            if (!File.Exists(publicKeyPath))
            {
                Console.WriteLine();
                return;
            }
            var publicKeyXml = File.ReadAllText(publicKeyPath);
            rsa.FromXmlString(publicKeyXml);
            if (!File.Exists(signaturePath))
            {
                Console.WriteLine();
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = File.ReadAllBytes(signaturePath);
            var isVerified = VerifyData(data, signature);
            AnsiConsole.MarkupLine($);
        }
        public static byte[] SignData(byte[] data, RSAParameters privateKey)
        {
            rsa.ImportParameters(privateKey);
            var signedData = rsa.SignData(data, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            return signedData;
        }
        static bool VerifyData(byte[] data, byte[] signature)
        {
            return rsa.VerifyData(data, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
        }
    }
    public class AesRsaEncryption
    {
        public static void EncryptFile(string inputFilePath, string outputFilePath, RSAParameters publicKey)
        {
            using (Aes aes = Aes.Create())
            {
                aes.GenerateKey();
                aes.GenerateIV();
                using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    byte[] buffer = new byte[1024];
                    int bytesRead;
                    while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                    {
                        cryptoStream.Write(buffer, 0, bytesRead);
                    }
                }
                using (RSA rsa = new RSACryptoServiceProvider())
                {
                    rsa.ImportParameters(publicKey);
                    byte[] encryptedKey = rsa.Encrypt(aes.Key, RSAEncryptionPadding.Pkcs1);
                    File.WriteAllBytes(outputFilePath + , encryptedKey.Concat(aes.IV).ToArray());
                }
            }
        }
        public static void DecryptFile(string inputFilePath, string keyFilePath, string outputFilePath, RSAParameters privateKey)
        {
            byte[] encryptedData = File.ReadAllBytes(keyFilePath);
            byte[] encryptedKey = encryptedData.Take(encryptedData.Length - 16).ToArray();
            byte[] iv = encryptedData.Skip(encryptedData.Length - 16).ToArray();
            using (RSA rsa = new RSACryptoServiceProvider())
            {
                rsa.ImportParameters(privateKey);
                byte[] decryptedKey = rsa.Decrypt(encryptedKey, RSAEncryptionPadding.Pkcs1);
                using (Aes aes = Aes.Create())
                {
                    aes.Key = decryptedKey;
                    aes.IV = iv;
                    using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                    using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                    using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        byte[] buffer = new byte[1024];
                        int bytesRead;
                        while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                        {
                            cryptoStream.Write(buffer, 0, bytesRead);
                        }
                    }
                }
            }
        }
    }
}",CryptoAlgorithmsImplementations.cs
"using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using Spectre.Console;
namespace Implementation
{
    public class PasswordGenerator
    {
        private static readonly string LowercaseChars = ;
        private static readonly string UppercaseChars = ;
        private static readonly string NumberChars = ;
        private static readonly string SpecialChars = ;
        public static string GeneratePassword(bool useLowercase, bool useUppercase, bool useNumbers, bool useSpecial, int length)
        {
            if (length <= 0 || (!useLowercase && !useUppercase && !useNumbers && !useSpecial))
            {
                throw new ArgumentException();
            }
            string charPool = (useLowercase ? LowercaseChars : ) +
                              (useUppercase ? UppercaseChars : ) +
                              (useNumbers ? NumberChars : ) +
                              (useSpecial ? SpecialChars : );
            var bytes = new byte[length];
            RandomNumberGenerator.Fill(bytes);
            return new string(bytes.Select(b => charPool[b % charPool.Length]).ToArray());
        }
    }
    public class EntropyCalculator
    {
        public static double CalculateStringEntropy(string input)
        {
            if (string.IsNullOrEmpty(input))
                return 0.0; 
            Dictionary<char, int> charCounts = new Dictionary<char, int>();
            foreach (char c in input)
            {
                if (charCounts.ContainsKey(c))
                    charCounts[c]++;
                else
                    charCounts[c] = 1;
            }
            double entropy = 0.0;
            int totalChars = input.Length;
            foreach (var count in charCounts.Values)
            {
                double probability = (double)count / totalChars;
                entropy += probability * Math.Log2(probability);
            }
            return -entropy;
        }
    }
    public class Encrypt
    {
        public static void EncryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16]; 
                RandomNumberGenerator.Fill(salt);
                int iterations = 100000;
                Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                aes.Key = pdb.GetBytes(32);
                aes.IV = pdb.GetBytes(16);
                using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                {
                    fsOutput.Write(salt, 0, salt.Length);
                    using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                    using (CryptoStream cs = new CryptoStream(fsOutput, aes.CreateEncryptor(), CryptoStreamMode.Write))
                    {
                        int data;
                        while ((data = fsInput.ReadByte()) != -1)
                        {
                            cs.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Decrypt
    {
        public static void DecryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16];
                using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                {
                    fsInput.Read(salt, 0, salt.Length);
                    int iterations = 100000;
                    Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                    aes.Key = pdb.GetBytes(32);
                    aes.IV = pdb.GetBytes(16);
                    using (CryptoStream cs = new CryptoStream(fsInput, aes.CreateDecryptor(), CryptoStreamMode.Read))
                    using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                    {
                        int data;
                        while ((data = cs.ReadByte()) != -1)
                        {
                            fsOutput.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Hashing
    {
        public static string HashingFileWithSHA256(string filePath)
        {
            using SHA256 sha256 = SHA256.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha256.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithSHA1(string filePath)
        {
            using SHA1 sha1 = SHA1.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha1.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithMD5(string filePath)
        {
            using MD5 md5 = MD5.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(md5.ComputeHash(stream)).Replace(, ).ToLower();
        }
    }
    public class ImageSteganography
    {
        public enum State
        {
            Hiding,
            Filling_With_Zeros
        };
        public static void embedText(string text, string inputImagePath)
        {
            string originalFilePath = inputImagePath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            Bitmap bmp = new Bitmap(inputImagePath);
            State state = State.Hiding;
            int charIndex = 0;
            int charValue = 0;
            long pixelElementIndex = 0;
            int zeros = 0;
            int R = 0, G = 0, B = 0;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                { 
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    R = pixel.R - pixel.R % 2;
                    G = pixel.G - pixel.G % 2;
                    B = pixel.B - pixel.B % 2;
                    for (int n = 0; n < 3; n++)
                    {
                        if (pixelElementIndex % 8 == 0)
                        { 
                            if (state == State.Filling_With_Zeros && zeros == 8)
                            {
                                if ((pixelElementIndex - 1) % 3 < 2)
                                {
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                bmp.Save(newFilePath, ImageFormat.Png);
                            }
                            if (charIndex >= text.Length)
                            {
                                state = State.Filling_With_Zeros;
                            }
                            else
                            {
                                charValue = text[charIndex++];
                            }
                        }
                        switch (pixelElementIndex % 3)
                        {
                            case 0:
                                {
                                    if (state == State.Hiding)
                                    {
                                        R += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 1:
                                {
                                    if (state == State.Hiding)
                                    {
                                        G += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 2:
                                {
                                    if (state == State.Hiding)
                                    {
                                        B += charValue % 2;
                                        charValue /= 2;
                                    }
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                break;
                        }
                        pixelElementIndex++;
                        if (state == State.Filling_With_Zeros)
                        {
                            zeros++;
                        }
                    }
                }
            }
            bmp.Save(newFilePath, ImageFormat.Png);
        }
        public static string extractText(Bitmap bmp)
        {
            int colorUnitIndex = 0;
            int charValue = 0;
            string extractedText = String.Empty;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                {
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    for (int n = 0; n < 3; n++)
                    {
                        switch (colorUnitIndex % 3)
                        {
                            case 0:
                                {
                                    charValue = charValue * 2 + pixel.R % 2;
                                }
                                break;
                            case 1:
                                {
                                    charValue = charValue * 2 + pixel.G % 2;
                                }
                                break;
                            case 2:
                                {
                                    charValue = charValue * 2 + pixel.B % 2;
                                }
                                break;
                        }
                        colorUnitIndex++;
                        if (colorUnitIndex % 8 == 0)
                        {
                            charValue = reverseBits(charValue);
                            if (charValue == 0)
                            {
                                return extractedText;
                            }
                            char c = (char)charValue;
                            extractedText += c.ToString();
                        }
                    }
                }
            }
            return extractedText;
        }
        public static int reverseBits(int n)
        {
            int result = 0;
            for (int i = 0; i < 8; i++)
            {
                result = result * 2 + n % 2;
                n /= 2;
            }
            return result;
        }
    }
    class AudioSteganography
    {
        const int HEADER_SIZE = 4; 
        const int BYTE_INTERVAL = 16; 
        public static void HideMessageInAudio(string inputAudioPath, string message)
        {
            byte[] messageBytes = Encoding.ASCII.GetBytes(message);
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes.Length >> (i * 8 + j)) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit); 
                    audioIndex += BYTE_INTERVAL;
                }
            }
            for (int i = 0; i < messageBytes.Length; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes[i] >> j) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            string originalFilePath = inputAudioPath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            File.WriteAllBytes(newFilePath, audioBytes);
        }
        public static string ExtractMessageFromAudio(string inputAudioPath)
        {
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            int messageLength = 0;
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageLength |= (bit << (i * 8 + j));
                    audioIndex += BYTE_INTERVAL;
                }
            }
            byte[] messageBytes = new byte[messageLength];
            for (int i = 0; i < messageLength; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageBytes[i] |= (byte)(bit << j);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            return Encoding.ASCII.GetString(messageBytes);
        }
    }
    public class DigitalSignature
    {
        static RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(2048);
        static RSAParameters publicKey;
        static RSAParameters privateKey;
        public static void GenerateKeys(string publicKeyPath)
        {
            publicKey = rsa.ExportParameters(false);
            privateKey = rsa.ExportParameters(true);
            var publicKeyXml = rsa.ToXmlString(false);
            var privateKeyXml = rsa.ToXmlString(true);
            var publicKeyFullPath = Path.Combine(publicKeyPath, );
            var privateKeyFullPath = Path.Combine(publicKeyPath, );
            File.WriteAllText(publicKeyFullPath, publicKeyXml);
            File.WriteAllText(privateKeyFullPath, privateKeyXml);
            AnsiConsole.MarkupLine($);
        }
        public static void UploadKeys(string privateKeyPath)
        {
            var privateKeyXml = File.ReadAllText(privateKeyPath);
            rsa.FromXmlString(privateKeyXml);
            privateKey = rsa.ExportParameters(true);
        }
        public static void SignDocument(string documentPath)
        {
            if (privateKey.D == null)
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            if (!File.Exists(documentPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = SignData(data, privateKey);
            var signaturePath = documentPath + ;
            File.WriteAllBytes(signaturePath, signature);
            AnsiConsole.MarkupLine($);
        }
        public static void VerifyDocumentSignature(string documentPath, string signaturePath, string publicKeyPath)
        {
            if (!File.Exists(publicKeyPath))
            {
                Console.WriteLine();
                return;
            }
            var publicKeyXml = File.ReadAllText(publicKeyPath);
            rsa.FromXmlString(publicKeyXml);
            if (!File.Exists(signaturePath))
            {
                Console.WriteLine();
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = File.ReadAllBytes(signaturePath);
            var isVerified = VerifyData(data, signature);
            AnsiConsole.MarkupLine($);
        }
        public static byte[] SignData(byte[] data, RSAParameters privateKey)
        {
            rsa.ImportParameters(privateKey);
            var signedData = rsa.SignData(data, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            return signedData;
        }
        static bool VerifyData(byte[] data, byte[] signature)
        {","return rsa.VerifyData(data, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
        }
    }","public class AesRsaEncryption
    {
        public static void EncryptFile(string inputFilePath, string outputFilePath, RSAParameters publicKey)
        {
            using (Aes aes = Aes.Create())
            {
                aes.GenerateKey();
                aes.GenerateIV();
                using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    byte[] buffer = new byte[1024];
                    int bytesRead;
                    while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                    {
                        cryptoStream.Write(buffer, 0, bytesRead);
                    }
                }
                using (RSA rsa = new RSACryptoServiceProvider())
                {
                    rsa.ImportParameters(publicKey);
                    byte[] encryptedKey = rsa.Encrypt(aes.Key, RSAEncryptionPadding.Pkcs1);
                    File.WriteAllBytes(outputFilePath + , encryptedKey.Concat(aes.IV).ToArray());
                }
            }
        }
        public static void DecryptFile(string inputFilePath, string keyFilePath, string outputFilePath, RSAParameters privateKey)
        {
            byte[] encryptedData = File.ReadAllBytes(keyFilePath);
            byte[] encryptedKey = encryptedData.Take(encryptedData.Length - 16).ToArray();
            byte[] iv = encryptedData.Skip(encryptedData.Length - 16).ToArray();
            using (RSA rsa = new RSACryptoServiceProvider())
            {
                rsa.ImportParameters(privateKey);
                byte[] decryptedKey = rsa.Decrypt(encryptedKey, RSAEncryptionPadding.Pkcs1);
                using (Aes aes = Aes.Create())
                {
                    aes.Key = decryptedKey;
                    aes.IV = iv;
                    using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                    using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                    using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        byte[] buffer = new byte[1024];
                        int bytesRead;
                        while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                        {
                            cryptoStream.Write(buffer, 0, bytesRead);
                        }
                    }
                }
            }
        }
    }
}",CryptoAlgorithmsImplementations.cs
"using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using Spectre.Console;
namespace Implementation
{
    public class PasswordGenerator
    {
        private static readonly string LowercaseChars = ;
        private static readonly string UppercaseChars = ;
        private static readonly string NumberChars = ;
        private static readonly string SpecialChars = ;
        public static string GeneratePassword(bool useLowercase, bool useUppercase, bool useNumbers, bool useSpecial, int length)
        {
            if (length <= 0 || (!useLowercase && !useUppercase && !useNumbers && !useSpecial))
            {
                throw new ArgumentException();
            }
            string charPool = (useLowercase ? LowercaseChars : ) +
                              (useUppercase ? UppercaseChars : ) +
                              (useNumbers ? NumberChars : ) +
                              (useSpecial ? SpecialChars : );
            var bytes = new byte[length];
            RandomNumberGenerator.Fill(bytes);
            return new string(bytes.Select(b => charPool[b % charPool.Length]).ToArray());
        }
    }
    public class EntropyCalculator
    {
        public static double CalculateStringEntropy(string input)
        {
            if (string.IsNullOrEmpty(input))
                return 0.0; 
            Dictionary<char, int> charCounts = new Dictionary<char, int>();
            foreach (char c in input)
            {
                if (charCounts.ContainsKey(c))
                    charCounts[c]++;
                else
                    charCounts[c] = 1;
            }
            double entropy = 0.0;
            int totalChars = input.Length;
            foreach (var count in charCounts.Values)
            {
                double probability = (double)count / totalChars;
                entropy += probability * Math.Log2(probability);
            }
            return -entropy;
        }
    }
    public class Encrypt
    {
        public static void EncryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16]; 
                RandomNumberGenerator.Fill(salt);
                int iterations = 100000;
                Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                aes.Key = pdb.GetBytes(32);
                aes.IV = pdb.GetBytes(16);
                using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                {
                    fsOutput.Write(salt, 0, salt.Length);
                    using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                    using (CryptoStream cs = new CryptoStream(fsOutput, aes.CreateEncryptor(), CryptoStreamMode.Write))
                    {
                        int data;
                        while ((data = fsInput.ReadByte()) != -1)
                        {
                            cs.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Decrypt
    {
        public static void DecryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16];
                using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                {
                    fsInput.Read(salt, 0, salt.Length);
                    int iterations = 100000;
                    Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                    aes.Key = pdb.GetBytes(32);
                    aes.IV = pdb.GetBytes(16);
                    using (CryptoStream cs = new CryptoStream(fsInput, aes.CreateDecryptor(), CryptoStreamMode.Read))
                    using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                    {
                        int data;
                        while ((data = cs.ReadByte()) != -1)
                        {
                            fsOutput.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Hashing
    {
        public static string HashingFileWithSHA256(string filePath)
        {
            using SHA256 sha256 = SHA256.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha256.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithSHA1(string filePath)
        {
            using SHA1 sha1 = SHA1.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha1.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithMD5(string filePath)
        {
            using MD5 md5 = MD5.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(md5.ComputeHash(stream)).Replace(, ).ToLower();
        }
    }
    public class ImageSteganography
    {
        public enum State
        {
            Hiding,
            Filling_With_Zeros
        };
        public static void embedText(string text, string inputImagePath)
        {
            string originalFilePath = inputImagePath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            Bitmap bmp = new Bitmap(inputImagePath);
            State state = State.Hiding;
            int charIndex = 0;
            int charValue = 0;
            long pixelElementIndex = 0;
            int zeros = 0;
            int R = 0, G = 0, B = 0;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                { 
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    R = pixel.R - pixel.R % 2;
                    G = pixel.G - pixel.G % 2;
                    B = pixel.B - pixel.B % 2;
                    for (int n = 0; n < 3; n++)
                    {
                        if (pixelElementIndex % 8 == 0)
                        { 
                            if (state == State.Filling_With_Zeros && zeros == 8)
                            {
                                if ((pixelElementIndex - 1) % 3 < 2)
                                {
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                bmp.Save(newFilePath, ImageFormat.Png);
                            }
                            if (charIndex >= text.Length)
                            {
                                state = State.Filling_With_Zeros;
                            }
                            else
                            {
                                charValue = text[charIndex++];
                            }
                        }
                        switch (pixelElementIndex % 3)
                        {
                            case 0:
                                {
                                    if (state == State.Hiding)
                                    {
                                        R += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 1:
                                {
                                    if (state == State.Hiding)
                                    {
                                        G += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 2:
                                {
                                    if (state == State.Hiding)
                                    {
                                        B += charValue % 2;
                                        charValue /= 2;
                                    }
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                break;
                        }
                        pixelElementIndex++;
                        if (state == State.Filling_With_Zeros)
                        {
                            zeros++;
                        }
                    }
                }
            }
            bmp.Save(newFilePath, ImageFormat.Png);
        }
        public static string extractText(Bitmap bmp)
        {
            int colorUnitIndex = 0;
            int charValue = 0;
            string extractedText = String.Empty;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                {
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    for (int n = 0; n < 3; n++)
                    {
                        switch (colorUnitIndex % 3)
                        {
                            case 0:
                                {
                                    charValue = charValue * 2 + pixel.R % 2;
                                }
                                break;
                            case 1:
                                {
                                    charValue = charValue * 2 + pixel.G % 2;
                                }
                                break;
                            case 2:
                                {
                                    charValue = charValue * 2 + pixel.B % 2;
                                }
                                break;
                        }
                        colorUnitIndex++;
                        if (colorUnitIndex % 8 == 0)
                        {
                            charValue = reverseBits(charValue);
                            if (charValue == 0)
                            {
                                return extractedText;
                            }
                            char c = (char)charValue;
                            extractedText += c.ToString();
                        }
                    }
                }
            }
            return extractedText;
        }
        public static int reverseBits(int n)
        {
            int result = 0;
            for (int i = 0; i < 8; i++)
            {
                result = result * 2 + n % 2;
                n /= 2;
            }
            return result;
        }
    }
    class AudioSteganography
    {
        const int HEADER_SIZE = 4; 
        const int BYTE_INTERVAL = 16; 
        public static void HideMessageInAudio(string inputAudioPath, string message)
        {
            byte[] messageBytes = Encoding.ASCII.GetBytes(message);
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes.Length >> (i * 8 + j)) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit); 
                    audioIndex += BYTE_INTERVAL;
                }
            }
            for (int i = 0; i < messageBytes.Length; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes[i] >> j) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            string originalFilePath = inputAudioPath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            File.WriteAllBytes(newFilePath, audioBytes);
        }
        public static string ExtractMessageFromAudio(string inputAudioPath)
        {
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            int messageLength = 0;
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageLength |= (bit << (i * 8 + j));
                    audioIndex += BYTE_INTERVAL;
                }
            }
            byte[] messageBytes = new byte[messageLength];
            for (int i = 0; i < messageLength; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageBytes[i] |= (byte)(bit << j);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            return Encoding.ASCII.GetString(messageBytes);
        }
    }
    public class DigitalSignature
    {
        static RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(2048);
        static RSAParameters publicKey;","static RSAParameters privateKey;
        public static void GenerateKeys(string publicKeyPath)
        {","publicKey = rsa.ExportParameters(false);
            privateKey = rsa.ExportParameters(true);
            var publicKeyXml = rsa.ToXmlString(false);
            var privateKeyXml = rsa.ToXmlString(true);
            var publicKeyFullPath = Path.Combine(publicKeyPath, );
            var privateKeyFullPath = Path.Combine(publicKeyPath, );
            File.WriteAllText(publicKeyFullPath, publicKeyXml);
            File.WriteAllText(privateKeyFullPath, privateKeyXml);
            AnsiConsole.MarkupLine($);
        }
        public static void UploadKeys(string privateKeyPath)
        {
            var privateKeyXml = File.ReadAllText(privateKeyPath);
            rsa.FromXmlString(privateKeyXml);
            privateKey = rsa.ExportParameters(true);
        }
        public static void SignDocument(string documentPath)
        {
            if (privateKey.D == null)
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            if (!File.Exists(documentPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = SignData(data, privateKey);
            var signaturePath = documentPath + ;
            File.WriteAllBytes(signaturePath, signature);
            AnsiConsole.MarkupLine($);
        }
        public static void VerifyDocumentSignature(string documentPath, string signaturePath, string publicKeyPath)
        {
            if (!File.Exists(publicKeyPath))
            {
                Console.WriteLine();
                return;
            }
            var publicKeyXml = File.ReadAllText(publicKeyPath);
            rsa.FromXmlString(publicKeyXml);
            if (!File.Exists(signaturePath))
            {
                Console.WriteLine();
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = File.ReadAllBytes(signaturePath);
            var isVerified = VerifyData(data, signature);
            AnsiConsole.MarkupLine($);
        }
        public static byte[] SignData(byte[] data, RSAParameters privateKey)
        {
            rsa.ImportParameters(privateKey);
            var signedData = rsa.SignData(data, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            return signedData;
        }
        static bool VerifyData(byte[] data, byte[] signature)
        {
            return rsa.VerifyData(data, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
        }
    }
    public class AesRsaEncryption
    {
        public static void EncryptFile(string inputFilePath, string outputFilePath, RSAParameters publicKey)
        {
            using (Aes aes = Aes.Create())
            {
                aes.GenerateKey();
                aes.GenerateIV();
                using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    byte[] buffer = new byte[1024];
                    int bytesRead;
                    while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                    {
                        cryptoStream.Write(buffer, 0, bytesRead);
                    }
                }
                using (RSA rsa = new RSACryptoServiceProvider())
                {
                    rsa.ImportParameters(publicKey);
                    byte[] encryptedKey = rsa.Encrypt(aes.Key, RSAEncryptionPadding.Pkcs1);
                    File.WriteAllBytes(outputFilePath + , encryptedKey.Concat(aes.IV).ToArray());
                }
            }
        }
        public static void DecryptFile(string inputFilePath, string keyFilePath, string outputFilePath, RSAParameters privateKey)
        {
            byte[] encryptedData = File.ReadAllBytes(keyFilePath);
            byte[] encryptedKey = encryptedData.Take(encryptedData.Length - 16).ToArray();
            byte[] iv = encryptedData.Skip(encryptedData.Length - 16).ToArray();
            using (RSA rsa = new RSACryptoServiceProvider())
            {
                rsa.ImportParameters(privateKey);
                byte[] decryptedKey = rsa.Decrypt(encryptedKey, RSAEncryptionPadding.Pkcs1);
                using (Aes aes = Aes.Create())
                {
                    aes.Key = decryptedKey;
                    aes.IV = iv;
                    using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                    using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                    using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        byte[] buffer = new byte[1024];
                        int bytesRead;
                        while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                        {
                            cryptoStream.Write(buffer, 0, bytesRead);
                        }
                    }
                }
            }
        }
    }
}",CryptoAlgorithmsImplementations.cs
"using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using Spectre.Console;
namespace Implementation
{
    public class PasswordGenerator
    {
        private static readonly string LowercaseChars = ;
        private static readonly string UppercaseChars = ;
        private static readonly string NumberChars = ;
        private static readonly string SpecialChars = ;
        public static string GeneratePassword(bool useLowercase, bool useUppercase, bool useNumbers, bool useSpecial, int length)
        {
            if (length <= 0 || (!useLowercase && !useUppercase && !useNumbers && !useSpecial))
            {
                throw new ArgumentException();
            }
            string charPool = (useLowercase ? LowercaseChars : ) +
                              (useUppercase ? UppercaseChars : ) +
                              (useNumbers ? NumberChars : ) +
                              (useSpecial ? SpecialChars : );
            var bytes = new byte[length];
            RandomNumberGenerator.Fill(bytes);
            return new string(bytes.Select(b => charPool[b % charPool.Length]).ToArray());
        }
    }
    public class EntropyCalculator
    {
        public static double CalculateStringEntropy(string input)
        {
            if (string.IsNullOrEmpty(input))
                return 0.0; 
            Dictionary<char, int> charCounts = new Dictionary<char, int>();
            foreach (char c in input)
            {
                if (charCounts.ContainsKey(c))
                    charCounts[c]++;
                else
                    charCounts[c] = 1;
            }
            double entropy = 0.0;
            int totalChars = input.Length;
            foreach (var count in charCounts.Values)
            {
                double probability = (double)count / totalChars;
                entropy += probability * Math.Log2(probability);
            }
            return -entropy;
        }
    }
    public class Encrypt
    {
        public static void EncryptFile(string inputFile, string outputFile, string password)","{
            using (Aes aes = Aes.Create())
            {","byte[] salt = new byte[16]; 
                RandomNumberGenerator.Fill(salt);
                int iterations = 100000;
                Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                aes.Key = pdb.GetBytes(32);
                aes.IV = pdb.GetBytes(16);
                using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                {
                    fsOutput.Write(salt, 0, salt.Length);
                    using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                    using (CryptoStream cs = new CryptoStream(fsOutput, aes.CreateEncryptor(), CryptoStreamMode.Write))
                    {
                        int data;
                        while ((data = fsInput.ReadByte()) != -1)
                        {
                            cs.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Decrypt
    {
        public static void DecryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16];
                using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                {
                    fsInput.Read(salt, 0, salt.Length);
                    int iterations = 100000;
                    Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                    aes.Key = pdb.GetBytes(32);
                    aes.IV = pdb.GetBytes(16);
                    using (CryptoStream cs = new CryptoStream(fsInput, aes.CreateDecryptor(), CryptoStreamMode.Read))
                    using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                    {
                        int data;
                        while ((data = cs.ReadByte()) != -1)
                        {
                            fsOutput.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Hashing
    {
        public static string HashingFileWithSHA256(string filePath)
        {
            using SHA256 sha256 = SHA256.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha256.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithSHA1(string filePath)
        {
            using SHA1 sha1 = SHA1.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha1.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithMD5(string filePath)
        {
            using MD5 md5 = MD5.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(md5.ComputeHash(stream)).Replace(, ).ToLower();
        }
    }
    public class ImageSteganography
    {
        public enum State
        {
            Hiding,
            Filling_With_Zeros
        };
        public static void embedText(string text, string inputImagePath)
        {
            string originalFilePath = inputImagePath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            Bitmap bmp = new Bitmap(inputImagePath);
            State state = State.Hiding;
            int charIndex = 0;
            int charValue = 0;
            long pixelElementIndex = 0;
            int zeros = 0;
            int R = 0, G = 0, B = 0;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                { 
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    R = pixel.R - pixel.R % 2;
                    G = pixel.G - pixel.G % 2;
                    B = pixel.B - pixel.B % 2;
                    for (int n = 0; n < 3; n++)
                    {
                        if (pixelElementIndex % 8 == 0)
                        { 
                            if (state == State.Filling_With_Zeros && zeros == 8)
                            {
                                if ((pixelElementIndex - 1) % 3 < 2)
                                {
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                bmp.Save(newFilePath, ImageFormat.Png);
                            }
                            if (charIndex >= text.Length)
                            {
                                state = State.Filling_With_Zeros;
                            }
                            else
                            {
                                charValue = text[charIndex++];
                            }
                        }
                        switch (pixelElementIndex % 3)
                        {
                            case 0:
                                {
                                    if (state == State.Hiding)
                                    {
                                        R += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 1:
                                {
                                    if (state == State.Hiding)
                                    {
                                        G += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 2:
                                {
                                    if (state == State.Hiding)
                                    {
                                        B += charValue % 2;
                                        charValue /= 2;
                                    }
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                break;
                        }
                        pixelElementIndex++;
                        if (state == State.Filling_With_Zeros)
                        {
                            zeros++;
                        }
                    }
                }
            }
            bmp.Save(newFilePath, ImageFormat.Png);
        }
        public static string extractText(Bitmap bmp)
        {
            int colorUnitIndex = 0;
            int charValue = 0;
            string extractedText = String.Empty;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                {
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    for (int n = 0; n < 3; n++)
                    {
                        switch (colorUnitIndex % 3)
                        {
                            case 0:
                                {
                                    charValue = charValue * 2 + pixel.R % 2;
                                }
                                break;
                            case 1:
                                {
                                    charValue = charValue * 2 + pixel.G % 2;
                                }
                                break;
                            case 2:
                                {
                                    charValue = charValue * 2 + pixel.B % 2;
                                }
                                break;
                        }
                        colorUnitIndex++;
                        if (colorUnitIndex % 8 == 0)
                        {
                            charValue = reverseBits(charValue);
                            if (charValue == 0)
                            {
                                return extractedText;
                            }
                            char c = (char)charValue;
                            extractedText += c.ToString();
                        }
                    }
                }
            }
            return extractedText;
        }
        public static int reverseBits(int n)
        {
            int result = 0;
            for (int i = 0; i < 8; i++)
            {
                result = result * 2 + n % 2;
                n /= 2;
            }
            return result;
        }
    }
    class AudioSteganography
    {
        const int HEADER_SIZE = 4; 
        const int BYTE_INTERVAL = 16; 
        public static void HideMessageInAudio(string inputAudioPath, string message)
        {
            byte[] messageBytes = Encoding.ASCII.GetBytes(message);
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes.Length >> (i * 8 + j)) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit); 
                    audioIndex += BYTE_INTERVAL;
                }
            }
            for (int i = 0; i < messageBytes.Length; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes[i] >> j) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            string originalFilePath = inputAudioPath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            File.WriteAllBytes(newFilePath, audioBytes);
        }
        public static string ExtractMessageFromAudio(string inputAudioPath)
        {
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            int messageLength = 0;
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageLength |= (bit << (i * 8 + j));
                    audioIndex += BYTE_INTERVAL;
                }
            }
            byte[] messageBytes = new byte[messageLength];
            for (int i = 0; i < messageLength; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageBytes[i] |= (byte)(bit << j);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            return Encoding.ASCII.GetString(messageBytes);
        }
    }
    public class DigitalSignature
    {
        static RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(2048);
        static RSAParameters publicKey;
        static RSAParameters privateKey;
        public static void GenerateKeys(string publicKeyPath)
        {
            publicKey = rsa.ExportParameters(false);
            privateKey = rsa.ExportParameters(true);
            var publicKeyXml = rsa.ToXmlString(false);
            var privateKeyXml = rsa.ToXmlString(true);
            var publicKeyFullPath = Path.Combine(publicKeyPath, );
            var privateKeyFullPath = Path.Combine(publicKeyPath, );
            File.WriteAllText(publicKeyFullPath, publicKeyXml);
            File.WriteAllText(privateKeyFullPath, privateKeyXml);
            AnsiConsole.MarkupLine($);
        }
        public static void UploadKeys(string privateKeyPath)
        {
            var privateKeyXml = File.ReadAllText(privateKeyPath);
            rsa.FromXmlString(privateKeyXml);
            privateKey = rsa.ExportParameters(true);
        }
        public static void SignDocument(string documentPath)
        {
            if (privateKey.D == null)
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            if (!File.Exists(documentPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = SignData(data, privateKey);
            var signaturePath = documentPath + ;
            File.WriteAllBytes(signaturePath, signature);
            AnsiConsole.MarkupLine($);
        }
        public static void VerifyDocumentSignature(string documentPath, string signaturePath, string publicKeyPath)
        {
            if (!File.Exists(publicKeyPath))
            {
                Console.WriteLine();
                return;
            }
            var publicKeyXml = File.ReadAllText(publicKeyPath);
            rsa.FromXmlString(publicKeyXml);
            if (!File.Exists(signaturePath))
            {
                Console.WriteLine();
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = File.ReadAllBytes(signaturePath);
            var isVerified = VerifyData(data, signature);
            AnsiConsole.MarkupLine($);
        }
        public static byte[] SignData(byte[] data, RSAParameters privateKey)
        {
            rsa.ImportParameters(privateKey);
            var signedData = rsa.SignData(data, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            return signedData;
        }
        static bool VerifyData(byte[] data, byte[] signature)
        {
            return rsa.VerifyData(data, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
        }
    }
    public class AesRsaEncryption
    {
        public static void EncryptFile(string inputFilePath, string outputFilePath, RSAParameters publicKey)
        {
            using (Aes aes = Aes.Create())
            {
                aes.GenerateKey();
                aes.GenerateIV();
                using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    byte[] buffer = new byte[1024];
                    int bytesRead;
                    while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                    {
                        cryptoStream.Write(buffer, 0, bytesRead);
                    }
                }
                using (RSA rsa = new RSACryptoServiceProvider())
                {
                    rsa.ImportParameters(publicKey);
                    byte[] encryptedKey = rsa.Encrypt(aes.Key, RSAEncryptionPadding.Pkcs1);
                    File.WriteAllBytes(outputFilePath + , encryptedKey.Concat(aes.IV).ToArray());
                }
            }
        }
        public static void DecryptFile(string inputFilePath, string keyFilePath, string outputFilePath, RSAParameters privateKey)
        {
            byte[] encryptedData = File.ReadAllBytes(keyFilePath);
            byte[] encryptedKey = encryptedData.Take(encryptedData.Length - 16).ToArray();
            byte[] iv = encryptedData.Skip(encryptedData.Length - 16).ToArray();
            using (RSA rsa = new RSACryptoServiceProvider())
            {
                rsa.ImportParameters(privateKey);
                byte[] decryptedKey = rsa.Decrypt(encryptedKey, RSAEncryptionPadding.Pkcs1);
                using (Aes aes = Aes.Create())
                {
                    aes.Key = decryptedKey;
                    aes.IV = iv;
                    using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                    using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                    using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        byte[] buffer = new byte[1024];
                        int bytesRead;
                        while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                        {
                            cryptoStream.Write(buffer, 0, bytesRead);
                        }
                    }
                }
            }
        }
    }
}",CryptoAlgorithmsImplementations.cs
"using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using Spectre.Console;
namespace Implementation
{
    public class PasswordGenerator
    {
        private static readonly string LowercaseChars = ;
        private static readonly string UppercaseChars = ;
        private static readonly string NumberChars = ;
        private static readonly string SpecialChars = ;
        public static string GeneratePassword(bool useLowercase, bool useUppercase, bool useNumbers, bool useSpecial, int length)
        {
            if (length <= 0 || (!useLowercase && !useUppercase && !useNumbers && !useSpecial))
            {
                throw new ArgumentException();
            }
            string charPool = (useLowercase ? LowercaseChars : ) +
                              (useUppercase ? UppercaseChars : ) +
                              (useNumbers ? NumberChars : ) +
                              (useSpecial ? SpecialChars : );
            var bytes = new byte[length];
            RandomNumberGenerator.Fill(bytes);
            return new string(bytes.Select(b => charPool[b % charPool.Length]).ToArray());
        }
    }
    public class EntropyCalculator
    {
        public static double CalculateStringEntropy(string input)
        {
            if (string.IsNullOrEmpty(input))
                return 0.0; 
            Dictionary<char, int> charCounts = new Dictionary<char, int>();
            foreach (char c in input)
            {
                if (charCounts.ContainsKey(c))
                    charCounts[c]++;
                else
                    charCounts[c] = 1;
            }
            double entropy = 0.0;
            int totalChars = input.Length;
            foreach (var count in charCounts.Values)
            {
                double probability = (double)count / totalChars;
                entropy += probability * Math.Log2(probability);
            }
            return -entropy;
        }
    }
    public class Encrypt
    {
        public static void EncryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16]; 
                RandomNumberGenerator.Fill(salt);
                int iterations = 100000;
                Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                aes.Key = pdb.GetBytes(32);
                aes.IV = pdb.GetBytes(16);
                using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                {
                    fsOutput.Write(salt, 0, salt.Length);
                    using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                    using (CryptoStream cs = new CryptoStream(fsOutput, aes.CreateEncryptor(), CryptoStreamMode.Write))
                    {
                        int data;
                        while ((data = fsInput.ReadByte()) != -1)
                        {
                            cs.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Decrypt
    {
        public static void DecryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16];
                using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                {
                    fsInput.Read(salt, 0, salt.Length);
                    int iterations = 100000;
                    Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                    aes.Key = pdb.GetBytes(32);
                    aes.IV = pdb.GetBytes(16);
                    using (CryptoStream cs = new CryptoStream(fsInput, aes.CreateDecryptor(), CryptoStreamMode.Read))
                    using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                    {
                        int data;
                        while ((data = cs.ReadByte()) != -1)
                        {
                            fsOutput.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Hashing
    {
        public static string HashingFileWithSHA256(string filePath)
        {
            using SHA256 sha256 = SHA256.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha256.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithSHA1(string filePath)
        {
            using SHA1 sha1 = SHA1.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha1.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithMD5(string filePath)
        {
            using MD5 md5 = MD5.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(md5.ComputeHash(stream)).Replace(, ).ToLower();
        }
    }
    public class ImageSteganography
    {
        public enum State
        {
            Hiding,
            Filling_With_Zeros
        };
        public static void embedText(string text, string inputImagePath)
        {
            string originalFilePath = inputImagePath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            Bitmap bmp = new Bitmap(inputImagePath);
            State state = State.Hiding;
            int charIndex = 0;
            int charValue = 0;
            long pixelElementIndex = 0;
            int zeros = 0;
            int R = 0, G = 0, B = 0;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                { 
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    R = pixel.R - pixel.R % 2;
                    G = pixel.G - pixel.G % 2;
                    B = pixel.B - pixel.B % 2;
                    for (int n = 0; n < 3; n++)
                    {
                        if (pixelElementIndex % 8 == 0)
                        { 
                            if (state == State.Filling_With_Zeros && zeros == 8)
                            {
                                if ((pixelElementIndex - 1) % 3 < 2)
                                {
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                bmp.Save(newFilePath, ImageFormat.Png);
                            }
                            if (charIndex >= text.Length)
                            {
                                state = State.Filling_With_Zeros;
                            }
                            else
                            {
                                charValue = text[charIndex++];
                            }
                        }
                        switch (pixelElementIndex % 3)
                        {
                            case 0:
                                {
                                    if (state == State.Hiding)
                                    {
                                        R += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 1:
                                {
                                    if (state == State.Hiding)
                                    {
                                        G += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 2:
                                {
                                    if (state == State.Hiding)
                                    {
                                        B += charValue % 2;
                                        charValue /= 2;
                                    }
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                break;
                        }
                        pixelElementIndex++;
                        if (state == State.Filling_With_Zeros)
                        {
                            zeros++;
                        }
                    }
                }
            }
            bmp.Save(newFilePath, ImageFormat.Png);
        }
        public static string extractText(Bitmap bmp)
        {
            int colorUnitIndex = 0;
            int charValue = 0;
            string extractedText = String.Empty;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                {
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    for (int n = 0; n < 3; n++)
                    {
                        switch (colorUnitIndex % 3)
                        {
                            case 0:
                                {
                                    charValue = charValue * 2 + pixel.R % 2;
                                }
                                break;
                            case 1:
                                {
                                    charValue = charValue * 2 + pixel.G % 2;
                                }
                                break;
                            case 2:
                                {
                                    charValue = charValue * 2 + pixel.B % 2;
                                }
                                break;
                        }
                        colorUnitIndex++;
                        if (colorUnitIndex % 8 == 0)
                        {
                            charValue = reverseBits(charValue);
                            if (charValue == 0)
                            {
                                return extractedText;
                            }
                            char c = (char)charValue;
                            extractedText += c.ToString();
                        }
                    }
                }
            }
            return extractedText;
        }
        public static int reverseBits(int n)
        {
            int result = 0;
            for (int i = 0; i < 8; i++)
            {
                result = result * 2 + n % 2;
                n /= 2;
            }
            return result;
        }
    }
    class AudioSteganography
    {
        const int HEADER_SIZE = 4; 
        const int BYTE_INTERVAL = 16; 
        public static void HideMessageInAudio(string inputAudioPath, string message)
        {
            byte[] messageBytes = Encoding.ASCII.GetBytes(message);
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes.Length >> (i * 8 + j)) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit); 
                    audioIndex += BYTE_INTERVAL;
                }
            }
            for (int i = 0; i < messageBytes.Length; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes[i] >> j) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            string originalFilePath = inputAudioPath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            File.WriteAllBytes(newFilePath, audioBytes);
        }
        public static string ExtractMessageFromAudio(string inputAudioPath)
        {
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            int messageLength = 0;
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageLength |= (bit << (i * 8 + j));","audioIndex += BYTE_INTERVAL;
                }
            }","byte[] messageBytes = new byte[messageLength];
            for (int i = 0; i < messageLength; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageBytes[i] |= (byte)(bit << j);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            return Encoding.ASCII.GetString(messageBytes);
        }
    }
    public class DigitalSignature
    {
        static RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(2048);
        static RSAParameters publicKey;
        static RSAParameters privateKey;
        public static void GenerateKeys(string publicKeyPath)
        {
            publicKey = rsa.ExportParameters(false);
            privateKey = rsa.ExportParameters(true);
            var publicKeyXml = rsa.ToXmlString(false);
            var privateKeyXml = rsa.ToXmlString(true);
            var publicKeyFullPath = Path.Combine(publicKeyPath, );
            var privateKeyFullPath = Path.Combine(publicKeyPath, );
            File.WriteAllText(publicKeyFullPath, publicKeyXml);
            File.WriteAllText(privateKeyFullPath, privateKeyXml);
            AnsiConsole.MarkupLine($);
        }
        public static void UploadKeys(string privateKeyPath)
        {
            var privateKeyXml = File.ReadAllText(privateKeyPath);
            rsa.FromXmlString(privateKeyXml);
            privateKey = rsa.ExportParameters(true);
        }
        public static void SignDocument(string documentPath)
        {
            if (privateKey.D == null)
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            if (!File.Exists(documentPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = SignData(data, privateKey);
            var signaturePath = documentPath + ;
            File.WriteAllBytes(signaturePath, signature);
            AnsiConsole.MarkupLine($);
        }
        public static void VerifyDocumentSignature(string documentPath, string signaturePath, string publicKeyPath)
        {
            if (!File.Exists(publicKeyPath))
            {
                Console.WriteLine();
                return;
            }
            var publicKeyXml = File.ReadAllText(publicKeyPath);
            rsa.FromXmlString(publicKeyXml);
            if (!File.Exists(signaturePath))
            {
                Console.WriteLine();
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = File.ReadAllBytes(signaturePath);
            var isVerified = VerifyData(data, signature);
            AnsiConsole.MarkupLine($);
        }
        public static byte[] SignData(byte[] data, RSAParameters privateKey)
        {
            rsa.ImportParameters(privateKey);
            var signedData = rsa.SignData(data, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            return signedData;
        }
        static bool VerifyData(byte[] data, byte[] signature)
        {
            return rsa.VerifyData(data, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
        }
    }
    public class AesRsaEncryption
    {
        public static void EncryptFile(string inputFilePath, string outputFilePath, RSAParameters publicKey)
        {
            using (Aes aes = Aes.Create())
            {
                aes.GenerateKey();
                aes.GenerateIV();
                using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    byte[] buffer = new byte[1024];
                    int bytesRead;
                    while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                    {
                        cryptoStream.Write(buffer, 0, bytesRead);
                    }
                }
                using (RSA rsa = new RSACryptoServiceProvider())
                {
                    rsa.ImportParameters(publicKey);
                    byte[] encryptedKey = rsa.Encrypt(aes.Key, RSAEncryptionPadding.Pkcs1);
                    File.WriteAllBytes(outputFilePath + , encryptedKey.Concat(aes.IV).ToArray());
                }
            }
        }
        public static void DecryptFile(string inputFilePath, string keyFilePath, string outputFilePath, RSAParameters privateKey)
        {
            byte[] encryptedData = File.ReadAllBytes(keyFilePath);
            byte[] encryptedKey = encryptedData.Take(encryptedData.Length - 16).ToArray();
            byte[] iv = encryptedData.Skip(encryptedData.Length - 16).ToArray();
            using (RSA rsa = new RSACryptoServiceProvider())
            {
                rsa.ImportParameters(privateKey);
                byte[] decryptedKey = rsa.Decrypt(encryptedKey, RSAEncryptionPadding.Pkcs1);
                using (Aes aes = Aes.Create())
                {
                    aes.Key = decryptedKey;
                    aes.IV = iv;
                    using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                    using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                    using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        byte[] buffer = new byte[1024];
                        int bytesRead;
                        while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                        {
                            cryptoStream.Write(buffer, 0, bytesRead);
                        }
                    }
                }
            }
        }
    }
}",CryptoAlgorithmsImplementations.cs
"using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Drawing;
using System.Drawing.Imaging;
using Spectre.Console;
namespace Implementation
{
    public class PasswordGenerator
    {
        private static readonly string LowercaseChars = ;
        private static readonly string UppercaseChars = ;
        private static readonly string NumberChars = ;
        private static readonly string SpecialChars = ;
        public static string GeneratePassword(bool useLowercase, bool useUppercase, bool useNumbers, bool useSpecial, int length)
        {
            if (length <= 0 || (!useLowercase && !useUppercase && !useNumbers && !useSpecial))
            {
                throw new ArgumentException();
            }
            string charPool = (useLowercase ? LowercaseChars : ) +
                              (useUppercase ? UppercaseChars : ) +
                              (useNumbers ? NumberChars : ) +
                              (useSpecial ? SpecialChars : );
            var bytes = new byte[length];
            RandomNumberGenerator.Fill(bytes);
            return new string(bytes.Select(b => charPool[b % charPool.Length]).ToArray());
        }
    }
    public class EntropyCalculator
    {
        public static double CalculateStringEntropy(string input)
        {
            if (string.IsNullOrEmpty(input))
                return 0.0; 
            Dictionary<char, int> charCounts = new Dictionary<char, int>();
            foreach (char c in input)
            {
                if (charCounts.ContainsKey(c))
                    charCounts[c]++;
                else
                    charCounts[c] = 1;
            }
            double entropy = 0.0;
            int totalChars = input.Length;
            foreach (var count in charCounts.Values)
            {
                double probability = (double)count / totalChars;
                entropy += probability * Math.Log2(probability);
            }
            return -entropy;
        }
    }
    public class Encrypt
    {
        public static void EncryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16]; 
                RandomNumberGenerator.Fill(salt);
                int iterations = 100000;
                Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                aes.Key = pdb.GetBytes(32);
                aes.IV = pdb.GetBytes(16);
                using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                {
                    fsOutput.Write(salt, 0, salt.Length);
                    using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                    using (CryptoStream cs = new CryptoStream(fsOutput, aes.CreateEncryptor(), CryptoStreamMode.Write))
                    {
                        int data;
                        while ((data = fsInput.ReadByte()) != -1)
                        {
                            cs.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Decrypt
    {
        public static void DecryptFile(string inputFile, string outputFile, string password)
        {
            using (Aes aes = Aes.Create())
            {
                byte[] salt = new byte[16];
                using (FileStream fsInput = new FileStream(inputFile, FileMode.Open))
                {
                    fsInput.Read(salt, 0, salt.Length);
                    int iterations = 100000;
                    Rfc2898DeriveBytes pdb = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
                    aes.Key = pdb.GetBytes(32);
                    aes.IV = pdb.GetBytes(16);
                    using (CryptoStream cs = new CryptoStream(fsInput, aes.CreateDecryptor(), CryptoStreamMode.Read))
                    using (FileStream fsOutput = new FileStream(outputFile, FileMode.Create))
                    {
                        int data;
                        while ((data = cs.ReadByte()) != -1)
                        {
                            fsOutput.WriteByte((byte)data);
                        }
                    }
                }
            }
        }
    }
    public class Hashing
    {
        public static string HashingFileWithSHA256(string filePath)
        {
            using SHA256 sha256 = SHA256.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha256.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithSHA1(string filePath)
        {
            using SHA1 sha1 = SHA1.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(sha1.ComputeHash(stream)).Replace(, ).ToLower();
        }
        public static string HashFileWithMD5(string filePath)
        {
            using MD5 md5 = MD5.Create();
            using FileStream stream = File.OpenRead(filePath);
            return BitConverter.ToString(md5.ComputeHash(stream)).Replace(, ).ToLower();
        }
    }
    public class ImageSteganography
    {
        public enum State
        {
            Hiding,
            Filling_With_Zeros
        };
        public static void embedText(string text, string inputImagePath)
        {
            string originalFilePath = inputImagePath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            Bitmap bmp = new Bitmap(inputImagePath);
            State state = State.Hiding;
            int charIndex = 0;
            int charValue = 0;
            long pixelElementIndex = 0;
            int zeros = 0;
            int R = 0, G = 0, B = 0;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                { 
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    R = pixel.R - pixel.R % 2;
                    G = pixel.G - pixel.G % 2;
                    B = pixel.B - pixel.B % 2;
                    for (int n = 0; n < 3; n++)
                    {
                        if (pixelElementIndex % 8 == 0)
                        { 
                            if (state == State.Filling_With_Zeros && zeros == 8)
                            {
                                if ((pixelElementIndex - 1) % 3 < 2)
                                {
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                bmp.Save(newFilePath, ImageFormat.Png);
                            }
                            if (charIndex >= text.Length)
                            {
                                state = State.Filling_With_Zeros;
                            }
                            else
                            {
                                charValue = text[charIndex++];
                            }
                        }
                        switch (pixelElementIndex % 3)
                        {
                            case 0:
                                {
                                    if (state == State.Hiding)
                                    {
                                        R += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 1:
                                {
                                    if (state == State.Hiding)
                                    {
                                        G += charValue % 2;
                                        charValue /= 2;
                                    }
                                }
                                break;
                            case 2:
                                {
                                    if (state == State.Hiding)
                                    {
                                        B += charValue % 2;
                                        charValue /= 2;
                                    }
                                    bmp.SetPixel(j, i, System.Drawing.Color.FromArgb(R, G, B));
                                }
                                break;
                        }
                        pixelElementIndex++;
                        if (state == State.Filling_With_Zeros)
                        {
                            zeros++;
                        }
                    }
                }
            }
            bmp.Save(newFilePath, ImageFormat.Png);
        }
        public static string extractText(Bitmap bmp)
        {
            int colorUnitIndex = 0;
            int charValue = 0;
            string extractedText = String.Empty;
            for (int i = 0; i < bmp.Height; i++)
            {
                for (int j = 0; j < bmp.Width; j++)
                {
                    System.Drawing.Color pixel = bmp.GetPixel(j, i);
                    for (int n = 0; n < 3; n++)
                    {
                        switch (colorUnitIndex % 3)
                        {
                            case 0:
                                {
                                    charValue = charValue * 2 + pixel.R % 2;
                                }
                                break;
                            case 1:
                                {
                                    charValue = charValue * 2 + pixel.G % 2;
                                }
                                break;
                            case 2:
                                {
                                    charValue = charValue * 2 + pixel.B % 2;
                                }
                                break;
                        }
                        colorUnitIndex++;
                        if (colorUnitIndex % 8 == 0)
                        {
                            charValue = reverseBits(charValue);
                            if (charValue == 0)
                            {
                                return extractedText;
                            }
                            char c = (char)charValue;
                            extractedText += c.ToString();
                        }
                    }
                }
            }
            return extractedText;
        }
        public static int reverseBits(int n)
        {
            int result = 0;
            for (int i = 0; i < 8; i++)
            {
                result = result * 2 + n % 2;
                n /= 2;
            }
            return result;
        }
    }
    class AudioSteganography
    {
        const int HEADER_SIZE = 4; 
        const int BYTE_INTERVAL = 16; 
        public static void HideMessageInAudio(string inputAudioPath, string message)
        {
            byte[] messageBytes = Encoding.ASCII.GetBytes(message);
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes.Length >> (i * 8 + j)) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit); 
                    audioIndex += BYTE_INTERVAL;
                }
            }
            for (int i = 0; i < messageBytes.Length; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)((messageBytes[i] >> j) & 1);
                    audioBytes[audioIndex] = (byte)((audioBytes[audioIndex] & 0xFE) | bit);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            string originalFilePath = inputAudioPath;
            string directory = Path.GetDirectoryName(originalFilePath);
            string originalFileName = Path.GetFileName(originalFilePath);
            string newFileName =  + originalFileName;
            string newFilePath = Path.Combine(directory, newFileName);
            File.WriteAllBytes(newFilePath, audioBytes);
        }
        public static string ExtractMessageFromAudio(string inputAudioPath)
        {
            byte[] audioBytes = File.ReadAllBytes(inputAudioPath);
            int audioIndex = 44; 
            int messageLength = 0;
            for (int i = 0; i < HEADER_SIZE; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageLength |= (bit << (i * 8 + j));
                    audioIndex += BYTE_INTERVAL;
                }
            }
            byte[] messageBytes = new byte[messageLength];
            for (int i = 0; i < messageLength; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    byte bit = (byte)(audioBytes[audioIndex] & 1);
                    messageBytes[i] |= (byte)(bit << j);
                    audioIndex += BYTE_INTERVAL;
                }
            }
            return Encoding.ASCII.GetString(messageBytes);
        }
    }
    public class DigitalSignature
    {
        static RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(2048);
        static RSAParameters publicKey;
        static RSAParameters privateKey;
        public static void GenerateKeys(string publicKeyPath)
        {
            publicKey = rsa.ExportParameters(false);
            privateKey = rsa.ExportParameters(true);
            var publicKeyXml = rsa.ToXmlString(false);
            var privateKeyXml = rsa.ToXmlString(true);
            var publicKeyFullPath = Path.Combine(publicKeyPath, );
            var privateKeyFullPath = Path.Combine(publicKeyPath, );
            File.WriteAllText(publicKeyFullPath, publicKeyXml);
            File.WriteAllText(privateKeyFullPath, privateKeyXml);
            AnsiConsole.MarkupLine($);
        }
        public static void UploadKeys(string privateKeyPath)
        {
            var privateKeyXml = File.ReadAllText(privateKeyPath);
            rsa.FromXmlString(privateKeyXml);
            privateKey = rsa.ExportParameters(true);
        }
        public static void SignDocument(string documentPath)
        {
            if (privateKey.D == null)
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            if (!File.Exists(documentPath))
            {
                AnsiConsole.MarkupLine($);
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = SignData(data, privateKey);
            var signaturePath = documentPath + ;
            File.WriteAllBytes(signaturePath, signature);
            AnsiConsole.MarkupLine($);
        }
        public static void VerifyDocumentSignature(string documentPath, string signaturePath, string publicKeyPath)
        {
            if (!File.Exists(publicKeyPath))
            {
                Console.WriteLine();
                return;
            }
            var publicKeyXml = File.ReadAllText(publicKeyPath);
            rsa.FromXmlString(publicKeyXml);
            if (!File.Exists(signaturePath))
            {
                Console.WriteLine();
                return;
            }
            var data = File.ReadAllBytes(documentPath);
            var signature = File.ReadAllBytes(signaturePath);
            var isVerified = VerifyData(data, signature);
            AnsiConsole.MarkupLine($);
        }
        public static byte[] SignData(byte[] data, RSAParameters privateKey)
        {
            rsa.ImportParameters(privateKey);
            var signedData = rsa.SignData(data, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            return signedData;
        }
        static bool VerifyData(byte[] data, byte[] signature)
        {
            return rsa.VerifyData(data, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
        }
    }
    public class AesRsaEncryption
    {
        public static void EncryptFile(string inputFilePath, string outputFilePath, RSAParameters publicKey)
        {
            using (Aes aes = Aes.Create())
            {
                aes.GenerateKey();
                aes.GenerateIV();
                using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateEncryptor(), CryptoStreamMode.Write))
                {
                    byte[] buffer = new byte[1024];
                    int bytesRead;
                    while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                    {
                        cryptoStream.Write(buffer, 0, bytesRead);
                    }
                }
                using (RSA rsa = new RSACryptoServiceProvider())
                {
                    rsa.ImportParameters(publicKey);
                    byte[] encryptedKey = rsa.Encrypt(aes.Key, RSAEncryptionPadding.Pkcs1);
                    File.WriteAllBytes(outputFilePath + , encryptedKey.Concat(aes.IV).ToArray());
                }
            }
        }","public static void DecryptFile(string inputFilePath, string keyFilePath, string outputFilePath, RSAParameters privateKey)
        {
            byte[] encryptedData = File.ReadAllBytes(keyFilePath);","byte[] encryptedKey = encryptedData.Take(encryptedData.Length - 16).ToArray();
            byte[] iv = encryptedData.Skip(encryptedData.Length - 16).ToArray();
            using (RSA rsa = new RSACryptoServiceProvider())
            {
                rsa.ImportParameters(privateKey);
                byte[] decryptedKey = rsa.Decrypt(encryptedKey, RSAEncryptionPadding.Pkcs1);
                using (Aes aes = Aes.Create())
                {
                    aes.Key = decryptedKey;
                    aes.IV = iv;
                    using (FileStream inputFileStream = new FileStream(inputFilePath, FileMode.Open, FileAccess.Read))
                    using (FileStream outputFileStream = new FileStream(outputFilePath, FileMode.Create, FileAccess.Write))
                    using (CryptoStream cryptoStream = new CryptoStream(outputFileStream, aes.CreateDecryptor(), CryptoStreamMode.Write))
                    {
                        byte[] buffer = new byte[1024];
                        int bytesRead;
                        while ((bytesRead = inputFileStream.Read(buffer, 0, buffer.Length)) > 0)
                        {
                            cryptoStream.Write(buffer, 0, bytesRead);
                        }
                    }
                }
            }
        }
    }
}",CryptoAlgorithmsImplementations.cs
